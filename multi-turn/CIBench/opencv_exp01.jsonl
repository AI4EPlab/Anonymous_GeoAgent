{"prompt": "File Path: 'data/opencv_dataset01.jpg'. \n### Load the image from the file path. Display the original RGB image.\n", "code": "import cv2\nimport matplotlib.pyplot as plt\nfile_path = 'data/opencv_dataset01.jpg'\nimage = cv2.imread(file_path)\nplt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))\nplt.show()\n", "library": ["opencv", "matplotlib"], "exlib": ["opencv", "matplotlib"]}
{"prompt": "\n\n### Resize the image to (500,560). Convert the image to grayscale and display the converted image.\n", "code": "resized_image = cv2.resize(image, (500, 560))\ngray_image = cv2.cvtColor(resized_image, cv2.COLOR_BGR2GRAY)\nplt.imshow(gray_image, cmap='gray')\nplt.show()\n", "library": ["opencv", "matplotlib"], "exlib": ["opencv", "matplotlib"]}
{"prompt": "\n\n### Set the Guass kernel size as (3,3) and Guass sigma as 0, apply Guassian blur to the grayscale image. Set the target size as (500,600) and then perform Linear interpolation on the blurred image. Calculate the mean value of the resultant image pixels. Print the result with two decimal places.\n", "code": "import numpy as np\ngaussian_kernel_size = (3, 3)\ngaussian_sigma = 0\nblurred_image = cv2.GaussianBlur(gray_image, gaussian_kernel_size, gaussian_sigma)\ntarget_size = (500, 600)\nresized_image = cv2.resize(blurred_image, target_size, interpolation=cv2.INTER_LINEAR)\nmean_value = np.mean(resized_image)\nround(mean_value,2)\n", "library": ["opencv", "numpy"], "exlib": ["opencv", "numpy"]}
{"prompt": "\n\n### Applying histogram equalization to the blurred grayscale image to enhance its contrast, followed by displaying the resultant image.\n", "code": "equalized_image = cv2.equalizeHist(blurred_image)\nplt.imshow(equalized_image, cmap='gray')\nplt.show()\n", "library": ["opencv", "matplotlib"], "exlib": ["opencv", "matplotlib"]}
{"prompt": "\n\n### Detect edges using the Canny edge detector with canny min-val=80 and canny max-val=200 on the image processed in the previous step. Display the edged image.\n", "code": "canny_min_val = 80\ncanny_max_val = 200\nedges = cv2.Canny(equalized_image, canny_min_val, canny_max_val)\nplt.imshow(edges, cmap='gray')\nplt.show()\n", "library": ["opencv", "matplotlib"], "exlib": ["opencv", "matplotlib"]}
{"prompt": "\n\n### Detect corners using the Shi-Tomas corner detector with max-corners=50, min-distance=0.5 and blocksize=10, mark the corners with circles on the image. Note that the coordinates of corner points must be a tuple of integers. The radius and thickness of the circle are 5 and 1. Show the marked image.\n", "code": "max_corners = 50\nmin_distance = 0.5\nblock_size = 10\ncorners = cv2.goodFeaturesToTrack(equalized_image, max_corners, 0.01, min_distance, blockSize=block_size)\ncorners = np.intp(corners)\n\nmarked_image = resized_image.copy()\nfor corner in corners:\n    x, y = corner.ravel()\n    cv2.circle(marked_image, (x, y), 5, (0, 0, 255), 1)  #circle with radius 5 and thickness 1\n\nplt.imshow(cv2.cvtColor(marked_image, cv2.COLOR_BGR2RGB))\nplt.show()\n", "library": ["opencv", "numpy"], "exlib": ["opencv", "numpy"]}
