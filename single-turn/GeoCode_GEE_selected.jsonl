{"code": "# Load the Green band.\nGreen = (\n    ee.ImageCollection(\"COPERNICUS/S1_GRD\")\n.filterDate(\"2019-11-13\", \"2019-11-26\")\n.filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))\n.filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n.filterMetadata(\"resolution_meters\", \"equals\", 10)\n.select(\"VV\")\n.median()\n)\n", "task": "Define the variable `Green` based on the value of the external variable `ee`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["unknown_function.median", "unknown_function.select", "unknown_function.filterMetadata", "unknown_function.filter", "unknown_function.filter", "unknown_function.filterDate", "ee.ImageCollection", "ee.Filter.listContains", "ee.Filter.eq"], "external_vars": ["ee"], "defined_vars": ["Green"], "parameters": ["VV", "resolution_meters", "equals", 10, "2019-11-13", "2019-11-26", "COPERNICUS/S1_GRD", "transmitterReceiverPolarisation", "VV", "instrumentMode", "IW", "ee.Filter.eq('instrumentMode', 'IW')", "ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')"], "libraries": ["import ee", "import geemap"]}
{"code": "def func_(month):\n    month_img = pr.filter(ee.Filter.calendarRange(month, month, 'month')).sum()\n    date = ee.Date.fromYMD(2023, month, 1)\n    resample = month_img.resample().reproject(crs=month_img.projection().crs(), scale=500)\n    return resample.toInt().set('system:time_start', date.millis()).set('system:index', date.format('YYYY-MM-dd'))\n\npr_monthly = ee.ImageCollection(month_list.map(func_))\n", "task": "Using the provided external variables `ee`, `pr`, `month_list`, and `func_`, create an `ee.ImageCollection` named `pr_monthly` by applying the function `func_` to each month in the `month_list`. Define the following variables within the code: `date`, `month`, `month_img`, and `resample`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ntime_start = '2023'\ntime_end = '2024'\npr = ee.ImageCollection('NOAA/PERSIANN-CDR').filterDate(time_start, time_end)\nmonth_list = ee.List.sequence(1, 12)\n", "functions": ["unknown_function.sum", "pr.filter", "ee.Filter.calendarRange", "ee.Date.fromYMD", "unknown_function.reproject", "month_img.resample", "unknown_function.crs", "month_img.projection", "unknown_function.set", "unknown_function.set", "resample.toInt", "date.millis", "date.format", "ee.ImageCollection", "month_list.map"], "external_vars": ["func_", "month_list", "ee", "pr"], "defined_vars": ["resample", "pr_monthly", "month", "month_img", "date"], "parameters": ["month", "month", "month", 2023, "month", 1, "system:index", "system:time_start", "YYYY-MM-dd", "func_", "ee.Filter.calendarRange(month, month, 'month')", "date.format('YYYY-MM-dd')", "date.millis()", "month_list.map(func_)"], "libraries": ["import geemap", "import ee"]}
{"code": "urban = ee.ImageCollection(\"GOOGLE/DYNAMICWORLD/V1\").select('label').filterDate(time_start, time_end).filterBounds(roi).filter(ee.Filter.calendarRange(5, 9, 'month')).mode().eq(6)\n", "task": "Using the Earth Engine API (ee), create a variable named \"urban\" representing a binary mask indicating urban areas within the specified region of interest (roi) during the time period defined by \"time_start\" and \"time_end\". Specifically, filter the \"GOOGLE/DYNAMICWORLD/V1\" image collection to select only the \"label\" band, applying the following filters:\\n\\n1. Filter by date range using \"time_start\" and \"time_end\".\\n2. Filter by the region of interest using \"roi\".\\n3. Filter to include only months 5 through 9 using `ee.Filter.calendarRange(5, 9, 'month')`.\\n4. Use the `mode()` function to obtain the most frequent label within each pixel.\\n5. Finally, use `eq(6)` to create a binary mask where pixels with a label of 6 (representing urban areas) are set to 1 and all other pixels are set to 0.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ntable = ee.FeatureCollection('FAO/GAUL/2015/level1')\ncor = [24.92986164991798, 60.20951014430325]\npoint = ee.Geometry.Point(cor)\nroi = table.filterBounds(point).map(lambda vec: vec.simplify(1000))\ntime_start = '2023'\ntime_end = '2024'\n", "functions": ["unknown_function.eq", "unknown_function.mode", "unknown_function.filter", "unknown_function.filterBounds", "unknown_function.filterDate", "unknown_function.select", "ee.ImageCollection", "ee.Filter.calendarRange"], "external_vars": ["time_end", "roi", "ee", "time_start"], "defined_vars": ["urban"], "parameters": [6, "roi", "time_start", "time_end", "label", "GOOGLE/DYNAMICWORLD/V1", 5, 9, "month", "ee.Filter.calendarRange(5, 9, 'month')"], "libraries": ["import geemap", "import ee"]}
{"code": "# Apply the function on the previous composite.\ncomposite_with_ndvi2 = add_ndvi(composite_median)\n", "task": "Define a new variable named `composite_with_ndvi2` by applying the `add_ndvi` function to the `composite_median` variable.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the administration boundary data and filter it to the region of interest.\nselangor = ee.FeatureCollection(\n    'FAO/GAUL/2015/level1').filter(ee.Filter.eq('ADM1_NAME', 'Selangor'))\n# Get the Landsat 8 collection and filter it as in previous lab.\nfiltered = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterBounds(\n    selangor).filterDate('2020-06-01', '2020-12-31').sort('CLOUD_COVER')\n# Compute the median composite of the filtered collection.\ncomposite_median = filtered.median()\n# Define a function to calculate and add NDVI to an image.\n\n\ndef add_ndvi(image):\n    ndvi = image.normalizedDifference(['SR_B5', 'SR_B4']).rename('NDVI')\n    return image.addBands(ndvi)\n", "functions": ["add_ndvi"], "external_vars": ["add_ndvi", "composite_median"], "defined_vars": ["composite_with_ndvi2"], "parameters": ["composite_median"], "libraries": ["import geemap", "import ee"]}
{"code": "landsat = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_L2\").filterDate(time_start, time_end).filterBounds(geometry).filter(ee.Filter.lt('CLOUD_COVER', 10)).filter(ee.Filter.eq('WRS_PATH', 168)).filter(ee.Filter.eq('WRS_ROW', 34)).map(func_)\n", "task": "Using the Earth Engine library (ee), define a variable named \"landsat\" that represents an ImageCollection of Landsat 8 data. This collection should be filtered by the following criteria:\\n\\n- Filter by date, selecting images between the dates specified by \"time_start\" and \"time_end\".\\n- Filter to include only images that intersect with the geographic region defined by \"geometry\".\\n- Exclude images with a cloud cover percentage greater than 10%.\\n- Only include images that belong to the WRS path 168 and row 34.\\n- Apply the function \"func_\" to each image in the collection.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ncor = [[45.832858804169355, 36.64822615381035], [46.568942788544355, 36.64822615381035], [46.568942788544355,\n                                                                                          37.17965366966633], [45.832858804169355, 37.17965366966633], [45.832858804169355, 36.64822615381035]]\ngeometry = ee.Geometry.Polygon(cor)\ntime_start = '2013'\ntime_end = '2024'\n\n\ndef func_(img):\n    tir = img.select('ST_B10')\n    tir_gain = ee.Number(img.get('TEMPERATURE_MULT_BAND_ST_B10'))\n    tir_offset = ee.Number(img.get('TEMPERATURE_ADD_BAND_ST_B10'))\n    lst = tir.multiply(tir_gain).add(tir_offset)\n    return lst.rename('landsat').copyProperties(img, ['system:time_start', 'system:index'])\n", "functions": ["unknown_function.map", "unknown_function.filter", "unknown_function.filter", "unknown_function.filter", "unknown_function.filterBounds", "unknown_function.filterDate", "ee.ImageCollection", "ee.Filter.lt", "ee.Filter.eq", "ee.Filter.eq"], "external_vars": ["geometry", "ee", "time_end", "func_", "time_start"], "defined_vars": ["landsat"], "parameters": ["func_", "geometry", "time_start", "time_end", "LANDSAT/LC08/C02/T1_L2", "CLOUD_COVER", 10, "WRS_PATH", 168, "WRS_ROW", 34, "ee.Filter.eq('WRS_ROW', 34)", "ee.Filter.eq('WRS_PATH', 168)", "ee.Filter.lt('CLOUD_COVER', 10)"], "libraries": ["import geemap", "import ee"]}
{"code": "# Visualize the GEDI Mean Biomass data on the map.\nMap.addLayer(l4b.select('MU').clip(c), {'min': 10, 'max': 250, 'palette': '440154,414387,2a788e,23a884,7ad151,fde725'}, 'Mean Biomass')\nMap.centerObject(c, 6)\n\n\n", "task": "Add a layer to the Map object called \"Mean Biomass\" using the 'MU' band from the l4b image, clipped to the geometry 'c'. Set the minimum value to 10, maximum to 250, and use the specified palette. Then, center the Map object on the geometry 'c' with a zoom level of 6. \\n\\n**Required variables:**\\n- Map: Earth Engine Map object.\\n- l4b: Earth Engine Image.\\n- c: Earth Engine Geometry.\\n- **Palette:** A string defining the color palette for the layer.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Load the GEDI data.\nc = ee.FeatureCollection(\n    'USDOS/LSIB_SIMPLE/2017').filter(ee.Filter.eq('country_na', 'Thailand'))\nl4b = ee.Image('LARSE/GEDI/GEDI04_B_002')\n", "functions": ["Map.addLayer", "unknown_function.clip", "l4b.select", "Map.centerObject"], "external_vars": ["c", "l4b", "Map"], "defined_vars": [], "parameters": ["Mean Biomass", "c", "MU", "c", 6, "l4b.select('MU').clip(c)", "{'min': 10, 'max': 250, 'palette': '440154,414387,2a788e,23a884,7ad151,fde725'}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define a function to add indices to each image in a collection.\ndef add_indices(image):\n    ndvi = image.normalizedDifference(['B5', 'B4']).rename('ndvi')\n    ndwi = image.normalizedDifference(['B3', 'B6']).rename('ndwi')\n    return image.addBands(ndvi).addBands(ndwi)\n", "task": "Define a function called `add_indices` that takes an image object as input. This function should calculate the Normalized Difference Vegetation Index (NDVI) and Normalized Difference Water Index (NDWI) using the image's bands. Specifically, NDVI should be calculated using bands `B5` and `B4`, while NDWI should be calculated using bands `B3` and `B6`. Finally, the function should add the calculated `ndvi` and `ndwi` as bands to the input `image` and return the updated image object. The `ndvi` and `ndwi` variables should be defined within the function.", "exec_path": "GEE", "context": "", "functions": ["unknown_function.rename", "image.normalizedDifference", "unknown_function.rename", "image.normalizedDifference", "unknown_function.addBands", "image.addBands"], "external_vars": [], "defined_vars": ["ndvi", "image", "ndwi"], "parameters": ["ndvi", "ndwi", "ndwi", "ndvi", "['B5', 'B4']", "['B3', 'B6']"], "libraries": []}
{"code": "# Add the elevation, elevation_binary, elevation_masked,.And slope layers to the map.\nMap.addLayer(srtm, {min:0, max:5000}, 'elevation')\nMap.addLayer(srtm_lt_1000, {'palette': ['black','red']}, 'elevation_binary')\nMap.addLayer(srtm_masked, {min:0, max:5000}, 'elevation_masked')\nMap.addLayer(slope, {min:0, max:45}, 'slope')\n\n\n", "task": "Add four layers to the map using the `Map.addLayer` function. The first layer is called \"elevation\" and is based on the `srtm` variable, with a minimum value of `min` (0) and a maximum value of `max` (5000). The second layer is called \"elevation_binary\" and is based on the `srtm_lt_1000` variable with a palette of [\"black\", \"red\"]. The third layer is called \"elevation_masked\" and is based on the `srtm_masked` variable, with a minimum value of `min` (0) and a maximum value of `max` (5000). The fourth layer is called \"slope\" and is based on the `slope` variable with a minimum value of 0 and a maximum value of 45. You will need to define the variables `srtm`, `srtm_lt_1000`, `srtm_masked`, `slope`, `min`, `max`, and `Map` before running this code. ", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the SRTM elevation data.\nsrtm = ee.Image('USGS/SRTMGL1_003')\n# Find all pixels with elevation lower than 1000 m.\nsrtm_lt_1000 = srtm.lt(1000)\n# or lower than equal (lte), greater than (gt), greater than equal (gte)\nsrtm_masked = srtm.updateMask(srtm.lt(1000))\n# Calculation of terrain slope from the SRTM30m\nslope = ee.Terrain.slope(srtm)\n", "functions": ["Map.addLayer", "Map.addLayer", "Map.addLayer", "Map.addLayer"], "external_vars": ["srtm_masked", "max", "srtm", "slope", "srtm_lt_1000", "min", "Map"], "defined_vars": [], "parameters": ["srtm", "elevation", "srtm_lt_1000", "elevation_binary", "srtm_masked", "elevation_masked", "slope", "slope", "{min: 0, max: 5000}", "{'palette': ['black', 'red']}", "{min: 0, max: 5000}", "{min: 0, max: 45}"], "libraries": ["import geemap", "import ee"]}
{"code": "time_start = ee.Date('1950')\ntime_end = ee.Date('2023')\ntime_dif = time_end.difference(time_start, 'year').round()\n", "task": "Using the Earth Engine library (ee), calculate the difference between the years 1950 and 2023 and store the result as an integer in the variable `time_dif`.  Define the variables `time_start` and `time_end` for the start and end dates respectively.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Date", "ee.Date", "unknown_function.round", "time_end.difference"], "external_vars": ["ee"], "defined_vars": ["time_start", "time_end", "time_dif"], "parameters": ["1950", "2023", "time_start", "year"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the geometry to be used.\ngeometry = ee.Geometry.Polygon(\n    [[[-73.37330634923838, -48.83382315743275],\n      [-73.37330634923838, -49.43492743084122],\n      [-72.40925605626963, -49.43492743084122],\n      [-72.40925605626963, -48.83382315743275]]], None, False)\n", "task": "Using the ee module, define a variable called `geometry` that represents a polygon with the following coordinates: [[-73.37330634923838, -48.83382315743275], [-73.37330634923838, -49.43492743084122], [-72.40925605626963, -49.43492743084122], [-72.40925605626963, -48.83382315743275]].", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee"], "defined_vars": ["geometry"], "parameters": [null, false, "[[[-73.37330634923838, -48.83382315743275], [-73.37330634923838, -49.43492743084122], [-72.40925605626963, -49.43492743084122], [-72.40925605626963, -48.83382315743275]]]"], "libraries": ["import geemap", "import ee"]}
{"code": "#Example 1: Total fishing effort over date range\n#Filter by \"WLD\" to get all global fishing effort rasters in 2016\nstartDate='2016-01-01'\nendDate='2017-01-01'\neffort_all = gfw.filterMetadata('country', 'equals', 'WLD').filterDate(startDate,endDate)\nprint('effort_all',effort_all)\n# Aggregate 2016 collection to single image of global fishing effort\neffort_2016 = effort_all.sum()\n#We now have a multi-band image where each band contains the total global fishing effort for that gear type. We can isolate global effort for each gear type, like trawlers, by selecting the desired image band.\n", "task": "Use the `gfw` object to filter data for the country \"WLD\" between the dates specified by `startDate` and `endDate`. Store the filtered data in a variable called `effort_all`. Print the `effort_all` variable using the `print` function. Then, calculate the sum of the `effort_all` data and store the result in a variable called `effort_2016`. You will need to define the variables: `effort_2016`, `effort_all`, `endDate`, and `startDate`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Import GFW data\ngfw = ee.ImageCollection('GFW/GFF/V1/fishing_hours')\n", "functions": ["unknown_function.filterDate", "gfw.filterMetadata", "print", "effort_all.sum"], "external_vars": ["gfw", "print"], "defined_vars": ["effort_2016", "startDate", "endDate", "effort_all"], "parameters": ["startDate", "endDate", "country", "equals", "WLD", "effort_all", "effort_all"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the MAIAC - MODIS AOD image collection for August 2019\nAOD_ago2019 = ee.ImageCollection('MODIS/006/MCD19A2_GRANULES').select('Optical_Depth_055').filterDate('2019-08-01', '2019-08-31').filterBounds(pais)\n", "task": "Using the Earth Engine library (ee), define a variable named `AOD_ago2019` to represent a collection of MODIS Aerosol Optical Depth (AOD) images for August 2019, filtered by the region defined by `pais`.  Select only the `Optical_Depth_055` band. ", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Load the borders of South America\nlimites = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017')\npais = limites.filterMetadata('wld_rgn', 'equals', 'South America')\n", "functions": ["unknown_function.filterBounds", "unknown_function.filterDate", "unknown_function.select", "ee.ImageCollection"], "external_vars": ["ee", "pais"], "defined_vars": ["AOD_ago2019"], "parameters": ["pais", "2019-08-01", "2019-08-31", "Optical_Depth_055", "MODIS/006/MCD19A2_GRANULES"], "libraries": ["import ee", "import geemap"]}
{"code": "modis = ee.ImageCollection(\"MODIS/MOD09GA_006_NDVI\").filterDate(time_start, time_end)\n", "task": "Using the Earth Engine library (ee), create an ImageCollection named \"modis\" from the MODIS/MOD09GA_006_NDVI dataset, filtering it by the specified start and end dates (time_start and time_end).", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\ntime_start = '2020'\ntime_end = '2021'\n", "functions": ["unknown_function.filterDate", "ee.ImageCollection"], "external_vars": ["time_end", "ee", "time_start"], "defined_vars": ["modis"], "parameters": ["time_start", "time_end", "MODIS/MOD09GA_006_NDVI"], "libraries": ["import geemap", "import ee"]}
{"code": "# Vectorize the segmentation results.\nvectors = im_snic.reduceToVectors(\n    reducer=ee.Reducer.mean(),\n    geometry=geometry,\n    scale=10,\n    maxPixels=1e13\n)\n", "task": "Using the Earth Engine object `im_snic`, compute the mean value of each superpixel within the specified `geometry`. Define a variable called `vectors` to store the resulting vectors, using a scale of 10 meters and a maximum pixel limit of 10000000000000.0. ", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Define the Sentinel-2 image collection.\nic_s2 = ee.ImageCollection('COPERNICUS/S2_SR')\n# Define the geometry of the area of interest.\ngeometry = ee.Geometry.Polygon([[[-100.89655610713305, 37.8219111973775], [-100.89655610713305, 37.74050705491682],\n                               [-100.72832795771899, 37.74050705491682], [-100.72832795771899, 37.8219111973775]]], None, False)\n# Define the bands of interest.\nbands = ['B2', 'B3', 'B4', 'B8']\n# Filter the image collection by date, cloud cover, and geometry.\nimg = ic_s2.filterDate('2018-01-01', '2020-01-01').filterMetadata(\n    'CLOUDY_PIXEL_PERCENTAGE', 'less_than', 10).filterBounds(geometry).select(bands).median()\n# Define the seed for the segmentation algorithm.\nseed = ee.Algorithms.Image.Segmentation.seedGrid(90)\n# Perform SNIC segmentation on the image.\nim_snic = ee.Algorithms.Image.Segmentation.SNIC(\n    image=img, compactness=100, connectivity=8, neighborhoodSize=100, seeds=seed).reproject('EPSG:4326', None, 10)\n", "functions": ["im_snic.reduceToVectors", "ee.Reducer.mean"], "external_vars": ["im_snic", "geometry", "ee"], "defined_vars": ["vectors"], "parameters": [], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the input polygons\npolygons = ee.FeatureCollection(\"users/englishr18/AlleghenyCounty_Footprints201805\")\n", "task": "Using the ee library, define a variable named \"polygons\" that represents a FeatureCollection from the Google Earth Engine asset \"users/englishr18/AlleghenyCounty_Footprints201805\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.FeatureCollection"], "external_vars": ["ee"], "defined_vars": ["polygons"], "parameters": ["users/englishr18/AlleghenyCounty_Footprints201805"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the ACA/reef_habitat/v1_0 dataset.\ndataset = ee.Image(\"ACA/reef_habitat/v1_0\")\n", "task": "Using the Earth Engine library (`ee`), load the image dataset \"ACA/reef_habitat/v1_0\" and assign it to a variable named `dataset`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["dataset"], "parameters": ["ACA/reef_habitat/v1_0"], "libraries": ["import geemap", "import ee"]}
{"code": "print(repr(\n'''\n# 5. Decision Tree (binarisation)\n# Extraerlo, hacer un árbol de decisión, binarización\nSARchange = LogRatio.gt(1)\nMap.addLayer(SARchange, {'bands': ['logratio'], min: [0], max: [1]}, 'Sentinel-1 Log-Ratio Image')\n'''\n))\n", "task": "Create a boolean mask named `SARchange` by comparing the `LogRatio` image to 1 using the `gt()` function. Then, add this mask to the map as a layer with bands `['logratio']`, a minimum value of 0, and a maximum value of 1. Label the layer \"Sentinel-1 Log-Ratio Image\". \\n\\n**Required variables:**\\n- `LogRatio` (a Google Earth Engine image representing the log ratio of Sentinel-1 data)\\n- `Map` (a Google Earth Engine Map object)", "exec_path": "GEE", "context": "", "functions": ["print", "repr"], "external_vars": ["repr", "print"], "defined_vars": [], "parameters": ["\n# 5. Decision Tree (binarisation)\n# Extraerlo, hacer un árbol de decisión, binarización\nSARchange = LogRatio.gt(1)\nMap.addLayer(SARchange, {'bands': ['logratio'], min: [0], max: [1]}, 'Sentinel-1 Log-Ratio Image')\n", "repr(\"\\n# 5. Decision Tree (binarisation)\\n# Extraerlo, hacer un árbol de decisión, binarización\\nSARchange = LogRatio.gt(1)\\nMap.addLayer(SARchange, {'bands': ['logratio'], min: [0], max: [1]}, 'Sentinel-1 Log-Ratio Image')\\n\")"], "libraries": []}
{"code": "Map.addLayer(water_mask.clip(geometry2), {}, 'water_mask', False)\n", "task": "Add a layer to the Map called \"water_mask\" that shows the water_mask clipped to the geometry2 area. Make the layer non-interactive.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor1 = [-121.30739155546495, 37.83353662375529]\ngeometry = ee.Geometry.Point(cor1)\ncor2 = [[-123.45801418605573, 38.81836572068789], [-122.44589870754011, 38.81836572068789], [-122.44589870754011,\n                                                                                             39.64593638831554], [-123.45801418605573, 39.64593638831554], [-123.45801418605573, 38.81836572068789]]\ngeometry2 = ee.Geometry.Polygon(cor2)\nwater_mask = ee.ImageCollection(\n    'GOOGLE/DYNAMICWORLD/V1').select('label').mode().eq(0)\n", "functions": ["Map.addLayer", "water_mask.clip"], "external_vars": ["geometry2", "Map", "water_mask"], "defined_vars": [], "parameters": ["water_mask", false, "geometry2", "water_mask.clip(geometry2)", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Reduce the NDVI bands to get the median value.\nndvi_composite = ndvi.reduce(ee.Reducer.median())\n", "task": "Calculate the median NDVI value over the entire image using the `ee.Reducer.median()` method. Store the resulting image in a new variable called `ndvi_composite`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the region of interest (AOI).\nAOI = ee.Geometry.Polygon([[[85.93424394561369, 25.902532910616806], [85.93424394561369, 25.890835317934567], [\n                          85.94943597747404, 25.890835317934567], [85.94943597747404, 25.902532910616806]]])\n# Define a function to clip the images to the AOI.\n\n\ndef image_clip(image):\n    return image.clip(AOI)\n# Define a function to calculate the NDVI.\n\n\ndef ndvi_image(image):\n    ndvi = image.normalizedDifference(['B8', 'B4']).rename('NDVI')\n    return image.addBands(ndvi)\n\n\n# Define the start and end dates for the image collection.\nstart_date = '2022-01-01'\nend_date = '2023-01-01'\n# Load the Sentinel-2 dataset and clip the images to the AOI.\ndataset_s2 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED').filterBounds(\n    AOI).filterDate(start_date, end_date).map(image_clip).map(ndvi_image)\nndvi = dataset_s2.select('NDVI')\n", "functions": ["ndvi.reduce", "ee.Reducer.median"], "external_vars": ["ndvi", "ee"], "defined_vars": ["ndvi_composite"], "parameters": ["ee.Reducer.median()"], "libraries": ["import geemap", "import ee"]}
{"code": "# Visualize the infra-red band.\nMap.addLayer(ir_band, {'min': 0, 'max': 5000}, 'infra-red')\n", "task": "Add the infrared band (`ir_band`) to the map (`Map`) as a layer with a minimum value of 0 and a maximum value of 5000, and label it \"infra-red\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# a) Define the Sentinel-2 image used for the analysis.\nS2 = ee.Image('COPERNICUS/S2_SR/20200719T031539_20200719T032500_T48QYD')\nir_band = S2.select('B8')\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "ir_band"], "defined_vars": [], "parameters": ["ir_band", "infra-red", "{'min': 0, 'max': 5000}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Load Sentinel-1 C-band SAR Ground Range collection (log scaling, VV co-polar)\ncollection =  ee.ImageCollection('COPERNICUS/S1_GRD').filterBounds(pt).filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')).select('VV')\n", "task": "Using the Earth Engine library (ee) and a point geometry (pt), create an ImageCollection (collection) from the COPERNICUS/S1_GRD dataset. Filter the collection to include only images that contain the \"VV\" polarization data and select the \"VV\" band.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Default location\ncor = [[-123.45801418605573, 38.81836572068789], [-122.44589870754011, 38.81836572068789], [-122.44589870754011,\n                                                                                            39.64593638831554], [-123.45801418605573, 39.64593638831554], [-123.45801418605573, 38.81836572068789]]\npt = ee.Geometry.Polygon(cor)\n", "functions": ["unknown_function.select", "unknown_function.filter", "unknown_function.filterBounds", "ee.ImageCollection", "ee.Filter.listContains"], "external_vars": ["ee", "pt"], "defined_vars": ["collection"], "parameters": ["VV", "pt", "COPERNICUS/S1_GRD", "transmitterReceiverPolarisation", "VV", "ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')"], "libraries": ["import geemap", "import ee"]}
{"code": "# Buffer the point feature collection\nbuffered = from_geom.map(lambda f: f.buffer(50000, 1))\n", "task": "Create a new GeoDataFrame called \"buffered\" by applying a buffer of 50,000 units to each geometry feature in the GeoDataFrame \"from_geom\". Use the \"map\" function and a lambda function to iterate through each feature (\"f\") in \"from_geom\" and apply the \"buffer\" method with a distance of 50,000 units and a resolution of 1.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the coordinates of the point\nlon = 103.82\nlat = 1.35\n# Create a point feature collection\nfrom_geom = ee.FeatureCollection(ee.Geometry.Point(lon, lat))\n", "functions": ["from_geom.map", "f.buffer"], "external_vars": ["f", "from_geom"], "defined_vars": ["buffered"], "parameters": [50000, 1, "lambda f: f.buffer(50000, 1)"], "libraries": ["import geemap", "import ee"]}
{"code": "# Display the single Sentinel-2 image\nMap.addLayer(single_image, {'bands': ['B4', 'B3', 'B2'], 'min': 0.0, 'max': 3000}, 'SingleImage')\n", "task": "Add the `single_image` to the `Map` as a layer with the following properties: bands = [\"B4\", \"B3\", \"B2\"], min = 0.0, max = 3000. Name the layer \"SingleImage\".  **Note:** You need to define the variables `Map` and `single_image` before running this code.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the geometry of the Twente region\nTwente = ee.Geometry.Polygon([[[-4.041052552535658, 52.94090567638422], [-4.041052552535658, 51.722482350154216], [\n                             7.155676575973158, 51.722482350154216], [7.155676575973158, 52.94090567638422]]])\n# Cloud masking function for Sentinel-2 imagery\n\n\ndef mask_s2_clouds(image):\n    \"\"\"\n  Masks clouds in Sentinel-2 imagery.\n\n  Args:\n    image: The Sentinel-2 image to be masked.\n\n  Returns:\n    The masked Sentinel-2 image.\n  \"\"\"\n    qa = image.select('QA60')\n    cloud_bit_mask = 1 << 10\n    cirrus_bit_mask = 1 << 11\n    mask = qa.bitwise_and(cloud_bit_mask).eq(\n        0) and qa.bitwise_and(cirrus_bit_mask).eq(0)\n    return image.updateMask(mask).divide(10000).select('B.*').copyProperties(image, ['system:time_start'])\n\n\n# Load the Sentinel-2 image collection\ns2 = ee.ImageCollection('COPERNICUS/S2')\n# Apply the cloud masking function to the Sentinel-2 image collection\ns2_cloudless = s2.filterDate('2020-01-01', '2020-12-31').filter(\n    ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 30)).map(mask_s2_clouds)\n# Filter the Sentinel-2 image collection by the Twente region\ns2_twente = s2_cloudless.filterBounds(Twente)\n# Get the first image from the filtered Sentinel-2 image collection\nsingle_image = s2_twente.first()\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "single_image"], "defined_vars": [], "parameters": ["single_image", "SingleImage", "{'bands': ['B4', 'B3', 'B2'], 'min': 0.0, 'max': 3000}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Filter the dataset for Malaysia.\nMalaysia = admin2.filter(ee.Filter.eq('ADM0_NAME', 'Malaysia'))\nprint(Malaysia)\n", "task": "Using the external variables `admin2`, `ee`, and `print`, filter the `admin2` data to select entries where the `ADM0_NAME` field is equal to \"Malaysia\". Assign the resulting filtered data to a variable named `Malaysia`. Then print the `Malaysia` variable.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Load the FAO/GAUL 2015 level 2 dataset.\nadmin2 = ee.FeatureCollection('FAO/GAUL/2015/level2')\n", "functions": ["admin2.filter", "ee.Filter.eq", "print"], "external_vars": ["ee", "print", "admin2"], "defined_vars": ["Malaysia"], "parameters": ["ADM0_NAME", "Malaysia", "Malaysia", "ee.Filter.eq('ADM0_NAME', 'Malaysia')"], "libraries": ["import ee", "import geemap"]}
{"code": "# Apply the add_ndvi function to the Landsat 8 collection.\nwith_ndvi = l8.map(add_ndvi)\n\n\n", "task": "Apply the function `add_ndvi` to each pixel of the Landsat 8 image (`l8`) using the `map` method. Store the result in a new variable called `with_ndvi`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the point of interest.\npoint = ee.Geometry.Point([-4.2771148681640625, 55.859225187001805])\n# Load the Landsat 8 collection.\nl8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_TOA')\n# Filter the collection by the point of interest and date range.\nimage = ee.Image(l8.filterBounds(point).filterDate(\n    '2015-01-01', '2015-12-31').sort('CLOUD_COVER').first())\n# Define a function to add NDVI to an image.\n\n\ndef add_ndvi(image):\n    ndvi = image.normalizedDifference(['B5', 'B4']).rename('NDVI')\n    return image.addBands(ndvi)\n", "functions": ["l8.map"], "external_vars": ["add_ndvi", "l8"], "defined_vars": ["with_ndvi"], "parameters": ["add_ndvi"], "libraries": ["import geemap", "import ee"]}
{"code": "# Filter the data to obtain the SO2 concentration before.And after COVID-19\nbefore_SO2 = SO2_concentration.filterDate(before_covid_start, before_covid_end)\nafter_SO2 = SO2_concentration.filterDate(after_covid_start, after_covid_end)\n", "task": "Filter the SO2_concentration data into two periods: before and after the COVID-19 pandemic. Define the variable before_SO2 to store the data from before_covid_start to before_covid_end, and define after_SO2 to store the data from after_covid_start to after_covid_end.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the geometry of the area of interest as a polygon\ngeometry = ee.Geometry.Polygon([[72.00885772705078, 24.593958481273493], [72.00885772705078, 12.754883174190141], [\n                               86.02741241455078, 12.754883174190141], [86.02741241455078, 24.593958481273493]])\n# Define the time periods before and after COVID-19\nbefore_covid_start = '2019-04-01'\nbefore_covid_end = '2019-04-30'\nafter_covid_start = '2020-04-01'\nafter_covid_end = '2020-04-30'\n# Load the SO2 concentration data from Copernicus\nSO2_concentration = ee.ImageCollection(\n    'COPERNICUS/S5P/OFFL/L3_SO2').filterBounds(geometry).select('SO2_column_number_density')\n", "functions": ["SO2_concentration.filterDate", "SO2_concentration.filterDate"], "external_vars": ["SO2_concentration", "after_covid_end", "before_covid_start", "after_covid_start", "before_covid_end"], "defined_vars": ["before_SO2", "after_SO2"], "parameters": ["before_covid_start", "before_covid_end", "after_covid_start", "after_covid_end"], "libraries": ["import geemap", "import ee"]}
{"code": "# Select variables for SPI/SPEI/EDDI\n# Timescales for SPI/SPEI/EDDI can be:\n# 14d (14 day), 30d (30 day), 90d (90 day), 180d (180 day),\n# 1y (1 year), 2y (2 year), 5y (5 year)\n# Here we choose 2 years = 48 months\nSPI2y = filtered.select('spi2y')\nSPEI2y = filtered.select('spei2y')\nEDDI2y = filtered.select('spei2y')\n", "task": "From the DataFrame `filtered`, select the columns named \"spi2y\", \"spei2y\", and \"spei2y\" and assign them to the variables `SPI2y`, `SPEI2y`, and `EDDI2y` respectively.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the GRIDMET/DROUGHT collection\ncollection = ee.ImageCollection('GRIDMET/DROUGHT')\n# Filter the collection by date\ndS = '1980-01-01'\ndE = '2020-01-01'\ndSUTC = ee.Date(dS, 'GMT')\ndEUTC = ee.Date(dE, 'GMT')\nfiltered = collection.filterDate(dSUTC, dEUTC.advance(1, 'day'))\n", "functions": ["filtered.select", "filtered.select", "filtered.select"], "external_vars": ["filtered"], "defined_vars": ["SPEI2y", "EDDI2y", "SPI2y"], "parameters": ["spi2y", "spei2y", "spei2y"], "libraries": ["import geemap", "import ee"]}
{"code": "# Center the map on the point of interest.\nMap.centerObject(pt_perth, 14)\n\n\n", "task": "Center the object represented by `pt_perth` on the `Map` at zoom level 14. You will need to define the variables `pt_perth` and `Map` before executing this instruction.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the point of interest (Perth, Australia).\npt_perth = ee.Geometry.Point([115.8, -31.9])\n", "functions": ["Map.centerObject"], "external_vars": ["pt_perth", "Map"], "defined_vars": [], "parameters": ["pt_perth", 14], "libraries": ["import geemap", "import ee"]}
{"code": "# Mask the Sentinel-2 imagery using the SWIR band.\nim_s2 = im_s2.updateMask(im_LowSWIR)\n", "task": "Update the mask of the image `im_s2` (which needs to be defined) with the values from `im_LowSWIR`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Define the geometry of interest.\ngeometry = ee.Geometry.MultiPoint()\n# Define the point of interest (Perth, Australia).\npt_perth = ee.Geometry.Point([115.805, -31.919])\n# Load the Sentinel-2 imagery collection.\nim_s2 = ee.ImageCollection('COPERNICUS/S2_SR').filterBounds(\n    pt_perth).filterDate('2018-06-01', '2019-09-30').median()\n# Extract the Short-Wave Infrared (SWIR) band.\nim_LowSWIR = im_s2.select('B11').lte(700)\n", "functions": ["im_s2.updateMask"], "external_vars": ["im_LowSWIR"], "defined_vars": ["im_s2"], "parameters": ["im_LowSWIR"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the geometry of the region of interest.\ngeometry = ee.Geometry.Polygon([\n  [-72.79833268778783, -12.79955106647952],\n  [-72.79833268778783, -14.124393053355513],\n  [-70.57909440653783, -14.124393053355513],\n  [-70.57909440653783, -12.79955106647952]\n])\n", "task": "Using the ee library, define a variable named `geometry` as a polygon with the following coordinates: [[-72.79833268778783, -12.79955106647952], [-72.79833268778783, -14.124393053355513], [-70.57909440653783, -14.124393053355513], [-70.57909440653783, -12.79955106647952]]", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee"], "defined_vars": ["geometry"], "parameters": ["[[-72.79833268778783, -12.79955106647952], [-72.79833268778783, -14.124393053355513], [-70.57909440653783, -14.124393053355513], [-70.57909440653783, -12.79955106647952]]"], "libraries": ["import ee", "import geemap"]}
{"code": "lc =  ee.ImageCollection(\"MODIS/061/MCD12Q1\").select('LC_Type1').mode()\n", "task": "Using the Earth Engine library (ee), load the MODIS Land Cover Type Yearly Global 500m product (MODIS/061/MCD12Q1) and select the \"LC_Type1\" band. Then, use the mode function to create a new image called \"lc\" representing the most frequent land cover type for each pixel in the image collection.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["unknown_function.mode", "unknown_function.select", "ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["lc"], "parameters": ["LC_Type1", "MODIS/061/MCD12Q1"], "libraries": ["import ee", "import geemap"]}
{"code": "geometry = ee.Geometry.Point(cor)\n", "task": "Define a variable named `geometry` as an Earth Engine Point geometry using the coordinates stored in the variable `cor`. Use the `ee.Geometry.Point()` function and the `ee` module.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\ncor = [51.332743999972905, 35.727911062671176]\n", "functions": ["ee.Geometry.Point"], "external_vars": ["ee", "cor"], "defined_vars": ["geometry"], "parameters": ["cor"], "libraries": ["import ee", "import geemap"]}
{"code": "# Zoom to the area\nMap.centerObject(Bound_geom)\n", "task": "Center the object represented by `Bound_geom` on the map `Map`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the bounding geometry\nBound_geom = ee.Geometry.Polygon([[[-93.11310959151902, 18.112334929829487], [-93.11310959151902, 17.86416393364247],\n                                 [-92.74781418136277, 17.86416393364247], [-92.74781418136277, 18.112334929829487]]], None, False)\n", "functions": ["Map.centerObject"], "external_vars": ["Bound_geom", "Map"], "defined_vars": [], "parameters": ["Bound_geom"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the region of interest (ROI)\nroi = ee.Geometry.Rectangle([77.836, 30.231, 78.299, 30.506])\n", "task": "Using the ee library, define a variable called `roi` representing a rectangular region of interest with coordinates [77.836, 30.231, 78.299, 30.506].", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Geometry.Rectangle"], "external_vars": ["ee"], "defined_vars": ["roi"], "parameters": ["[77.836, 30.231, 78.299, 30.506]"], "libraries": ["import geemap", "import ee"]}
{"code": "ndvi_thr = ndvi_mean.gt(0.25)\n", "task": "Define a boolean variable `ndvi_thr` that is True where the `ndvi_mean` is greater than 0.25 and False otherwise.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ncor = [[51.40150195835105, 35.680686269764024], [51.41738063571921, 35.67796719930233], [51.41841060398093, 35.68584527697069], [51.420813863258275,\n                                                                                                                                 35.68584527697069], [51.41944057224265, 35.70145969785625], [51.40536433933249, 35.70118089572008], [51.40150195835105, 35.680686269764024]]\ngeometry = ee.Geometry.Polygon(cor)\n\n\ndef func_(img):\n    bands = img.select('B.*').multiply(0.0001)\n    ndvi = bands.normalizedDifference(['B8', 'B4']).rename('ndvi')\n    return ndvi.copyProperties(img, ['system:time_start', 'system:time_end'])\n\n\nsen2 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED').filterBounds(geometry).filterDate('2018', '2024').filter(\n    ee.Filter.calendarRange(6, 8, 'month')).filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10)).map(func_)\nndvi_mean = sen2.median()\n", "functions": ["ndvi_mean.gt"], "external_vars": ["ndvi_mean"], "defined_vars": ["ndvi_thr"], "parameters": [0.25], "libraries": ["import geemap", "import ee"]}
{"code": "fao = ee.FeatureCollection(\"FAO/GAUL/2015/level0\")\n", "task": "Using the Earth Engine library (`ee`), define a variable called `fao` and assign it to the FeatureCollection representing the FAO GAUL 2015 level 0 administrative units.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.FeatureCollection"], "external_vars": ["ee"], "defined_vars": ["fao"], "parameters": ["FAO/GAUL/2015/level0"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define a mask to only show areas with tree cover greater than 35%.\nmask = tree_cover.gt(35)\n", "task": "Create a boolean mask named \"mask\" that identifies areas where the tree cover is greater than 35. Use the \"tree_cover\" variable for this operation.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the Global Forest Cover Hansen 2021 dataset.\ngfc2021 = ee.Image('UMD/hansen/global_forest_change_2021_v1_9')\n# Load a feature collection of Thailand.\nc = ee.FeatureCollection(\n    'USDOS/LSIB_SIMPLE/2017').filter(ee.Filter.eq('country_na', 'Thailand'))\n# Clip the GFC dataset to the boundary of Thailand.\ngfc2021_clip = gfc2021.clip(c)\n# Get the tree cover band from the GFC dataset.\ntree_cover = gfc2021_clip.select(['treecover2000'])\n", "functions": ["tree_cover.gt"], "external_vars": ["tree_cover"], "defined_vars": ["mask"], "parameters": [35], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the LANDSAT/LE7_L1T_32DAY_NDVI image collection.\nimage_collection = ee.ImageCollection(\"LANDSAT/LE7_L1T_32DAY_NDVI\")\n", "task": "Using the Earth Engine library (`ee`), load the Landsat 7 32-day Normalized Difference Vegetation Index (NDVI) image collection and assign it to the variable `image_collection`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["image_collection"], "parameters": ["LANDSAT/LE7_L1T_32DAY_NDVI"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define two points: Barcelona.And China\nbarcelona = ee.Feature(ee.Geometry.Point([-89.37, 40.57])).set(\"Class\", \"BCN\")\nchina = ee.Feature(ee.Geometry.Point([-120.83, 40.77])).set(\"Class\", \"China\")\n", "task": "Using the Earth Engine library (`ee`), define two variables named `barcelona` and `china` representing points on the Earth. `barcelona` should be located at coordinates [-89.37, 40.57] and have a property named `Class` set to `BCN`. Similarly, `china` should be located at coordinates [-120.83, 40.77] with a property named `Class` set to `China`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["unknown_function.set", "ee.Feature", "ee.Geometry.Point", "unknown_function.set", "ee.Feature", "ee.Geometry.Point"], "external_vars": ["ee"], "defined_vars": ["barcelona", "china"], "parameters": ["Class", "BCN", "Class", "China", "ee.Geometry.Point([-89.37, 40.57])", "[-89.37, 40.57]", "ee.Geometry.Point([-120.83, 40.77])", "[-120.83, 40.77]"], "libraries": ["import geemap", "import ee"]}
{"code": "## Create a list of Features.\nfeatures = [\n    ee.Feature(ee.Geometry.Rectangle(30.01, 59.80, 30.59, 60.15), {'name': 'Voronoi'}),\n    ee.Feature(ee.Geometry.Point(-73.96, 40.781), {'name': 'Thiessen'}),\n    ee.Feature(ee.Geometry.Point(6.4806, 50.8012), {'name': 'Dirichlet'})\n]\n", "task": "Using the Earth Engine library (ee), create a list of features named \"features\" that includes a rectangle, a point, and another point. The rectangle should be defined by coordinates (30.01, 59.8, 30.59, 60.15) and named \"Voronoi\". The first point should be at coordinates (-73.96, 40.781) and named \"Thiessen\". The second point should be at coordinates (6.4806, 50.8012) and named \"Dirichlet\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Feature", "ee.Geometry.Rectangle", "ee.Feature", "ee.Geometry.Point", "ee.Feature", "ee.Geometry.Point"], "external_vars": ["ee"], "defined_vars": ["features"], "parameters": [30.01, 59.8, 30.59, 60.15, 40.781, 6.4806, 50.8012, "ee.Geometry.Rectangle(30.01, 59.8, 30.59, 60.15)", "{'name': 'Voronoi'}", "ee.Geometry.Point(-73.96, 40.781)", "{'name': 'Thiessen'}", "-73.96", "ee.Geometry.Point(6.4806, 50.8012)", "{'name': 'Dirichlet'}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Get the 1992.And 2012 images by their unique IDs\nntl1992 = ee.Image('NOAA/DMSP-OLS/NIGHTTIME_LIGHTS/F101992').select('stable_lights')\nntl2012 = ee.Image('NOAA/DMSP-OLS/NIGHTTIME_LIGHTS/F182012').select('stable_lights')\n", "task": "Using the ee library, define two variables named `ntl1992` and `ntl2012` by loading the corresponding images from the  NOAA/DMSP-OLS/NIGHTTIME_LIGHTS collection. Select the `stable_lights` band for both images.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["unknown_function.select", "ee.Image", "unknown_function.select", "ee.Image"], "external_vars": ["ee"], "defined_vars": ["ntl2012", "ntl1992"], "parameters": ["stable_lights", "NOAA/DMSP-OLS/NIGHTTIME_LIGHTS/F101992", "stable_lights", "NOAA/DMSP-OLS/NIGHTTIME_LIGHTS/F182012"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the table.\ntable = ee.FeatureCollection(\"users/3050512/Lindani\")\n", "task": "Using the Earth Engine library (`ee`), load the FeatureCollection named \"Lindani\" from the user \"3050512\" and assign it to the variable `table`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.FeatureCollection"], "external_vars": ["ee"], "defined_vars": ["table"], "parameters": ["users/3050512/Lindani"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the Landsat 8 collection.\nlandsat8 = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_SR\")\n", "task": "Using the Earth Engine library (ee), define a variable called `landsat8` to represent the Landsat 8 Collection 2 Tier 1 Surface Reflectance image collection.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["landsat8"], "parameters": ["LANDSAT/LC08/C02/T1_SR"], "libraries": ["import geemap", "import ee"]}
{"code": "# Get the bounds of the buffer\nbounds = buffer.bounds()\n", "task": "Get the bounds of the buffer and assign them to the variable `bounds`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Define the input geometries\ngeometry = ee.Geometry.Point([-2.481398773193373, 6.822477794917577])\n# Create a buffer around the first geometry\nbuffer = geometry.buffer(10000)\n", "functions": ["buffer.bounds"], "external_vars": ["buffer"], "defined_vars": ["bounds"], "parameters": [], "libraries": ["import ee", "import geemap"]}
{"code": "# Select only the 1km day LST data band.\nmodLSTday = mod11a2.select('LST_Day_1km')\n", "task": "Using the variable `mod11a2`, select the data for \"LST_Day_1km\" and store it in a new variable named `modLSTday`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Import LST image collection.\nmodis = ee.ImageCollection('MODIS/MOD11A2')\n# Define a date range of interest; here, a start date is defined and the end date is determined by advancing 1 year from the start date.\nstart = ee.Date('2015-01-01')\ndateRange = ee.DateRange(start, start.advance(1, 'year'))\n# Filter the LST collection to include only images intersecting the desired date range.\nmod11a2 = modis.filterDate(dateRange)\n", "functions": ["mod11a2.select"], "external_vars": ["mod11a2"], "defined_vars": ["modLSTday"], "parameters": ["LST_Day_1km"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the list of satellite data items\nitems = [\n  {\n    \"name\": \"L5\",\n    \"collection\": ee.ImageCollection('LANDSAT/LT5_SR'),\n    \"start\": ee.Date('1995-01-01'),\n    \"finish\": ee.Date('2013-01-01'),\n    \"target\": target_point,\n    \"cloud_cover_lt\": 0.8,\n    \"bands\": [\"B3\", \"B2\", \"B1\"],\n    \"export\": True\n  },\n  {\n    \"name\": \"L8\",\n    \"collection\": ee.ImageCollection('LANDSAT/LC08/C01/T1_RT'),\n    \"start\": ee.Date('2013-01-01'),\n    \"finish\": ee.Date('2017-10-23'),\n    \"target\": target_point,\n    \"cloud_cover_lt\": 0.8,\n    \"bands\": [\"B4\", \"B3\", \"B2\"],\n    \"export\": True\n  }\n]\n", "task": "Define a variable called `items` that contains a list of dictionaries. Each dictionary should represent a Landsat image collection with the following keys: `name`, `collection`, `start`, `finish`, `target`, `cloud_cover_lt`, `bands`, and `export`. Use the `ee.ImageCollection` constructor to define the collection, `ee.Date` for the start and finish dates, and the provided `target_point` for the target location. Set the `export` flag to True for all entries. The code should also import the `ee` library.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Define the input geometries\ngeometry = ee.Geometry.Point([91.3458251953125, 22.260503165629657])\ntarget_point = ee.Geometry.Point(91.3458251953125, 22.260503165629657)\n", "functions": ["ee.ImageCollection", "ee.Date", "ee.Date", "ee.ImageCollection", "ee.Date", "ee.Date"], "external_vars": ["ee", "target_point"], "defined_vars": ["items"], "parameters": ["LANDSAT/LT5_SR", "1995-01-01", "2013-01-01", "LANDSAT/LC08/C01/T1_RT", "2013-01-01", "2017-10-23"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add the elevation data to the map with the specified visualization parameters.\nMap.addLayer(elevation, elevation_vis, 'Elevation')  \n\n\n", "task": "Add a layer to the map named \"Elevation\" using the `elevation` data and the `elevation_vis` visualization style. You need to define the following variables: `Map`, `elevation_vis`, and `elevation`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the dataset to be used.\ndataset = ee.Image('NOAA/NGDC/ETOPO1')\nelevation = dataset.select('bedrock')\n# Define the visualization parameters for the elevation data.\nelevation_vis = {'min': -7000.0, 'max': 3000.0,\n                 'palette': ['011de2', 'afafaf', '3603ff', 'fff477', 'b42109']}\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "elevation_vis", "elevation"], "defined_vars": [], "parameters": ["elevation", "elevation_vis", "Elevation"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the data to the map.\nMap.addLayer(data)\nprint(data)\n\n\n", "task": "Add the data to the Map and then print the data. You will need to define the variables: [Map, data] and import the print function.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the global intertidal dataset.\ndata = ee.ImageCollection('UQ/murray/Intertidal/v1_1/global_intertidal')\n", "functions": ["Map.addLayer", "print"], "external_vars": ["Map", "data", "print"], "defined_vars": [], "parameters": ["data", "data"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the Landsat 8 collection.\nl8 = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_TOA\")\n", "task": "Using the Earth Engine library (`ee`), load the Landsat 8 Collection 2 Tier 1 TOA data and assign it to the variable `l8`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["l8"], "parameters": ["LANDSAT/LC08/C02/T1_TOA"], "libraries": ["import geemap", "import ee"]}
{"code": "#// Calculate total effort across gear types\nchina_all = china.reduce(ee.Reducer.sum())\n", "task": "Using the `ee` and `china` variables, calculate the sum of all values in the `china` variable and assign it to the variable `china_all`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Import GFW data\ngfw = ee.ImageCollection('GFW/GFF/V1/fishing_hours')\n# Define a function to filter/aggregate for a specific flag state and date range\n\n\ndef flag_totals(flag, start_date, end_date):\n    effort_flag = gfw.filterMetadata(\n        'country', 'equals', flag).filterDate(start_date, end_date).sum()\n    return ee.Image(effort_flag)\n\n\n# // Apply function to China\nchina = flag_totals('CHN', '2016-01-01', '2017-01-01')\n", "functions": ["china.reduce", "ee.Reducer.sum"], "external_vars": ["ee", "china"], "defined_vars": ["china_all"], "parameters": ["ee.Reducer.sum()"], "libraries": ["import geemap", "import ee"]}
{"code": "modis = ee.ImageCollection(\"MODIS/061/MCD12Q1\").select('LC_Type1').filterDate(time_start, time_end).first()\n", "task": "Using the Earth Engine library (ee), load the MODIS Land Cover Type 1 product (MODIS/061/MCD12Q1) and select the \"LC_Type1\" band. Filter the collection by date using the variables `time_start` and `time_end`, and then select the first image in the filtered collection. Assign the resulting image to the variable `modis`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\ntime_start = '2020'\ntime_end = '2021'\n", "functions": ["unknown_function.first", "unknown_function.filterDate", "unknown_function.select", "ee.ImageCollection"], "external_vars": ["ee", "time_start", "time_end"], "defined_vars": ["modis"], "parameters": ["time_start", "time_end", "LC_Type1", "MODIS/061/MCD12Q1"], "libraries": ["import ee", "import geemap"]}
{"code": "# Create a list of years from 1981 to 2022\nyears = ee.List.sequence(1981, 2022)\n", "task": "Using the Earth Engine library (ee), define a variable called \"years\" that contains a list of years from 1981 to 2022.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.List.sequence"], "external_vars": ["ee"], "defined_vars": ["years"], "parameters": [1981, 2022], "libraries": ["import geemap", "import ee"]}
{"code": "## This function masks clouds in Landsat 8 imagery.\ndef mask_clouds(image):\n    \"\"\"Masks clouds in Landsat 8 imagery.\n\n    Args:\n        image: ee.Image, Landsat 8 imagery.\n\n    Returns:\n        ee.Image, Landsat 8 imagery with clouds masked.\n    \"\"\"\n\n    scored = ee.Algorithms.Landsat.simpleCloudScore(image)\n    return image.updateMask(scored.select(['cloud']).lt(20))\n", "task": "If the value of the variable `ee` is equal to the value of the variable `scored`, then set the value of the variable `image` to the string \"img/success.png\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Algorithms.Landsat.simpleCloudScore", "image.updateMask", "unknown_function.lt", "scored.select"], "external_vars": ["ee"], "defined_vars": ["scored", "image"], "parameters": ["image", 20, "scored.select(['cloud']).lt(20)", "['cloud']"], "libraries": ["import geemap", "import ee"]}
{"code": "# Filter the collection by date.\nfiltered = l8.filterDate('2017-07-01', '2017-07-31')\n", "task": "Using the `l8` object, filter the data to include entries between July 1st, 2017 and July 31st, 2017. Store the filtered data in a variable called `filtered`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the Landsat 8 C01 Tier 1 Real-Time (RT) collection.\nl8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_RT')\n", "functions": ["l8.filterDate"], "external_vars": ["l8"], "defined_vars": ["filtered"], "parameters": ["2017-07-01", "2017-07-31"], "libraries": ["import geemap", "import ee"]}
{"code": "sen5 = ee.ImageCollection(\"COPERNICUS/S5P/OFFL/L3_CH4\").select(['CH4_column_volume_mixing_ratio_dry_air'],['methane']).filterDate(time_start, time_end).filterBounds(roi)\n", "task": "Define a variable named `sen5` using the Earth Engine library (`ee`) to load the Sentinel-5P methane data from the specified time period (`time_start`, `time_end`) and region of interest (`roi`). Select the `CH4_column_volume_mixing_ratio_dry_air` band and rename it to `methane`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\ntable = ee.FeatureCollection('FAO/GAUL/2015/level1')\ncor = [51.332743999972905, 35.727911062671176]\ngeometry = ee.Geometry.Point(cor)\nroi = table.filterBounds(geometry)\ntime_start = '2020'\ntime_end = '2024'\n", "functions": ["unknown_function.filterBounds", "unknown_function.filterDate", "unknown_function.select", "ee.ImageCollection"], "external_vars": ["ee", "roi", "time_start", "time_end"], "defined_vars": ["sen5"], "parameters": ["roi", "time_start", "time_end", "COPERNICUS/S5P/OFFL/L3_CH4", "['CH4_column_volume_mixing_ratio_dry_air']", "['methane']"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add the true and false color composites to the map.\nMap.addLayer(image, viz_true, 'True Color Composite')\nMap.addLayer(image, viz_false, 'False Color Composite')\n", "task": "Add two layers to the Map object, one displaying the image with the visualization defined in `viz_true` labeled \"True Color Composite\", and the other displaying the image with the visualization defined in `viz_false` labeled \"False Color Composite\".\\n\\n**Required variables:**\\n* `viz_true`: Visualization for the \"True Color Composite\" layer\\n* `viz_false`: Visualization for the \"False Color Composite\" layer\\n* `image`: The image to be displayed\\n* `Map`: The Map object to add the layers to", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Load the Simplified and Detailed boundary datasets from LSIB.\nsimplified = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017')\n# Filter the countries to only include Indonesia.\nindonesia = simplified.filter(ee.Filter.eq('country_na', 'Indonesia'))\n# Filter the image collection by date, bounds, and cloud cover.\nimage = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA').filterDate('2016-01-01', '2016-12-31').filterBounds(\n    indonesia).filterMetadata('CLOUD_COVER', 'less_than', 30).median().clip(indonesia)\n# Define the visualization parameters for true and false color composites.\nviz_false = {'bands': ['B5', 'B4', 'B3'],\n             'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}\nviz_true = {'bands': ['B4', 'B3', 'B2'],\n            'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}\n", "functions": ["Map.addLayer", "Map.addLayer"], "external_vars": ["image", "Map", "viz_true", "viz_false"], "defined_vars": [], "parameters": ["image", "viz_true", "True Color Composite", "image", "viz_false", "False Color Composite"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add the SRTM data to the map\nMap.addLayer(srtm, {}, 'SRTMDEM')\n", "task": "Add the SRTM elevation data to the map, using the variable `srtm` as the data source and naming the layer \"SRTMDEM\". The `Map` variable should already be defined and represent a map object.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Load the SRTM and forest data\nsrtm = ee.Image('USGS/SRTMGL1_003')\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "srtm"], "defined_vars": [], "parameters": ["srtm", "SRTMDEM", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Select the RGB bands from the composite median.\nrgb_bands = ['SR_B4', 'SR_B3', 'SR_B2']\nrgb_image = composite_median.select(rgb_bands)\n", "task": "Define a list called `rgb_bands` containing the band names `SR_B4`, `SR_B3`, and `SR_B2`. Then, use the `composite_median` image and select these bands to create a new image called `rgb_image`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the administration boundary data and filter it to the region of interest.\nselangor = ee.FeatureCollection(\n    'FAO/GAUL/2015/level1').filter(ee.Filter.eq('ADM1_NAME', 'Selangor'))\n# Get the Landsat 8 collection and filter it as in previous lab.\nfiltered = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterBounds(\n    selangor).filterDate('2020-06-01', '2020-12-31').sort('CLOUD_COVER')\n# Compute the median composite of the filtered collection.\ncomposite_median = filtered.median()\n", "functions": ["composite_median.select"], "external_vars": ["composite_median"], "defined_vars": ["rgb_image", "rgb_bands"], "parameters": ["rgb_bands"], "libraries": ["import geemap", "import ee"]}
{"code": "# Display data\nMap.addLayer(dem.clip(Ethiopia).updateMask(dem.gt(0)), vis_params, \"DEM\")\nMap.centerObject(Ethiopia, 6)\n\n\n", "task": "Add a layer to the map representing the elevation data (DEM) clipped to Ethiopia and masked to only include areas with positive elevation. Center the map on Ethiopia with a zoom level of 6. \\n\\n**Required variables:**\\n - `Ethiopia`:  a GeoJSON object representing the country of Ethiopia.\\n - `dem`: a raster dataset containing elevation data.\\n - `Map`: a reference to the Google Earth Engine map object.\\n - `vis_params`: a dictionary defining the visualization parameters for the DEM layer.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncountries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017')\nEthiopia = countries.filter(ee.Filter.eq('country_na', 'Ethiopia'))\n# Print the elevation of Mount Everest.\ndem = ee.Image('USGS/SRTMGL1_003')\n# Set visualization parameters\nvis_params = {'min': 0, 'max': 4000, 'palette': [\n    '006633', 'EFFFCC', '662A00', 'D8D8D8', 'F5F5F5']}\n", "functions": ["Map.addLayer", "unknown_function.updateMask", "dem.clip", "dem.gt", "Map.centerObject"], "external_vars": ["dem", "Map", "vis_params", "Ethiopia"], "defined_vars": [], "parameters": ["vis_params", "DEM", "Ethiopia", 0, "Ethiopia", 6, "dem.clip(Ethiopia).updateMask(dem.gt(0))", "dem.gt(0)"], "libraries": ["import ee", "import geemap"]}
{"code": "# Get the first image in the collection\nfirst_image = collection.first()\n", "task": "Get the first image from the `collection` and assign it to the variable `first_image`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load a collection of Landsat 8 images for one year\ncollection = ee.ImageCollection(\n    'LANDSAT/LC08/C02/T1_SR').filterDate('2016-01-01', '2018-12-31')\n", "functions": ["collection.first"], "external_vars": ["collection"], "defined_vars": ["first_image"], "parameters": [], "libraries": ["import geemap", "import ee"]}
{"code": "def func2_(img):\n    ms = img.select('B.*').multiply(0.0001)\n    ndvi = ms.normalizedDifference(['B8','B4']).rename('ndvi')\n    return ndvi.copyProperties(img, ['system:time_start', 'system:time_end','system:index'])\n\nsen2 = ee.ImageCollection(\"COPERNICUS/S2_SR_HARMONIZED\").filterDate(time_start, time_end).filterBounds(geometry).map(func2_)\n", "task": "Using the Earth Engine library (ee), filter a Sentinel-2 image collection by date and geographic region. Define variables for the image collection (sen2), individual images within the collection (img), a multispectral band selection (ms), and the normalized difference vegetation index (ndvi). Use the provided geometry, time_start, and time_end variables to filter the image collection. Apply the function func2_ to each image in the collection. The function should select all bands starting with \"B\" and multiply them by 0.0001, calculate the NDVI using bands B8 and B4, and rename the NDVI band. Finally, copy the properties \"system:time_start\", \"system:time_end\", and \"system:index\" from the original image to the NDVI image. ", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ncor = [[48.09532576624447, 31.98308763719514], [48.744892416635096, 31.98308763719514], [48.744892416635096,\n                                                                                         32.40378543571943], [48.09532576624447, 32.40378543571943], [48.09532576624447, 31.98308763719514]]\ngeometry = ee.Geometry.Polygon(cor)\ntime_start = '2023'\ntime_end = '2024'\n", "functions": ["unknown_function.multiply", "img.select", "unknown_function.rename", "ms.normalizedDifference", "ndvi.copyProperties", "unknown_function.map", "unknown_function.filterBounds", "unknown_function.filterDate", "ee.ImageCollection"], "external_vars": ["func2_", "time_start", "ee", "geometry", "time_end"], "defined_vars": ["ndvi", "img", "ms", "sen2"], "parameters": [0.0001, "B.*", "ndvi", "img", "func2_", "geometry", "time_start", "time_end", "COPERNICUS/S2_SR_HARMONIZED", "['B8', 'B4']", "['system:time_start', 'system:time_end', 'system:index']"], "libraries": ["import geemap", "import ee"]}
{"code": "# Import the Landsat 8 image collection\nl8 = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_L2\")\n", "task": "Load the Landsat 8 Collection 2 Tier 1 Level 2 surface reflectance data into an Earth Engine ImageCollection and assign it to the variable `l8`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["l8"], "parameters": ["LANDSAT/LC08/C02/T1_L2"], "libraries": ["import ee", "import geemap"]}
{"code": "# Filter the CHIRPS collection by date\nfiltered = chirps.filter(ee.Filter.date(start_date, end_date))\n", "task": "Using the Earth Engine library (ee), filter the chirps dataset to include data between the start and end dates. Store the filtered data in a variable named \"filtered\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the CHIRPS precipitation dataset\nchirps = ee.ImageCollection('UCSB-CHG/CHIRPS/PENTAD')\n# Specify the year for which you want to calculate the precipitation\nyear = 2023\nstart_date = ee.Date.fromYMD(year, 1, 1)\nend_date = start_date.advance(1, 'year')\n", "functions": ["chirps.filter", "ee.Filter.date"], "external_vars": ["end_date", "chirps", "ee", "start_date"], "defined_vars": ["filtered"], "parameters": ["start_date", "end_date", "ee.Filter.date(start_date, end_date)"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the nBRT layer to the map.\nMap.addLayer(nBRT, {'min': 0.9, 'max': 1}, 'nBRT')\n\n\n", "task": "Add the layer \"nBRT\" to the \"Map\" object with a minimum value of 0.9 and a maximum value of 1, using the layer name \"nBRT\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the geometry of interest.\ngeometry = ee.Geometry.Point([85.32766113281264, 27.70294105837698])\n# Load the Landsat 8 collection and filter it by date and geometry.\nlandsat = ee.ImageCollection(\n    'LANDSAT/LC8_L1T').filterDate('2016-01-01', '2017-01-01').filterBounds(geometry)\n# Create a simple composite of the Landsat collection.\ncomposite = ee.Algorithms.Landsat.simpleComposite(\n    collection=landsat, asFloat=True)\n# Calculate the nBRT.\nnBRT = composite.expression({'expression': '(nir - 0.0001 * swir * thermal) / ' + '(nir + 0.0001 * swir * thermal)',\n                            'map': {'nir': composite.select('B5'), 'swir': composite.select('B7'), 'thermal': composite.select('B11')}})\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "nBRT"], "defined_vars": [], "parameters": ["nBRT", "nBRT", "{'min': 0.9, 'max': 1}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Zoom to a location.\nMap.setCenter(-112.8598, 36.2841, 9)  # Center on the Grand Canyon\n", "task": "Use the `Map` object to center the map on the coordinates (-112.8598, 36.2841) with a zoom level of 9. You need to define the `Map` variable before executing this instruction.", "exec_path": "GEE", "context": "import geemap\nMap = geemap.Map()\n", "functions": ["Map.setCenter"], "external_vars": ["Map"], "defined_vars": [], "parameters": [36.2841, 9, "-112.8598"], "libraries": ["import geemap"]}
{"code": "Map.addLayer(era.first(),{},'era5', False)\nMap.addLayer(mod.first(),{},'mod', False)\n", "task": "Add two layers to the map, named \"era5\" and \"mod\", using the first elements of the \"era\" and \"mod\" lists respectively. The layer options should be empty dictionaries. Set the opacity of both layers to False. You need to define the following variables: [\"era\", \"mod\", \"Map\"].", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ntime_start = '2010'\ntime_end = '2020'\nera = ee.ImageCollection('ECMWF/ERA5_LAND/DAILY_AGGR').select(\n    'skin_temperature').filterDate(time_start, time_end)\nmod = ee.ImageCollection(\n    'MODIS/061/MOD11A1').select('LST_Day_1km').filterDate(time_start, time_end)\n", "functions": ["Map.addLayer", "era.first", "Map.addLayer", "mod.first"], "external_vars": ["Map", "era", "mod"], "defined_vars": [], "parameters": ["era5", false, "mod", false, "era.first()", "{}", "mod.first()", "{}"], "libraries": ["import geemap", "import ee"]}
{"code": "colombia = admin2.filter(ee.Filter.eq('ADM0_NAME', 'Colombia'))\n", "task": "Using the Earth Engine library (ee) and the admin2 feature collection, define a new feature collection named \"colombia\" that contains all features where the \"ADM0_NAME\" property is equal to \"Colombia\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nadmin2 = ee.FeatureCollection('FAO/GAUL_SIMPLIFIED_500m/2015/level1')\n", "functions": ["admin2.filter", "ee.Filter.eq"], "external_vars": ["ee", "admin2"], "defined_vars": ["colombia"], "parameters": ["ADM0_NAME", "Colombia", "ee.Filter.eq('ADM0_NAME', 'Colombia')"], "libraries": ["import geemap", "import ee"]}
{"code": "# Center the map on the point of interest.\nMap.centerObject(point, 14)\n", "task": "Center the object located at the point `point` on the map `Map` with a radius of 14. The variables `point` and `Map` must be defined.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the point of interest.\npoint = ee.Geometry.Point([107.58, 16.47])\n", "functions": ["Map.centerObject"], "external_vars": ["Map", "point"], "defined_vars": [], "parameters": ["point", 14], "libraries": ["import ee", "import geemap"]}
{"code": "# Filter the image collection by the geometry.And select the bands of interest\nimage = image_collection.filterBounds(geometry).select(bands).median()\n", "task": "Calculate the median value of all pixels within the specified geometry for each band in the image collection, and store the result in the variable \"image\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the geometry of interest, in this case a rectangle\ngeometry = ee.Geometry.Polygon([[115.81810323928907, -31.94727319521792], [115.81810323928907, -31.98295314826852], [\n                               115.91749517654493, -31.98295314826852], [115.91749517654493, -31.94727319521792]])\n# Define the bands of interest\nbands = ['B2', 'B3', 'B4', 'B8', 'B8A', 'B11']\n# Load the Sentinel-2 SR image collection\nimage_collection = ee.ImageCollection('COPERNICUS/S2_SR')\n", "functions": ["unknown_function.median", "unknown_function.select", "image_collection.filterBounds"], "external_vars": ["geometry", "image_collection", "bands"], "defined_vars": ["image"], "parameters": ["bands", "geometry"], "libraries": ["import geemap", "import ee"]}
{"code": "# Sample the median image within the region of interest.\ntraining = image.sample(region=geometry, scale=10, numPixels=5000)\nprint(training)\n", "task": "Sample 5000 pixels from the image within the specified geometry region, using a scale of 10. Define a variable named \"training\" to store the result and print its contents.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the Sentinel-2 image collection.\ns2 = ee.ImageCollection('COPERNICUS/S2_SR')\n# Define the geometry of the region of interest.\ngeometry = ee.Geometry.Polygon([[115.7316849708557, -31.947837287582516], [115.7316849708557, -32.06079976675064], [\n                               115.87862710952757, -32.06079976675064], [115.87862710952757, -31.947837287582516]])\n# Define the bands of interest.\nbands = ['B4', 'B3', 'B2', 'B8', 'B8A', 'B11']\n# Compute the median image of the filtered collection.\nimage = ee.ImageCollection(s2).filterBounds(geometry).select(bands).median()\n", "functions": ["image.sample", "print"], "external_vars": ["image", "print", "geometry"], "defined_vars": ["training"], "parameters": ["training"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the SGLI image collection\nimage = ee.ImageCollection(\"projects/ee-eutrophication-gee4geo/assets/OCEANDATA/SGLI/JASMES\")\n", "task": "Using the Earth Engine library (`ee`), define a variable named `image` to represent the ImageCollection `projects/ee-eutrophication-gee4geo/assets/OCEANDATA/SGLI/JASMES`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["image"], "parameters": ["projects/ee-eutrophication-gee4geo/assets/OCEANDATA/SGLI/JASMES"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define a cloud removal function for Landsat images using the simple composite algorithm\ndef simple_composite(collection, as_float=True):\n    \"\"\"\n    Applies the simple composite algorithm to a Landsat image collection.\n\n    Args:\n        collection (ee.ImageCollection): The Landsat image collection to apply the algorithm to.\n        as_float (bool, optional): Whether to convert the output image to float. Defaults to True.\n\n    Returns:\n        ee.Image: The composite image.\n    \"\"\"\n    return ee.Algorithms.Landsat.simpleComposite({\n        'collection': collection,\n        'asFloat': as_float\n    })\n", "task": "Given a list of integers, `collection`, return a list of the elements cast to floats, if `as_float` is True. If `as_float` is False, return the elements of the list in the same format they were given.  The elements in the list should all be floats, even if `as_float` is False. For example, if `collection` is [1, 2, 3] and `as_float` is True, then the output should be [1.0, 2.0, 3.0]. If `as_float` is False, then the output should be [1.0, 2.0, 3.0]. The variable `ee` is not used.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Algorithms.Landsat.simpleComposite"], "external_vars": ["ee"], "defined_vars": ["collection", "as_float"], "parameters": ["{'collection': collection, 'asFloat': as_float}"], "libraries": ["import geemap", "import ee"]}
{"code": "## Define the area of interest (AOI) as a polygon geometry.\naoi = ee.Geometry.Polygon(\n    [[[85.06273238283217, 25.724799033948425],\n      [85.06273238283217, 25.42254429051253],\n      [85.84825484376967, 25.42254429051253],\n      [85.84825484376967, 25.724799033948425]]], None, False)\n", "task": "Define a variable called `aoi` and assign it a polygon geometry using the `ee.Geometry.Polygon()` function. The polygon coordinates should be: [[[85.06273238283217, 25.724799033948425], [85.06273238283217, 25.42254429051253], [85.84825484376967, 25.42254429051253], [85.84825484376967, 25.724799033948425]]]. Set the `proj` and `geodesic` arguments to `None` and `False`, respectively.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee"], "defined_vars": ["aoi"], "parameters": [null, false, "[[[85.06273238283217, 25.724799033948425], [85.06273238283217, 25.42254429051253], [85.84825484376967, 25.42254429051253], [85.84825484376967, 25.724799033948425]]]"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the roi layer to the map\nMap.addLayer(roi, {'color':\"blue\"}, \"Region of Interest\")\n", "task": "Add the region of interest (`roi`) as a layer to the map (`Map`) with a blue color and label it \"Region of Interest\".  Make sure to define the following variables: `roi`, `Map`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the geometry of interest (a multi-point geometry)\ngeometry = ee.Geometry.MultiPoint([[86.37282419555602, 23.305273163571], [87.04848337524352, 23.209384103179094], [\n                                  87.89443064086852, 23.34562685067499], [87.26089649984799, 22.443664263792446]])\n# Import the FAO GAUL Second Level Feature Collection\nadm2 = ee.FeatureCollection('FAO/GAUL_SIMPLIFIED_500m/2015/level2')\n# Extract multiple features from the feature collection\nroi = adm2.filterBounds(geometry)\n", "functions": ["Map.addLayer"], "external_vars": ["roi", "Map"], "defined_vars": [], "parameters": ["roi", "Region of Interest", "{'color': 'blue'}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the Landsat 8 C02 Tier 1 TOA image collection.\nimage_collection = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_TOA\")\n", "task": "Using the Earth Engine library (ee), define a variable named \"image_collection\" that represents the Landsat 8 Collection 2 Tier 1 Top of Atmosphere (TOA) Reflectance image collection.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["image_collection"], "parameters": ["LANDSAT/LC08/C02/T1_TOA"], "libraries": ["import ee", "import geemap"]}
{"code": "geometry = ee.Geometry.Polygon(cor)\nMap.centerObject(geometry)\n", "task": "Using the Earth Engine library (ee), create a polygon geometry object from the coordinates stored in the variable `cor`.  Define a new variable called `geometry` to store this polygon. Then, center the map (`Map`) on this newly created geometry. ", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [[1.921468397822803, 52.382854413832085], [48.3277183978228, 52.382854413832085], [48.3277183978228,\n                                                                                         71.58428687506868], [1.921468397822803, 71.58428687506868], [1.921468397822803, 52.382854413832085]]\n", "functions": ["ee.Geometry.Polygon", "Map.centerObject"], "external_vars": ["ee", "Map", "cor"], "defined_vars": ["geometry"], "parameters": ["cor", "geometry"], "libraries": ["import ee", "import geemap"]}
{"code": "# Calculate.And add NDVI for every single image in the filtered collection (Filtered)\nCollectionwithNDVI = Filtered.map(add_ndvi)\n", "task": "Define a new variable called `CollectionwithNDVI` by applying the `add_ndvi` function to each element in the `Filtered` collection using the `map` method.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\nSelangor = ee.FeatureCollection(\n    'FAO/GAUL/2015/level1').filter(ee.Filter.eq('ADM1_NAME', 'Selangor'))\n# Get Landsat8 collection and filter it as in previous lab\nFiltered = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterBounds(\n    Selangor).filterDate('2020-06-01', '2020-12-31').sort('CLOUD_COVER')\n# Writing function to calculate, rename and add NDVI to an image\n\n\ndef add_ndvi(image):\n    ndvi = image.normalizedDifference(['SR_B5', 'SR_B4'])\n    ndvi = ndvi.rename('NDVI')\n    return image.addBands(ndvi)\n", "functions": ["Filtered.map"], "external_vars": ["add_ndvi", "Filtered"], "defined_vars": ["CollectionwithNDVI"], "parameters": ["add_ndvi"], "libraries": ["import geemap", "import ee"]}
{"code": "# Filter the features to select only the geometry collections.\ngeometrycollection = features.map(lambda f: ee.Feature(f).set('geometry_type', ee.Feature(f).geometry().type())).filter(ee.Filter.eq('geometry_type', 'GeometryCollection'))\n", "task": "Define a variable named `geometrycollection` that contains all features from the `features` list that are of type \"GeometryCollection\". Use the `ee` library to convert each feature to an `ee.Feature` object, set a property named `geometry_type` to the type of the feature's geometry, and then filter the resulting list for features where `geometry_type` is equal to \"GeometryCollection\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\nSSCGS_ADM4 = ee.FeatureCollection(\n    'projects/earthengine-legacy/assets/projects/sat-io/open-datasets/geoboundaries/SSCGS-ADM4')\n# Define the table variable with SSCGS_ADM4 (or CGAZ_ADM2) as the input.\ntable = SSCGS_ADM4\n# Convert the table to a list of features.\nfeatures = table.toList(table.size())\n", "functions": ["unknown_function.filter", "features.map", "unknown_function.set", "ee.Feature", "unknown_function.type", "unknown_function.geometry", "ee.Feature", "ee.Filter.eq"], "external_vars": ["f", "ee", "features"], "defined_vars": ["geometrycollection"], "parameters": ["geometry_type", "f", "f", "geometry_type", "GeometryCollection", "ee.Filter.eq('geometry_type', 'GeometryCollection')", "lambda f: ee.Feature(f).set('geometry_type', ee.Feature(f).geometry().type())", "ee.Feature(f).geometry().type()"], "libraries": ["import geemap", "import ee"]}
{"code": "# Composite the dataset and clip into the region\ns2_composite = s2filtered.median().clip(geometry)\n", "task": "Calculate the median value of the `s2filtered` dataset, clip it to the specified `geometry`, and store the result in a new variable called `s2_composite`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the geometry of the region of interest\ngeometry = ee.Geometry.Polygon([[[-56.052926888266825, -6.197669822910539], [-56.05524303386028, -6.910891091940537],\n                               [-55.063928517710906, -6.90030373668148], [-55.08889758664213, -6.186888896354678]]])\n# Load the Sentinel-2 TOA reflectance data\ns2 = ee.ImageCollection('COPERNICUS/S2')\n# Define a function to mask clouds using the Sentinel-2 QA band\n\n\ndef maskS2clouds(image):\n    \"\"\"\n    Function to mask clouds using the Sentinel-2 QA band.\n\n    Args:\n        image (ee.Image): Sentinel-2 image\n\n    Returns:\n        ee.Image: Sentinel-2 image with clouds masked\n    \"\"\"\n    qa = image.select('QA60')\n    cloud_bit_mask = ee.Number(2).pow(10).int()\n    cirrus_bit_mask = ee.Number(2).pow(11).int()\n    mask = qa.bitwiseAnd(cloud_bit_mask).eq(\n        0) and qa.bitwiseAnd(cirrus_bit_mask).eq(0)\n    return image.updateMask(mask).divide(10000)\n\n\n# Apply the cloud masking function over one year of data\ns2filtered = s2.filterDate('2017-01-01', '2017-12-31').filterMetadata(\n    'CLOUDY_PIXEL_PERCENTAGE', 'less_than', 10).map(maskS2clouds).select('B.*')\n", "functions": ["unknown_function.clip", "s2filtered.median"], "external_vars": ["s2filtered", "geometry"], "defined_vars": ["s2_composite"], "parameters": ["geometry"], "libraries": ["import ee", "import geemap"]}
{"code": "# Get a specific metadata property (CLOUDY_PIXEL_PERCENTAGE).\ncloudiness = image.get('CLOUDY_PIXEL_PERCENTAGE')\nprint('CLOUDY_PIXEL_PERCENTAGE: ', cloudiness)  # Prints the cloudiness as an ee.Number.\n", "task": "Retrieve the percentage of cloudy pixels from the image data and store it in a variable called \"cloudiness\". Then, print the value of \"cloudiness\" with a label.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load a Sentinel-2 image.\nimage = ee.Image('COPERNICUS/S2_SR/20210117T095341_20210117T100437_T32PLR')\n", "functions": ["image.get", "print"], "external_vars": ["image", "print"], "defined_vars": ["cloudiness"], "parameters": ["CLOUDY_PIXEL_PERCENTAGE", "CLOUDY_PIXEL_PERCENTAGE: ", "cloudiness"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the oil palm grid feature collection\nop_grid = ee.FeatureCollection(\"projects/ee-green-supply-chain-grid/assets/oilpalm_grids_new_634\")\n", "task": "Using the Earth Engine library (ee), define a variable called `op_grid` that represents a FeatureCollection from the asset \"projects/ee-green-supply-chain-grid/assets/oilpalm_grids_new_634\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.FeatureCollection"], "external_vars": ["ee"], "defined_vars": ["op_grid"], "parameters": ["projects/ee-green-supply-chain-grid/assets/oilpalm_grids_new_634"], "libraries": ["import geemap", "import ee"]}
{"code": "Map.addLayer(dem,{},'dem',False)\n", "task": "Add the digital elevation model (DEM) layer to the map. Make sure the `dem` variable represents the DEM data, and the `Map` variable represents the map object. The layer should be named \"dem\" and should be added to the map without being displayed. You may need to define variables for the `dem` and `Map` objects.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ndem = ee.ImageCollection('JAXA/ALOS/AW3D30/V3_2').mean().select('DSM')\n", "functions": ["Map.addLayer"], "external_vars": ["dem", "Map"], "defined_vars": [], "parameters": ["dem", "dem", false, "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "landsat_collections = landsat4.merge(landsat5).merge(landsat7_slcon).merge(landsat7_slcoff).merge(landsat8).merge(landsat9).sort('system:time_start')\n\n\n", "task": "Merge Landsat 4, 5, 7 (both SLC-on and SLC-off), 8, and 9 collections into a single collection called `landsat_collections`, sorted by the `system:time_start` property.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [[48.62559911358055, 31.65418476680761], [48.91124364483055, 31.65418476680761], [48.91124364483055,\n                                                                                        31.885355756064595], [48.62559911358055, 31.885355756064595], [48.62559911358055, 31.65418476680761]]\nroi = ee.Geometry.Polygon(cor)\n\n\ndef ndvi_tm_etm(img):\n    bands = img.multiply(2.75e-05).add(-0.2)\n    ndvi = bands.normalizedDifference(['SR_B4', 'SR_B3']).rename('ndvi')\n    return ndvi.copyProperties(img, img.propertyNames())\n\n\nlandsat4 = ee.ImageCollection('LANDSAT/LT04/C02/T1_L2').select('SR_B.*').filterDate('1982', '1994').filterBounds(roi).filter(\n    ee.Filter.lt('CLOUD_COVER', 45)).filter(ee.Filter.eq('WRS_PATH', 165)).filter(ee.Filter.eq('WRS_ROW', 38)).map(ndvi_tm_etm)\nlandsat5 = ee.ImageCollection('LANDSAT/LT05/C02/T1_L2').select('SR_B.*').filterDate('1984', '2013').filterBounds(roi).filter(\n    ee.Filter.lt('CLOUD_COVER', 45)).filter(ee.Filter.eq('WRS_PATH', 165)).filter(ee.Filter.eq('WRS_ROW', 38)).map(ndvi_tm_etm)\nlandsat7_slcon = ee.ImageCollection('LANDSAT/LE07/C02/T1_L2').select('SR_B.*').filterDate('1999', '2003-05-30').filterBounds(\n    roi).filter(ee.Filter.lt('CLOUD_COVER', 45)).filter(ee.Filter.eq('WRS_PATH', 165)).filter(ee.Filter.eq('WRS_ROW', 38)).map(ndvi_tm_etm)\n\n\ndef slc_off(img):\n    bands = img.multiply(2.75e-05).add(-0.2)\n    ndvi = bands.normalizedDifference(['SR_B4', 'SR_B3']).rename('ndvi')\n    filter = ndvi.focalMedian(1, 'square', 'pixels', 10)\n    filled = filter.blend(ndvi).rename('ndvi')\n    return filled.copyProperties(img, img.propertyNames())\n\n\nlandsat7_slcoff = ee.ImageCollection('LANDSAT/LE07/C02/T1_L2').select('SR_B.*').filterDate('2003-06-01', '2024').filterBounds(\n    roi).filter(ee.Filter.lt('CLOUD_COVER', 45)).filter(ee.Filter.eq('WRS_PATH', 165)).filter(ee.Filter.eq('WRS_ROW', 38)).map(slc_off)\n\n\ndef ndvi_oli(img):\n    bands = img.multiply(2.75e-05).add(-0.2)\n    ndvi = bands.normalizedDifference(['SR_B5', 'SR_B4']).rename('ndvi')\n    return ndvi.copyProperties(img, img.propertyNames())\n\n\nlandsat8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').select('SR_B.*').filterDate('2013', '2024').filterBounds(roi).filter(\n    ee.Filter.lt('CLOUD_COVER', 45)).filter(ee.Filter.eq('WRS_PATH', 165)).filter(ee.Filter.eq('WRS_ROW', 38)).map(ndvi_oli)\nlandsat9 = ee.ImageCollection('LANDSAT/LC09/C02/T1_L2').select('SR_B.*').filterDate('2021', '2024').filterBounds(roi).filter(\n    ee.Filter.lt('CLOUD_COVER', 45)).filter(ee.Filter.eq('WRS_PATH', 165)).filter(ee.Filter.eq('WRS_ROW', 38)).map(ndvi_oli)\n", "functions": ["unknown_function.sort", "unknown_function.merge", "unknown_function.merge", "unknown_function.merge", "unknown_function.merge", "landsat4.merge"], "external_vars": ["landsat4", "landsat7_slcon", "landsat7_slcoff", "landsat8", "landsat5", "landsat9"], "defined_vars": ["landsat_collections"], "parameters": ["system:time_start", "landsat9", "landsat8", "landsat7_slcoff", "landsat7_slcon", "landsat5"], "libraries": ["import ee", "import geemap"]}
{"code": "def slc_off(img):\n    bands = img.multiply(0.0000275).add(-0.2)\n    ndvi = bands.normalizedDifference(['SR_B4','SR_B3']).rename('ndvi')\n    filter = ndvi.focalMedian(1, 'square', 'pixels',10)\n    filled = filter.blend(ndvi).rename('ndvi')\n    return filled.copyProperties(img, img.propertyNames())\n", "task": "Create a function called `slc_off` that takes an image object `img` as input. The function should perform the following steps:\\n\\n1. **Scale the image:** Multiply the image by 2.75e-05 and add -0.2. Assign the result to a variable named `bands`.\\n2. **Calculate NDVI:** Compute the Normalized Difference Vegetation Index (NDVI) using bands 'SR_B4' and 'SR_B3' from the scaled image. Rename the resulting band to 'ndvi' and assign it to a variable named `ndvi`.\\n3. **Apply a median filter:** Apply a focal median filter with a radius of 1 pixel and a square kernel to the NDVI. Assign the filtered result to a variable named `filter`.\\n4. **Fill missing values:** Blend the filtered NDVI with the original NDVI to fill missing values. Rename the blended result to 'ndvi' and assign it to a variable named `filled`.\\n5. **Copy properties:** Copy the properties of the original image `img` to the filled NDVI image. Return the filled NDVI image.\\n\\n**Note:** Ensure the following variables are defined before calling this function: `filled`, `bands`, `filter`, `img`, and `ndvi`.", "exec_path": "GEE", "context": "", "functions": ["unknown_function.add", "img.multiply", "unknown_function.rename", "bands.normalizedDifference", "ndvi.focalMedian", "unknown_function.rename", "filter.blend", "filled.copyProperties", "img.propertyNames"], "external_vars": [], "defined_vars": ["bands", "filter", "filled", "ndvi", "img"], "parameters": [2.75e-05, "ndvi", 1, "square", "pixels", 10, "ndvi", "ndvi", "img", "-0.2", "['SR_B4', 'SR_B3']", "img.propertyNames()"], "libraries": []}
{"code": "# Compute the minimum of the filtered image collection.\ncollMin = filtered.reduce(ee.Reducer.min())\n", "task": "Using the Earth Engine library (ee) and the filtered image collection, calculate the minimum value of the image collection and store it in the variable `collMin`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the geometry of the area of interest.\ngeometry = ee.Geometry.Polygon([[[88.38682765324907, 26.73397682050905], [88.38682765324907, 26.728601205646328], [\n                               88.39648360570268, 26.728601205646328], [88.39648360570268, 26.73397682050905]]])\n# Load the Sentinel-2 image collection.\nS2_1C = ee.ImageCollection('COPERNICUS/S2')\n# Filter the image collection by date, cloud cover, and geometry.\nfiltered = S2_1C.filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 30)).filter(\n    ee.Filter.date('2019-01-01', '2020-01-01')).filter(ee.Filter.bounds(geometry)).select('B.*')\n", "functions": ["filtered.reduce", "ee.Reducer.min"], "external_vars": ["filtered", "ee"], "defined_vars": ["collMin"], "parameters": ["ee.Reducer.min()"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define a function to add NDVI to an image.\ndef add_ndvi(image):\n    ndvi = image.normalizedDifference(['B8', 'B4']).rename('NDVI')\n    return image.addBands(ndvi)\n", "task": "Add a new band called \"NDVI\" to the image, calculated as the normalized difference between bands \"B8\" and \"B4\". Make sure the variables [ndvi, image] are defined. ", "exec_path": "GEE", "context": "", "functions": ["unknown_function.rename", "image.normalizedDifference", "image.addBands"], "external_vars": [], "defined_vars": ["image", "ndvi"], "parameters": ["NDVI", "ndvi", "['B8', 'B4']"], "libraries": []}
{"code": "speckel = sen1_monthly.map(lambda img:img.focalMean(30, 'square', 'meters').copyProperties(img, img.propertyNames()))\n", "task": "Define a new variable `speckel` that applies the `focalMean` function to each image in `sen1_monthly` with a window size of 30 meters, a 'square' shape, and units of 'meters'. Then, use the `copyProperties` function to copy all properties from the original image (`img`) to the resulting focal mean image. ", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [[48.42331357710716, 31.94100799817005], [48.75839658491966, 31.94100799817005], [48.75839658491966,\n                                                                                        32.18773294099697], [48.42331357710716, 32.18773294099697], [48.42331357710716, 31.94100799817005]]\ngeometry = ee.Geometry.Polygon(cor)\ntime_start = '2020'\ntime_end = '2021'\nsen1 = ee.ImageCollection('COPERNICUS/S1_GRD').filterDate(time_start, time_end).filterBounds(geometry).filter(\n    ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')).filter(ee.Filter.eq('instrumentMode', 'IW')).select('VV')\nasc = sen1.filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING'))\ndes = sen1.filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'))\n\n\ndef func_(month):\n    asc_month = asc.filter(ee.Filter.calendarRange(\n        month, month, 'month')).mean().rename('asc')\n    des_month = des.filter(ee.Filter.calendarRange(\n        month, month, 'month')).mean().rename('des')\n    date = ee.Date.fromYMD(2020, month, 1)\n    return asc_month.addBands(des_month).set('system:time_start', date.millis()).set('system:index', date.format('YYYY-MM'))\n\n\nsen1_monthly = ee.ImageCollection(ee.List.sequence(1, 12).map(func_))\n", "functions": ["sen1_monthly.map", "unknown_function.copyProperties", "img.focalMean", "img.propertyNames"], "external_vars": ["img", "sen1_monthly"], "defined_vars": ["speckel"], "parameters": ["img", 30, "square", "meters", "lambda img: img.focalMean(30, 'square', 'meters').copyProperties(img, img.propertyNames())", "img.propertyNames()"], "libraries": ["import ee", "import geemap"]}
{"code": "lan8 = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_L2\").select(['ST_B10'],['LST']).filterDate('2013','2024').filterBounds(roi).filter(ee.Filter.eq('WRS_PATH', 164)).filter(ee.Filter.eq('WRS_ROW', 35))\n", "task": "Using the Earth Engine library (ee), define a variable named `lan8` that represents an ImageCollection of Landsat 8 imagery. This collection should be filtered to include only data from 2013 to 2024 within the specified region of interest (`roi`). Additionally, the collection should only include scenes from path 164 and row 35. Finally, rename the `ST_B10` band to `LST`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\ncor = [[51.02815260405151, 35.50852818710441], [51.69282545561401, 35.50852818710441], [51.69282545561401,\n                                                                                        35.8988380759623], [51.02815260405151, 35.8988380759623], [51.02815260405151, 35.50852818710441]]\nroi = ee.Geometry.Polygon(cor)\n", "functions": ["unknown_function.filter", "unknown_function.filter", "unknown_function.filterBounds", "unknown_function.filterDate", "unknown_function.select", "ee.ImageCollection", "ee.Filter.eq", "ee.Filter.eq"], "external_vars": ["ee", "roi"], "defined_vars": ["lan8"], "parameters": ["roi", "2013", "2024", "LANDSAT/LC08/C02/T1_L2", "WRS_PATH", 164, "WRS_ROW", 35, "ee.Filter.eq('WRS_ROW', 35)", "ee.Filter.eq('WRS_PATH', 164)", "['ST_B10']", "['LST']"], "libraries": ["import geemap", "import ee"]}
{"code": "thr = ndsi_max.gt(50)\n", "task": "Define a variable named `thr` that is a boolean array indicating where the values in the `ndsi_max` array are greater than 50.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\ntime_start = '2010'\ntime_end = '2015'\nmodis = ee.ImageCollection(\n    'MODIS/061/MOD10A1').select('NDSI_Snow_Cover').filterDate(time_start, time_end)\nlc = ee.ImageCollection('MODIS/061/MCD12Q1').select('LC_Type1').mode()\nwb = lc.eq(17)\nndsi_max = modis.max().updateMask(wb)\n", "functions": ["ndsi_max.gt"], "external_vars": ["ndsi_max"], "defined_vars": ["thr"], "parameters": [50], "libraries": ["import geemap", "import ee"]}
{"code": "# Display the layers on the map\nMap.addLayer(srtm, {'min': 0, 'max': 3000}, 'SRTM')\nMap.addLayer(slope, {'min': 0, 'max': 45}, 'Slope')\nMap.addLayer(water_occurrence,\n             {'bands': ['occurrence'], 'min': 25, 'max': 75, 'palette': 'lightblue,blue'},\n             'Water Occurrence')\n\n\n", "task": "Add the following layers to the map: \\n1. **SRTM** layer using `srtm` variable with min value 0 and max value 3000. \\n2. **Slope** layer using `slope` variable with min value 0 and max value 45.\\n3. **Water Occurrence** layer using `water_occurrence` variable with bands \"occurrence\", min value 25, max value 75, and palette \"lightblue,blue\".\\n\\nUse the `Map.addLayer` function for each layer. Note that the variables `srtm`, `Map`, `slope`, and `water_occurrence` are defined elsewhere. ", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the SRTM and Global Surface Water (GSW) images\nsrtm = ee.Image('CGIAR/SRTM90_V4')\nwater = ee.Image('JRC/GSW1_0/GlobalSurfaceWater')\n# Calculate the slope from the SRTM image\nslope = ee.Terrain.slope(srtm)\n# Compute statistics for water in the area\nwater_occurrence = water.select('occurrence')\n", "functions": ["Map.addLayer", "Map.addLayer", "Map.addLayer"], "external_vars": ["srtm", "Map", "water_occurrence", "slope"], "defined_vars": [], "parameters": ["srtm", "SRTM", "slope", "Slope", "water_occurrence", "Water Occurrence", "{'min': 0, 'max': 3000}", "{'min': 0, 'max': 45}", "{'bands': ['occurrence'], 'min': 25, 'max': 75, 'palette': 'lightblue,blue'}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the result to the map\nMap.setCenter(116.84, 4.85, 9)  # latitude, longitude, zoom level\nMap.addLayer(result) \n\n\n", "task": "Set the center of the map to the coordinates (116.84, 4.85) with a zoom level of 9. Then add the layer stored in the variable \"result\" to the map.  Make sure you have defined variables \"Map\" and \"result\". ", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the geometries\ngeometry = ee.Geometry.Polygon([[[116.25338486328133, 4.987186579466683], [116.45113876953133, 4.776467086078755], [\n                               116.47585800781258, 4.981714188823658], [116.30556992187508, 5.047379855385064]]])\ngeometry2 = ee.Geometry.Polygon([[[117.12954453125008, 5.0254920341149525], [117.12130478515633, 4.7326729951223605], [\n                                117.34652451171883, 4.762781731906076], [117.29983261718758, 5.0501157811846875]]])\n# Create an image with the geometries painted on it\nimage = ee.Image().byte().paint(geometry, 0).paint(\n    geometry, 1, 5).paint(geometry2, 2).paint(geometry2, 3, 5)\n# Create FeatureCollections for the geometries\nc = ee.FeatureCollection([ee.Feature(geometry)])\nc2 = ee.FeatureCollection([ee.Feature(geometry2)])\n# Load the SRTM90 image\nimg = ee.Image('srtm90_v4').visualize(\n    {'min': 0, 'max': 3000, 'palette': ['green', 'yellow']})\n# Draw the geometries on the image\nd1 = c.draw('red')\nd2 = c2.draw('blue')\n# Mosaic the image and the drawings\nresult = ee.ImageCollection([img, d1, d2]).mosaic()\n", "functions": ["Map.setCenter", "Map.addLayer"], "external_vars": ["result", "Map"], "defined_vars": [], "parameters": [116.84, 4.85, 9, "result"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the chart parameters for the surface pressure and air temperature charts.\nsurface_pressure_chart_params = {\n    'title': 'Surface Pressure from ERA5',\n    'region': peninsula,\n    'reducer': ee.Reducer.mean(),\n    'series': {'surface_pressure': 'Surface Pressure (Pa)'}\n}\n\nair_temperature_chart_params = {\n    'title': 'Air Temperature from ERA5',\n    'region': peninsula,\n    'reducer': ee.Reducer.mean(),\n    'series': {'T_2mDegrees': 'Air Temperature (Celsius)'}\n}\n\n\n", "task": "Define two dictionaries, `surface_pressure_chart_params` and `air_temperature_chart_params`, using the provided variables `peninsula` and `ee`. Each dictionary should contain the keys `title`, `region`, `reducer`, and `series`.  The `region` should be set to the `peninsula` variable, the `reducer` should be set to `ee.Reducer.mean()`, and the `series` should be a dictionary containing the key-value pairs for the specific data variable and its display name. For `surface_pressure_chart_params`, the series should be `{'surface_pressure': 'Surface Pressure (Pa)'}`, and for `air_temperature_chart_params`, the series should be `{'T_2mDegrees': 'Air Temperature (Celsius)'}`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Define the region of interest (ROI) as a polygon.\npeninsula = ee.Geometry.Polygon([[[-59.95761783573391, -63.47027086385727], [-60.00156314823391, -63.72430838809856], [-59.90268619510891, -63.850478274051596], [-58.10092838260891, -64.54856148515674], [-57.39780338260891, -64.62870606429087], [-56.87045963260891, -64.58159077408938], [-56.49692447635891, -64.34954328808792], [-56.49692447635891, -64.12031784565966], [-57.04624088260891, -63.966442709295826], [-56.71665103885891, -63.68050259008884],\n                                [-55.61801822635891, -63.621989359411735], [-55.22251041385891, -63.46536326642057], [-54.60727603885891, -63.53399306066353], [-54.32163150760891, -63.32760830259313], [-54.73911197635891, -63.27330915962219], [-54.58530338260891, -63.169362717394144], [-55.49716861698391, -62.88032566483948], [-56.84848697635891, -62.85026153286475], [-57.13413150760891, -63.074993547686454], [-58.25473697635891, -63.278249674148896], [-58.91391666385891, -63.18423509431014]]])\n", "functions": ["ee.Reducer.mean", "ee.Reducer.mean"], "external_vars": ["ee", "peninsula"], "defined_vars": ["air_temperature_chart_params", "surface_pressure_chart_params"], "parameters": [], "libraries": ["import ee", "import geemap"]}
{"code": "# Filter the Sentinel-1 Image Collection for a different time period\ndry = s1.filterBounds(geometry) .filterDate('2019-11-13', '2019-11-26') .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')) .select('VV') .reduce(ee.Reducer.percentile([90]))\n", "task": "Using the variables `s1`, `ee`, and `geometry`, filter the Sentinel-1 data (`s1`) within the specified `geometry`, for the date range \"2019-11-13\" to \"2019-11-26\", selecting only data with \"VV\" polarization. Then, calculate the 90th percentile of the \"VV\" band and store the result in a variable named `dry`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Define the Sentinel-1 Image Collection\ns1 = ee.ImageCollection('COPERNICUS/S1_GRD')\n# Define the Region of Interest (ROI)\ngeometry = ee.Geometry.Polygon([[[8.76839355358185, 45.203085572066264], [8.76839355358185, 44.919840266349865], [\n                               9.9301977528006, 44.919840266349865], [9.9301977528006, 45.203085572066264]]])\n", "functions": ["unknown_function.reduce", "unknown_function.select", "unknown_function.filter", "unknown_function.filterDate", "s1.filterBounds", "ee.Filter.listContains", "ee.Reducer.percentile"], "external_vars": ["ee", "geometry", "s1"], "defined_vars": ["dry"], "parameters": ["VV", "2019-11-13", "2019-11-26", "geometry", "transmitterReceiverPolarisation", "VV", "ee.Reducer.percentile([90])", "ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')", "[90]"], "libraries": ["import ee", "import geemap"]}
{"code": "# Make a \"greenest\" pixel composite\ngreenest_2 = with_ndvi_squared.qualityMosaic('NDVI_squared')\n", "task": "Define a variable called `greenest_2` by performing a quality mosaic on the `with_ndvi_squared` object using the 'NDVI_squared' band.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# ee.Geometry.Point() function as demonstrated here.\npoint = ee.Geometry.Point([-41.4329728109325, -12.57788396003372])\n# Import the Landsat 8 TOA image collection.\nl8 = ee.ImageCollection('LANDSAT/LC08/C02/T1')\n# Get the least cloudy image in 2015\nimage = l8.filterBounds(point).filterDate(\n    '2015-01-01', '2015-12-31').sort('CLOUD_COVER').first()\n\n\ndef add_ndvi_squared(image):\n    ndvi = image.normalizedDifference(['B5', 'B4'])\n    ndvi_squared = ndvi.multiply(ndvi).rename('NDVI_squared')\n    return image.addBands(ndvi_squared)\n\n\nwith_ndvi_squared = l8.map(add_ndvi_squared)\n", "functions": ["with_ndvi_squared.qualityMosaic"], "external_vars": ["with_ndvi_squared"], "defined_vars": ["greenest_2"], "parameters": ["NDVI_squared"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define a function to create a time series feature from each image\ndef createTS(img):\n  # Get the start date of the image\n  date = img.get('system:time_start')\n\n  # Reduce the image to calculate the sum of the weighted areas of the indices.And cloud masks within the ROI\n  AWEInsh = img.reduceRegion(reducer=ee.Reducer.sum(), geometry=ROI, maxPixels=1e8).get('AWEI_nsh')\n  AWEIsh = img.reduceRegion(reducer=ee.Reducer.sum(), geometry=ROI, maxPixels=1e8).get('AWEI_sh')\n  MNDWI = img.reduceRegion(reducer=ee.Reducer.sum(), geometry=ROI, maxPixels=1e8).get('mNDWI')\n  Cirrus = img.reduceRegion(reducer=ee.Reducer.sum(), geometry=ROI, maxPixels=1e8).get('Cirrus')\n  Dense = img.reduceRegion(reducer=ee.Reducer.sum(), geometry=ROI, maxPixels=1e8).get('Dense')\n\n  # Create a Feature with the date.And calculated values\n  ft = ee.Feature(None, {'date': ee.Date(date).format('Y/M/d'), \n                         'AWEInsh': AWEInsh,\n                         'AWEIsh': AWEIsh,\n                         'mNDWI': MNDWI,\n                         'Cirrus': Cirrus,\n                         'Dense': Dense})\n\n  # Return the Feature\n  return ft\n", "task": "Define variables `ee`, `ROI`, `img`, `AWEInsh`, `AWEIsh`, `date`, `MNDWI`, `Cirrus`, and `Dense`. Then, create a function called `createTS` which takes `img` as an input and returns a feature `ft`.  The `ft` should have the following properties: `date`, `AWEInsh`, `AWEIsh`, `mNDWI`, `Cirrus`, and `Dense`. Use `img.get('system:time_start')` to get the date, and `img.reduceRegion(reducer=ee.Reducer.sum(), geometry=ROI, maxPixels=100000000.0).get(\"property_name\")` to get the values for the other properties, where `property_name` should be replaced with the corresponding property name from the feature properties.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Set the region of interest (ROI) as a FeatureCollection\nROI = ee.FeatureCollection('users/ce15btech11022/Final_Cities/Ahmedabad')\n", "functions": ["img.get", "unknown_function.get", "img.reduceRegion", "ee.Reducer.sum", "unknown_function.get", "img.reduceRegion", "ee.Reducer.sum", "unknown_function.get", "img.reduceRegion", "ee.Reducer.sum", "unknown_function.get", "img.reduceRegion", "ee.Reducer.sum", "unknown_function.get", "img.reduceRegion", "ee.Reducer.sum", "ee.Feature", "unknown_function.format", "ee.Date"], "external_vars": ["ROI", "ee"], "defined_vars": ["AWEInsh", "img", "Dense", "Cirrus", "date", "AWEIsh", "ft", "MNDWI"], "parameters": ["system:time_start", "AWEI_nsh", "AWEI_sh", "mNDWI", "Cirrus", "Dense", null, "Y/M/d", "date", "{'date': ee.Date(date).format('Y/M/d'), 'AWEInsh': AWEInsh, 'AWEIsh': AWEIsh, 'mNDWI': MNDWI, 'Cirrus': Cirrus, 'Dense': Dense}"], "libraries": ["import geemap", "import ee"]}
{"code": "geometry = ee.Geometry.Polygon(cor1)\n", "task": "Define a variable named `geometry` as an Earth Engine Polygon using the coordinates stored in the variable `cor1`. Use the `ee.Geometry.Polygon()` function to create the polygon.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\ncor1 = [[-113.80502319704019, 42.704955393175936], [-113.56057739625894, 42.704955393175936], [-113.56057739625894,\n                                                                                               42.862689736716995], [-113.80502319704019, 42.862689736716995], [-113.80502319704019, 42.704955393175936]]\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee", "cor1"], "defined_vars": ["geometry"], "parameters": ["cor1"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the Sentinel-1 images.\nbefore = (\n    ee.ImageCollection(\"COPERNICUS/S1_GRD\")\n.filterDate(\"2019-11-13\", \"2019-11-14\")\n.filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))\n.filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n.filterMetadata(\"resolution_meters\", \"equals\", 10)\n.select(\"VV\")\n.median()\n)\n\nafter = (\n    ee.ImageCollection(\"COPERNICUS/S1_GRD\")\n.filterDate(\"2019-11-25\", \"2019-11-26\")\n.filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))\n.filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n.filterMetadata(\"resolution_meters\", \"equals\", 10)\n.select(\"VV\")\n.median()\n)\n", "task": "Calculate the difference between the values of the variable \"ee\" before and after executing the provided code. Ensure that the code defines the variables \"after\" and \"before\" before making the calculation. ", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["unknown_function.median", "unknown_function.select", "unknown_function.filterMetadata", "unknown_function.filter", "unknown_function.filter", "unknown_function.filterDate", "ee.ImageCollection", "ee.Filter.listContains", "ee.Filter.eq", "unknown_function.median", "unknown_function.select", "unknown_function.filterMetadata", "unknown_function.filter", "unknown_function.filter", "unknown_function.filterDate", "ee.ImageCollection", "ee.Filter.listContains", "ee.Filter.eq"], "external_vars": ["ee"], "defined_vars": ["after", "before"], "parameters": ["VV", "resolution_meters", "equals", 10, "2019-11-13", "2019-11-14", "COPERNICUS/S1_GRD", "transmitterReceiverPolarisation", "VV", "instrumentMode", "IW", "VV", "resolution_meters", "equals", 10, "2019-11-25", "2019-11-26", "COPERNICUS/S1_GRD", "transmitterReceiverPolarisation", "VV", "instrumentMode", "IW", "ee.Filter.eq('instrumentMode', 'IW')", "ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')", "ee.Filter.eq('instrumentMode', 'IW')", "ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the geometry of the study area.\ngeometry = ee.Geometry.Polygon([\n  [-0.831530669699112, 42.64129586043597],\n  [-0.831530669699112, 37.32568333218967],\n  [7.166516205300888, 37.32568333218967],\n  [7.166516205300888, 42.64129586043597]\n])\n", "task": "Using the `ee` library, define a variable named `geometry` as an Earth Engine Polygon with the following coordinates: [[-0.831530669699112, 42.64129586043597], [-0.831530669699112, 37.32568333218967], [7.166516205300888, 37.32568333218967], [7.166516205300888, 42.64129586043597]]", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee"], "defined_vars": ["geometry"], "parameters": ["[[-0.831530669699112, 42.64129586043597], [-0.831530669699112, 37.32568333218967], [7.166516205300888, 37.32568333218967], [7.166516205300888, 42.64129586043597]]"], "libraries": ["import geemap", "import ee"]}
{"code": "# Filter the MODIS/006/MYD09GA collection by the oil spill geometry\ncollection = ee.ImageCollection('MODIS/006/MYD09GA').filterBounds(oil)\n", "task": "Using the Earth Engine library (ee), load the MODIS/006/MYD09GA image collection and filter it to include only images that intersect the geometry defined by the variable `oil`. Store the resulting filtered image collection in the variable `collection`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the geometry of the area of interest\ngeometry = ee.Geometry.Polygon([[[-90.15234375, 30.26147225282594], [-90.15234375, 29.52614052092204],\n                               [-89.049072265625, 29.52614052092204], [-89.049072265625, 30.26147225282594]]])\n# Define the geometry of the oil spill area\noil = ee.Geometry.Polygon([[[57.71639387540342, -20.380972663998552], [57.71639387540342, -20.42055266581538],\n                          [57.7538160555792, -20.42055266581538], [57.7538160555792, -20.380972663998552]]])\n", "functions": ["unknown_function.filterBounds", "ee.ImageCollection"], "external_vars": ["oil", "ee"], "defined_vars": ["collection"], "parameters": ["oil", "MODIS/006/MYD09GA"], "libraries": ["import geemap", "import ee"]}
{"code": "join = ee.Join.inner()\nfilter = ee.Filter.equals(\n  leftField='date', rightField='date'\n  )\njoin_collection = ee.ImageCollection(join.apply(fldas, grace, filter))\n", "task": "Use the Earth Engine library (`ee`) to perform an inner join between the `fldas` and `grace` image collections. The join should be based on the matching `date` property in both collections. Define variables named `join`, `filter`, and `join_collection` to store the join object, the filter criteria, and the resulting joined image collection, respectively.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ntime_start = '2020'\ntime_end = '2021'\n\n\ndef func_(img):\n    date = img.date().format('YYYY-MM')\n    return img.toInt().copyProperties(img, img.propertyNames()).set('date', date)\n\n\ngrace = ee.ImageCollection('NASA/GRACE/MASS_GRIDS_V03/MASCON_CRI').select(\n    'lwe_thickness').filterDate(time_start, time_end).map(func_)\n\n\ndef func2_(img):\n    date = img.date().format('YYYY-MM')\n    return img.copyProperties(img, img.propertyNames()).set('date', date)\n\n\nfldas = ee.ImageCollection('NASA/FLDAS/NOAH01/C/GL/M/V001').select('Snow.*', 'SWE_inst',\n                                                                   'SoilMoi00_10cm_tavg', 'Rainf_f_tavg').filterDate(time_start, time_end).map(func2_)\n", "functions": ["ee.Join.inner", "ee.Filter.equals", "ee.ImageCollection", "join.apply"], "external_vars": ["ee", "grace", "fldas"], "defined_vars": ["filter", "join", "join_collection"], "parameters": ["fldas", "grace", "filter", "join.apply(fldas, grace, filter)"], "libraries": ["import ee", "import geemap"]}
{"code": "# Center the map on the geometry\nMap.centerObject(geometry, 17)\n", "task": "Using the provided `Map` object, center the `geometry` object on the map at zoom level 17.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the geometry as a polygon\ngeometry = ee.Geometry.Polygon([[175.65420985221863, -39.13437121286583], [175.65410256385803, -39.13457510191529], [175.65424740314484, -39.1349163026774], [175.65453171730042, -39.13506193664559], [\n                               175.65478920936584, -39.13502448793968], [175.65471410751343, -39.1346291948293], [175.6545478105545, -39.13444194994987], [175.654456615448, -39.1343379248017]])\n", "functions": ["Map.centerObject"], "external_vars": ["geometry", "Map"], "defined_vars": [], "parameters": ["geometry", 17], "libraries": ["import geemap", "import ee"]}
{"code": "# Create an index array with values from 0 to length-1.\nindices = ee.Image(ee.Array(ee.List.sequence(0, length))).arraySlice(0, 0, length)\n", "task": "Using the Earth Engine library (ee), create a list of indices from 0 to `length` and convert it to an Earth Engine image, assigning the resulting image to the variable `indices`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the image you want to work with.\nthearrayimage = ee.Image([3, 4, 1, 55, 2]).toArray()\n# Get the length of the array along the first dimension.\nlength = thearrayimage.arrayLength(0)\n", "functions": ["unknown_function.arraySlice", "ee.Image", "ee.Array", "ee.List.sequence"], "external_vars": ["length", "ee"], "defined_vars": ["indices"], "parameters": [0, 0, "length", 0, "length", "ee.Array(ee.List.sequence(0, length))", "ee.List.sequence(0, length)"], "libraries": ["import geemap", "import ee"]}
{"code": "#temporal collection function\ndef temporal_collection(collection, start, count, interval, unit):\n    seq = ee.List.sequence(0, ee.Number(count).subtract(1))\n    origin_date = ee.Date(start)\n    def func_(i):\n        start_date = origin_date.advance(ee.Number(interval).multiply(i), unit)\n        end_date = origin_date.advance(ee.Number(interval).multiply(ee.Number(i).add(1)), unit)\n        return collection.filterDate(start_date, end_date).mean().set('system:time_start', start_date.millis()).set('system:time_end', end_date.millis())\n    return ee.ImageCollection(seq.map(func_))\n", "task": "Define a function called `temporal_collection` that takes in an `ee.ImageCollection` called `collection`, a start date string called `start`, an integer called `count` representing the number of intervals, an integer called `interval` representing the length of each interval, and a string called `unit` representing the time unit for the intervals. The function should use `ee.List.sequence` to create a list of integers from 0 to `count-1` and store it in a variable called `seq`. It should also create an `ee.Date` object called `origin_date` from the `start` string. Define a nested function called `func_` that takes an integer `i` as input. Inside `func_`, use `ee.Number` and `ee.Date.advance` to calculate the start and end dates for each interval using `i`, `interval`, and `unit` and store them in variables called `start_date` and `end_date` respectively. Then, use `ee.ImageCollection.filterDate` to filter the `collection` to images between `start_date` and `end_date`, calculate the mean of the filtered collection, and use `ee.Image.set` to add `system:time_start` and `system:time_end` properties to the resulting image. Finally, use `ee.ImageCollection.map` to apply `func_` to each element of `seq` and return the resulting `ee.ImageCollection`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n", "functions": ["ee.List.sequence", "unknown_function.subtract", "ee.Number", "ee.Date", "origin_date.advance", "unknown_function.multiply", "ee.Number", "origin_date.advance", "unknown_function.multiply", "ee.Number", "unknown_function.add", "ee.Number", "unknown_function.set", "unknown_function.set", "unknown_function.mean", "collection.filterDate", "start_date.millis", "end_date.millis", "ee.ImageCollection", "seq.map"], "external_vars": ["ee", "func_"], "defined_vars": ["collection", "start", "start_date", "unit", "seq", "interval", "origin_date", "end_date", "i", "count"], "parameters": [0, 1, "count", "start", "unit", "i", "interval", "unit", "interval", 1, "i", "system:time_end", "system:time_start", "start_date", "end_date", "func_", "ee.Number(count).subtract(1)", "ee.Number(interval).multiply(i)", "ee.Number(interval).multiply(ee.Number(i).add(1))", "ee.Number(i).add(1)", "end_date.millis()", "start_date.millis()", "seq.map(func_)"], "libraries": ["import ee", "import geemap"]}
{"code": "# Limit the collection to the 10 most recent images.\nrecent = landsat8_toa.sort('system:time_start', False).limit(10)\nprint('Recent images: ', recent)\n\n\n", "task": "Sort the `landsat8_toa` collection by the `system:time_start` property in descending order and limit the result to the 10 most recent images. Assign the result to a variable named `recent` and then use the `print` function to display the `recent` images.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load a Landsat 8 ImageCollection (USGS Landsat 8 Collection 1 Tier 1 TOA Reflectance) for a single path-row.\nlandsat8_toa = ee.ImageCollection('LANDSAT/LC08/C01/T1_TOA').filter(ee.Filter.eq(\n    'WRS_PATH', 188)).filter(ee.Filter.eq('WRS_ROW', 52)).filterDate('2021-01-01', '2021-05-03')\n", "functions": ["unknown_function.limit", "landsat8_toa.sort", "print"], "external_vars": ["landsat8_toa", "print"], "defined_vars": ["recent"], "parameters": [10, "system:time_start", false, "Recent images: ", "recent"], "libraries": ["import geemap", "import ee"]}
{"code": "geometry2 = ee.Geometry.Polygon(cor2)\n", "task": "Define a new variable called `geometry2` using the `ee.Geometry.Polygon` function with the coordinates stored in the variable `cor2`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\ncor = [[48.10178521249212, 30.724369816411947], [49.06308892342962, 30.724369816411947], [49.06308892342962,\n                                                                                          31.444134120146206], [48.10178521249212, 31.444134120146206], [48.10178521249212, 30.724369816411947]]\ngeometry = ee.Geometry.Polygon(cor)\ncor2 = [[48.54810479257024, 30.974198964042525], [48.56321099374212, 30.974198964042525], [48.56321099374212,\n                                                                                           30.984795502612585], [48.54810479257024, 30.984795502612585], [48.54810479257024, 30.974198964042525]]\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee", "cor2"], "defined_vars": ["geometry2"], "parameters": ["cor2"], "libraries": ["import ee", "import geemap"]}
{"code": "# Load the JRC max water extent layer\nwater = ee.Image('JRC/GSW1_4/GlobalSurfaceWater').select('max_extent')\n", "task": "Using the Earth Engine library (`ee`), load the Global Surface Water dataset (JRC/GSW1_4/GlobalSurfaceWater) and select the `max_extent` band. Assign this to a variable named `water`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["unknown_function.select", "ee.Image"], "external_vars": ["ee"], "defined_vars": ["water"], "parameters": ["max_extent", "JRC/GSW1_4/GlobalSurfaceWater"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the Sentinel-2 SR Harmonized image collection\ns2_img_coll = ee.ImageCollection(\"COPERNICUS/S2_SR_HARMONIZED\")\n", "task": "Using the Earth Engine library (ee), define a variable named `s2_img_coll` that represents the Sentinel-2 Surface Reflectance Harmonized image collection.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["s2_img_coll"], "parameters": ["COPERNICUS/S2_SR_HARMONIZED"], "libraries": ["import ee", "import geemap"]}
{"code": "plots = ee.FeatureCollection('users/wangyxtina/ForestPlots/MartinSullivan2020Science_AllPlots')\nprint(plots, 'all plots')\n", "task": "Using the Earth Engine library (`ee`), load the feature collection \"users/wangyxtina/ForestPlots/MartinSullivan2020Science_AllPlots\" into a variable named `plots`. Then, use the `print` function to display the contents of `plots` along with the label \"all plots\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.FeatureCollection", "print"], "external_vars": ["ee", "print"], "defined_vars": ["plots"], "parameters": ["users/wangyxtina/ForestPlots/MartinSullivan2020Science_AllPlots", "plots", "all plots"], "libraries": ["import ee", "import geemap"]}
{"code": "roi = table.filterBounds(geometry).map(lambda feature:feature.simplify(500))\n", "task": "Define a variable called `roi` that represents a filtered and simplified version of the `table`. First, filter the `table` using the bounds of the `geometry`. Then, for each `feature` in the filtered table, simplify it using a tolerance of 500.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [[51.09050885517992, 35.57496936569026], [51.58214703877367, 35.57496936569026], [51.58214703877367,\n                                                                                        35.85149920592443], [51.09050885517992, 35.85149920592443], [51.09050885517992, 35.57496936569026]]\ngeometry = ee.Geometry.Polygon(cor)\ntable = ee.FeatureCollection('FAO/GAUL/2015/level1')\n", "functions": ["unknown_function.map", "table.filterBounds", "feature.simplify"], "external_vars": ["geometry", "feature", "table"], "defined_vars": ["roi"], "parameters": ["geometry", 500, "lambda feature: feature.simplify(500)"], "libraries": ["import ee", "import geemap"]}
{"code": "# Load the 1992 Ordnance Survey land cover map\ny = ee.ImageCollection('projects/ee-os-land-cover-30m-maps-1/assets/os_landcover_maps_1991-2000') .filter(ee.Filter.stringContains('system:index', '1992')) .mosaic()\n", "task": "Using the Earth Engine library (ee), create an image collection from the \"projects/ee-os-land-cover-30m-maps-1/assets/os_landcover_maps_1991-2000\" asset, filter it to include only the image with \"1992\" in its index, and mosaic the remaining images into a single image. Store the resulting image in the variable **y**.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["unknown_function.mosaic", "unknown_function.filter", "ee.ImageCollection", "ee.Filter.stringContains"], "external_vars": ["ee"], "defined_vars": ["y"], "parameters": ["projects/ee-os-land-cover-30m-maps-1/assets/os_landcover_maps_1991-2000", "system:index", "1992", "ee.Filter.stringContains('system:index', '1992')"], "libraries": ["import geemap", "import ee"]}
{"code": "# Calculate the area of the geometry\nArea = geometry.area()\nprint(Area)\nMap.centerObject(geometry, 17)  # Center the map on the geometry\n", "task": "Calculate the area of the given geometry using the `geometry.area()` method. Store the result in a variable called `Area`. Then, print the value of `Area`. Finally, use the `Map.centerObject()` method to center the geometry on the map at zoom level 17.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the geometry (polygon)\ngeometry = ee.Geometry.Polygon([[[175.65420985221863, -39.13437121286583], [175.65410256385803, -39.13457510191529], [175.65424740314484, -39.1349163026774], [175.65453171730042, -39.13506193664559], [\n                               175.65478920936584, -39.13502448793968], [175.65471410751343, -39.1346291948293], [175.6545478105545, -39.13444194994987], [175.654456615448, -39.1343379248017]]])\n", "functions": ["geometry.area", "print", "Map.centerObject"], "external_vars": ["geometry", "print", "Map"], "defined_vars": ["Area"], "parameters": ["Area", "geometry", 17], "libraries": ["import geemap", "import ee"]}
{"code": "# Add layers to the map for visualization\nMap.setCenter(-1.91, 5.81, 12)\nMap.addLayer(filterDate, trueColor, 'RGB', 0)\nMap.addLayer(filterDate, falseColor, 'FalseColor', 0)\nMap.addLayer(median, trueColor, 'RGBmedian', 0)\nMap.addLayer(composite, trueColor, 'RGB2020', 0)\nMap.addLayer(composite2, trueColor2, 'RGB2009', 0)\nMap.addLayer(composite, falseColor, 'False2020', 0)\n", "task": "Center the map at coordinates (-1.91, 5.81) with a zoom level of 12. Add the following layers to the map, using the provided variables: \\n\\n* `filterDate`: with `trueColor` as the image, labeled as \"RGB\"\\n* `filterDate`: with `falseColor` as the image, labeled as \"FalseColor\"\\n* `median`: with `trueColor` as the image, labeled as \"RGBmedian\"\\n* `composite`: with `trueColor` as the image, labeled as \"RGB2020\"\\n* `composite2`: with `trueColor2` as the image, labeled as \"RGB2009\"\\n* `composite`: with `falseColor` as the image, labeled as \"False2020\"\\n\\n**Required Variables:**\\n* `composite`\\n* `trueColor`\\n* `trueColor2`\\n* `median`\\n* `composite2`\\n* `falseColor`\\n* `filterDate`\\n* `Map`\\n\\n**Note:** All layers should be added at the 0th layer index.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define Landsat 8 and Landsat 7 image collections\nl8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\nl7 = ee.ImageCollection('LANDSAT/LE07/C02/T1_RT')\n# Filter Landsat 8 image collection by date range\nfilterDate = l8.filterDate('2022-01-01', '2022-12-31')\n# Calculate the median pixel value for the filtered collection\nmedian = filterDate.median()\n# Define visualization parameters for true color and false color composites\ntrueColor = {'min': 0, 'max': 0.3, 'bands': ['B4', 'B3', 'B2']}\ntrueColor2 = {'min': 0, 'max': 0.3, 'bands': ['B3', 'B2', 'B1']}\nfalseColor = {'min': 0, 'max': 0.3, 'bands': ['B5', 'B4', 'B3']}\n# Define a cloud removal function for Landsat images using the simple composite algorithm\n\n\ndef simple_composite(collection, as_float=True):\n    \"\"\"\n    Applies the simple composite algorithm to a Landsat image collection.\n\n    Args:\n        collection (ee.ImageCollection): The Landsat image collection to apply the algorithm to.\n        as_float (bool, optional): Whether to convert the output image to float. Defaults to True.\n\n    Returns:\n        ee.Image: The composite image.\n    \"\"\"\n    return ee.Algorithms.Landsat.simpleComposite({'collection': collection, 'asFloat': as_float})\n\n\n# Apply cloud removal to Landsat 8 and Landsat 7 collections\ncomposite = simple_composite(l8.filterDate(\n    '2022-01-01', '2022-12-31'), as_float=True)\ncomposite2 = simple_composite(l7.filterDate(\n    '2022-01-01', '2022-12-31'), as_float=True)\n", "functions": ["Map.setCenter", "Map.addLayer", "Map.addLayer", "Map.addLayer", "Map.addLayer", "Map.addLayer", "Map.addLayer"], "external_vars": ["falseColor", "composite", "Map", "trueColor2", "trueColor", "median", "filterDate", "composite2"], "defined_vars": [], "parameters": [5.81, 12, "filterDate", "trueColor", "RGB", 0, "filterDate", "falseColor", "FalseColor", 0, "median", "trueColor", "RGBmedian", 0, "composite", "trueColor", "RGB2020", 0, "composite2", "trueColor2", "RGB2009", 0, "composite", "falseColor", "False2020", 0, "-1.91"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the RGB visualization of the image to the map\nMap.addLayer(image.select(['B4', 'B3', 'B2']), {'min': 0, 'max': 3000}, 'RGB')\n", "task": "Add a layer to the map using the `image` variable. Select bands `B4`, `B3`, and `B2` from the image and display them in RGB with a min value of 0 and a max value of 3000. Make sure the variables `image` and `Map` are defined.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the geometry of interest, in this case a rectangle\ngeometry = ee.Geometry.Polygon([[115.81810323928907, -31.94727319521792], [115.81810323928907, -31.98295314826852], [\n                               115.91749517654493, -31.98295314826852], [115.91749517654493, -31.94727319521792]])\n# Define the bands of interest\nbands = ['B2', 'B3', 'B4', 'B8', 'B8A', 'B11']\n# Load the Sentinel-2 SR image collection\nimage_collection = ee.ImageCollection('COPERNICUS/S2_SR')\n# Filter the image collection by the geometry and select the bands of interest\nimage = image_collection.filterBounds(geometry).select(bands).median()\n", "functions": ["Map.addLayer", "image.select"], "external_vars": ["image", "Map"], "defined_vars": [], "parameters": ["RGB", "image.select(['B4', 'B3', 'B2'])", "{'min': 0, 'max': 3000}", "['B4', 'B3', 'B2']"], "libraries": ["import geemap", "import ee"]}
{"code": "# Get the elevation band from the DEM.\nelev = dem30.select('elevation')\n", "task": "Using the `dem30` dataset, select the 'elevation' field and assign it to a variable named `elev`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\ndem30 = ee.Image('USGS/SRTMGL1_003')\n", "functions": ["dem30.select"], "external_vars": ["dem30"], "defined_vars": ["elev"], "parameters": ["elevation"], "libraries": ["import geemap", "import ee"]}
{"code": "# Generate 100 random points within Colorado\npoints = ee.FeatureCollection.randomPoints(\n  region=co_geo,\n  points=100\n)\n", "task": "Using the Earth Engine library (ee) and the geographic region defined by \"co_geo\", generate a FeatureCollection of 100 randomly distributed points. Store the resulting FeatureCollection in the variable \"points\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Load the states feature collection and filter to Colorado\nstates = ee.FeatureCollection('TIGER/2018/States')\ncolorado = states.filter(ee.Filter.eq('NAME', 'Colorado'))\n# Convert Colorado from a feature collection to a feature\nco = colorado.first()\n# Convert Colorado from a feature to a geometry\nco_geo = co.geometry()\n", "functions": ["ee.FeatureCollection.randomPoints"], "external_vars": ["ee", "co_geo"], "defined_vars": ["points"], "parameters": [], "libraries": ["import ee", "import geemap"]}
{"code": "# Display the image on the map\nMap.centerObject(image)\nMap.addLayer(image, image_vis_params, \"Sentinel-2\")\n", "task": "Center the map on the image and add it as a layer named \"Sentinel-2\" using the provided visualization parameters. Make sure the variables `image`, `Map`, and `image_vis_params` are defined.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the Sentinel-2 image collection\nimage_collection = ee.ImageCollection('COPERNICUS/S2')\n# Define the geometry (point) of interest\ngeometry = ee.Geometry.Point([-116.96939553275278, 32.790786772668355])\n# Define the visualization parameters for Sentinel-2 imagery\nimage_vis_params = {'opacity': 1, 'bands': [\n    'B12', 'B8A', 'B4'], 'min': 317.62, 'max': 7595.38, 'gamma': 1.518}\n# Filter the Sentinel-2 image collection by date and geometry\nimage_a = image_collection.filterDate(\n    '2020-09-01', '2020-10-31').filterBounds(geometry).sort('CLOUD_COVERAGE_ASSESSMENT', True)\n# Get the first image from the filtered collection\nimage = image_a.first()\n", "functions": ["Map.centerObject", "Map.addLayer"], "external_vars": ["image", "Map", "image_vis_params"], "defined_vars": [], "parameters": ["image", "image", "image_vis_params", "Sentinel-2"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add the Indonesia outline to the map.\nMap.addLayer(image2, {'palette': '000000', 'opacity': 0.5}, \"Indonesia\")\n", "task": "Add a layer to the map called \"Indonesia\" using the image2 variable. The layer should be black with an opacity of 0.5.  You will need to define the following variables: `image2`, `Map`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Load the Simplified and Detailed boundary datasets from LSIB.\nsimplified = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017')\n# Filter the countries to only include Indonesia.\nindonesia = simplified.filter(ee.Filter.eq('country_na', 'Indonesia'))\n# Filter the image collection by date, bounds, and cloud cover.\nimage = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA').filterDate('2016-01-01', '2016-12-31').filterBounds(\n    indonesia).filterMetadata('CLOUD_COVER', 'less_than', 30).median().clip(indonesia)\n# Create a blank image to accept the polygon outlines.\nimage1 = ee.Image(0).mask(0)\n# Outline Indonesia using the specified color and width.\nimage2 = image1.paint(indonesia, 'ff00ff', 2)\n", "functions": ["Map.addLayer"], "external_vars": ["image2", "Map"], "defined_vars": [], "parameters": ["image2", "Indonesia", "{'palette': '000000', 'opacity': 0.5}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add NDVI and EVI to the filtered image collection.\nndvi1 = filtered.map(add_ndvi).map(add_evi)\n", "task": "Define a new variable `ndvi1` by applying the `add_ndvi` function to each element of the `filtered` list, then applying the `add_evi` function to each element of the resulting list.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Load the Sentinel-2 SR image collection.\nS2 = ee.ImageCollection('COPERNICUS/S2_SR')\n# Load the FAO/GAUL/2015/level1 admin1 feature collection.\nadmin1 = ee.FeatureCollection('FAO/GAUL/2015/level1')\n# Filter the admin1 feature collection to get Karnataka.\nkarnataka = admin1.filter(ee.Filter.eq('ADM1_NAME', 'Karnataka'))\n# Get the geometry of Karnataka.\ngeometry = karnataka.geometry()\n# Filter the S2 image collection by date and cloud cover.\nfiltered = S2.filterDate('2020-01-01', '2020-12-31').filter(\n    ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 30)).filterBounds(geometry)\n# Define a function to add NDVI to an image.\n\n\ndef add_ndvi(image):\n    ndvi = image.normalizedDifference(['B8', 'B4']).rename('NDVI')\n    return image.addBands(ndvi)\n# Define a function to add EVI to an image.\n\n\ndef add_evi(image):\n    evi = image.expression('2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))', {'NIR': image.select('B8').multiply(\n        0.0001), 'RED': image.select('B4').multiply(0.0001), 'BLUE': image.select('B2').multiply(0.0001)}).rename('EVI')\n    return image.addBands(evi)\n", "functions": ["unknown_function.map", "filtered.map"], "external_vars": ["add_evi", "filtered", "add_ndvi"], "defined_vars": ["ndvi1"], "parameters": ["add_evi", "add_ndvi"], "libraries": ["import ee", "import geemap"]}
{"code": "Map.addLayer(sm_masked.clip(roi),{},'sm_masked',False)\n\n\n", "task": "Add a layer to the Map object named \"sm_masked\" using the clipped `sm_masked` GeoDataFrame to the `roi` bounding box. Make the layer visible by default.  You will need to define the following variables: `roi`, `sm_masked`, and `Map`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [[47.808901137191114, 31.621192173639276], [49.259096449691114, 31.621192173639276], [49.259096449691114,\n                                                                                            32.70003070644645], [47.808901137191114, 32.70003070644645], [47.808901137191114, 31.621192173639276]]\nroi = ee.Geometry.Polygon(cor)\n# landsat collection data\nlandsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterBounds(roi).filterDate('2020', '2022').filter(\n    ee.Filter.lt('CLOUD_COVER', 10)).filter(ee.Filter.eq('WRS_PATH', 165)).filter(ee.Filter.eq('WRS_ROW', 38))\n\n\ndef func_(img):\n    ms = img.select('SR_B.*').multiply(2.75e-05).add(-0.2)\n    ndvi = ms.normalizedDifference(['SR_B5', 'SR_B4']).rename('ndvi')\n    lst = img.select('ST_B10').multiply(0.00341802).add(149).rename('lst')\n    return ee.Image.cat(ndvi, lst).copyProperties(img, img.propertyNames())\n\n\nparameters = landsat.map(func_)\n\n\ndef func2_(img):\n    ndvi_full = img.select('ndvi').gt(0.3)\n    lst_full = img.select('lst').updateMask(ndvi_full)\n    return lst_full.copyProperties(img, img.propertyNames())\n\n\nlst_full_cover = parameters.map(func2_)\n\n\ndef func3_(img):\n    ndvi_bareland = img.select('ndvi').gte(0) and img.select('ndvi').lt(0.2)\n    lst_bareland = img.select('lst').updateMask(ndvi_bareland)\n    return lst_bareland.copyProperties(img, img.propertyNames())\n\n\nlst_bareland = parameters.map(func3_)\nvw = ee.Number(lst_full_cover.min().reduceRegion(\n    reducer=ee.Reducer.min(), geometry=roi, scale=100).values().get(0))\nvd = ee.Number(lst_full_cover.max().reduceRegion(\n    reducer=ee.Reducer.max(), geometry=roi, scale=100).values().get(0))\niw = ee.Number(lst_bareland.min().reduceRegion(\n    reducer=ee.Reducer.min(), geometry=roi, scale=100).values().get(0))\nid = ee.Number(lst_bareland.max().reduceRegion(\n    reducer=ee.Reducer.max(), geometry=roi, scale=100).values().get(0))\nsd = id.subtract(vd)\nsw = iw.subtract(vw)\n\n\ndef func4_(img):\n    eq = img.expression('(id + sd * ndvi - lst)/(id - iw + (sd - sw) * ndvi)', {'id': id, 'sd': sd, 'ndvi': img.select(\n        'ndvi'), 'lst': img.select('lst'), 'iw': iw, 'sw': sw}).rename('soil_moisture')\n    return eq.copyProperties(img, img.propertyNames())\n\n\nsm = parameters.map(func4_)\nlc = ee.ImageCollection(\n    'GOOGLE/DYNAMICWORLD/V1').select('label').filterBounds(roi).mode()\nmask = lc.eq(0) or lc.eq(6)\nsm_masked = sm.toBands().updateMask(mask)\n", "functions": ["Map.addLayer", "sm_masked.clip"], "external_vars": ["roi", "Map", "sm_masked"], "defined_vars": [], "parameters": ["sm_masked", false, "roi", "sm_masked.clip(roi)", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "diff_thresholded = diff_smoothed.lt(DIFF_UPPER_THRESHOLD)\n", "task": "Create a boolean tensor named `diff_thresholded` that indicates where the values in the tensor `diff_smoothed` are less than the threshold value `DIFF_UPPER_THRESHOLD`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Default location\ncor = [[-123.45801418605573, 38.81836572068789], [-122.44589870754011, 38.81836572068789], [-122.44589870754011,\n                                                                                            39.64593638831554], [-123.45801418605573, 39.64593638831554], [-123.45801418605573, 38.81836572068789]]\npt = ee.Geometry.Polygon(cor)\n# Load Sentinel-1 C-band SAR Ground Range collection (log scaling, VV co-polar)\ncollection = ee.ImageCollection('COPERNICUS/S1_GRD').filterBounds(pt).filter(\n    ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')).select('VV')\n# Filter by date\nbefore = collection.filterDate('2015-03-01', '2015-07-24').mosaic()\nafter = collection.filterDate('2015-07-25', '2015-12-2').mosaic()\n# Threshold smoothed radar intensities to identify \"flooded\" areas.\nSMOOTHING_RADIUS = 100\nDIFF_UPPER_THRESHOLD = -3\ndiff_smoothed = after.focal_median(SMOOTHING_RADIUS, 'circle', 'meters').subtract(\n    before.focal_median(SMOOTHING_RADIUS, 'circle', 'meters'))\n", "functions": ["diff_smoothed.lt"], "external_vars": ["DIFF_UPPER_THRESHOLD", "diff_smoothed"], "defined_vars": ["diff_thresholded"], "parameters": ["DIFF_UPPER_THRESHOLD"], "libraries": ["import geemap", "import ee"]}
{"code": "# Identify areas where built-up probability increased from before to after.\nnew_builtup = builtup_before.lt(0.25).And(builtup_after.gt(0.60))\nnew_builtup = new_builtup.updateMask(new_builtup)\n", "task": "Define a new variable named `new_builtup` that represents areas where `builtup_before` is less than 0.25 and `builtup_after` is greater than 0.6. Then, update the mask of `new_builtup` with itself.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the geometry of interest.\ngeometry = ee.Geometry.Polygon([[[74.19727747386207, 31.595662076288036], [74.19727747386207, 31.38370182587256], [\n                               74.49116175120582, 31.38370182587256], [74.49116175120582, 31.595662076288036]]])\n# Filter the Dynamic World collection by date and bounds.\ndw_before_coll = ee.ImageCollection(\n    'GOOGLE/DYNAMICWORLD/V1').filterDate('2019-03-01', '2019-04-01').filterBounds(geometry)\ndw_after_coll = ee.ImageCollection(\n    'GOOGLE/DYNAMICWORLD/V1').filterDate('2022-03-01', '2022-04-01').filterBounds(geometry)\ndw_before = dw_before_coll.mosaic().clip(geometry)\ndw_after = dw_after_coll.mosaic().clip(geometry)\n# Extract the built-up probability bands.\nbuiltup_before = dw_before.select('built')\nbuiltup_after = dw_after.select('built')\n", "functions": ["builtup_before.lt", "builtup_after.gt", "new_builtup.updateMask"], "external_vars": ["builtup_before", "builtup_after"], "defined_vars": ["new_builtup"], "parameters": [0.25, 0.6, "new_builtup"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the Landsat 8 collection.And filter it by bounds, cloud cover,.And date.\nl8collection = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR') .filterBounds(Bound_geom) .filterMetadata('CLOUD_COVER', 'less_than', 1.5) .filterDate('2020-01-01', '2020-12-31')\n", "task": "Using the Earth Engine library (`ee`) and a geometry object (`Bound_geom`), create a collection of Landsat 8 imagery (`l8collection`) for the year 2020, filtering by cloud cover less than 1.5%.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the boundary of the area of interest.\nBound_geom = ee.Geometry.Polygon([[-93.11310959151902, 18.112334929829487], [-93.11310959151902, 17.86416393364247],\n                                 [-92.74781418136277, 17.86416393364247], [-92.74781418136277, 18.112334929829487]])\n", "functions": ["unknown_function.filterDate", "unknown_function.filterMetadata", "unknown_function.filterBounds", "ee.ImageCollection"], "external_vars": ["ee", "Bound_geom"], "defined_vars": ["l8collection"], "parameters": ["2020-01-01", "2020-12-31", "CLOUD_COVER", "less_than", 1.5, "Bound_geom", "LANDSAT/LC08/C01/T1_SR"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the forest cover dataset\nforest = ee.Image(\"UMD/hansen/global_forest_change_2016_v1_4\")\n", "task": "Using the Earth Engine library (ee), load the global forest change dataset from 2016 into a variable called \"forest\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["forest"], "parameters": ["UMD/hansen/global_forest_change_2016_v1_4"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the geometry of the rectangular region of interest.\ngeometry = ee.Geometry.Polygon([\n    [11.478446455436142, 46.08039843345605],\n    [11.478446455436142, 45.8101593677626],\n    [11.954978437858017, 45.8101593677626],\n    [11.954978437858017, 46.08039843345605]\n])\n", "task": "Define a variable named `geometry` using the `ee.Geometry.Polygon` function to create a polygon with the following coordinates: [[11.478446455436142, 46.08039843345605], [11.478446455436142, 45.8101593677626], [11.954978437858017, 45.8101593677626], [11.954978437858017, 46.08039843345605]]", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee"], "defined_vars": ["geometry"], "parameters": ["[[11.478446455436142, 46.08039843345605], [11.478446455436142, 45.8101593677626], [11.954978437858017, 45.8101593677626], [11.954978437858017, 46.08039843345605]]"], "libraries": ["import ee", "import geemap"]}
{"code": "Map.centerObject(roi)\nMap.addLayer(roi)\n", "task": "Center the map on the region of interest (ROI) and add the ROI as a layer to the map. You need to define the variables `roi` and `Map` before executing this code.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor1 = [-121.30739155546495, 37.83353662375529]\ngeometry = ee.Geometry.Point(cor1)\ntable = ee.FeatureCollection('FAO/GAUL/2015/level1')\nroi = table.filterBounds(geometry).map(lambda feature: feature.simplify(10000))\n", "functions": ["Map.centerObject", "Map.addLayer"], "external_vars": ["roi", "Map"], "defined_vars": [], "parameters": ["roi", "roi"], "libraries": ["import ee", "import geemap"]}
{"code": "# Load the SRTM.And Global Surface Water (GSW) images\nsrtm = ee.Image(\"CGIAR/SRTM90_V4\")\nwater = ee.Image(\"JRC/GSW1_0/GlobalSurfaceWater\")\n", "task": "Using the ee module, define two variables: \"srtm\" representing the SRTM 90m elevation data, and \"water\" representing the Global Surface Water dataset. ", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Image", "ee.Image"], "external_vars": ["ee"], "defined_vars": ["water", "srtm"], "parameters": ["CGIAR/SRTM90_V4", "JRC/GSW1_0/GlobalSurfaceWater"], "libraries": ["import geemap", "import ee"]}
{"code": "roi = ee.Geometry.Point(cor)\n", "task": "Define a variable named `roi` that represents a point geometry using the `ee.Geometry.Point()` function and the coordinates stored in the variable `cor`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\ncor = [45.953922269937266, 36.92715318092904]\n", "functions": ["ee.Geometry.Point"], "external_vars": ["ee", "cor"], "defined_vars": ["roi"], "parameters": ["cor"], "libraries": ["import geemap", "import ee"]}
{"code": "# Compute multi-band difference between the 2008-2012 composite and the\n# previously loaded 1999-2003 composite\ndiff = landsat2008.subtract(landsat1999)\nvisParams = {'bands': ['B4', 'B3', 'B2'], 'min': -32, 'max': 32}\nMap.addLayer(diff, visParams, 'Landsat Difference 2008-2012 - 1999-2003')\n", "task": "Calculate the difference between the Landsat images from 2008 and 1999, using the `subtract` method. Define a variable named `diff` to store the result. Define a variable named `visParams` that specifies the visualization parameters. Add the calculated difference to the Map using the `addLayer` method, specifying the difference (`diff`), the visualization parameters (`visParams`), and the layer name \"Landsat Difference 2008-2012 - 1999-2003\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Load a 5-year Landsat 7 composite 1999-2003\nlandsat1999 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\n# Load a 5-year Landsat 7 composite 2008-2012\nlandsat2008 = ee.Image('LANDSAT/LE7_TOA_5YEAR/2008_2012')\n", "functions": ["landsat2008.subtract", "Map.addLayer"], "external_vars": ["landsat1999", "Map", "landsat2008"], "defined_vars": ["visParams", "diff"], "parameters": ["landsat1999", "diff", "visParams", "Landsat Difference 2008-2012 - 1999-2003"], "libraries": ["import ee", "import geemap"]}
{"code": "#Green Normalized Difference Vegetation Index (GNDVI)\nGNDVI = LandClip.normalizedDifference(['B5','B3']).rename('GNDVI')\nMap.addLayer(GNDVI,{min:-0.2, max: 1, 'palette':Palette}, 'GNDVI')\n", "task": "Calculate the Green Normalized Difference Vegetation Index (GNDVI) using the bands B5 and B3 from the `LandClip` object. Rename the result to `GNDVI`. Then, add the `GNDVI` layer to the `Map` object using the provided `Palette` and setting the minimum and maximum values to `-0.2` and `1` respectively.  This code assumes the variables `Palette`, `min`, `max`, `Map`, and `LandClip` are defined in the current scope. Define the variable `GNDVI` within the code.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ngeometry = ee.FeatureCollection([ee.Feature(ee.Geometry.Polygon([[[-68.68248825810653, -32.11042261459242], [-68.15789109013778, -\n                                32.11972783756108], [-68.14965134404403, -31.365289858898606], [-68.67974167607528, -31.365289858898606]]]), {'system:index': '0'})])\n# Eesto nos permite ordenar la colección completa de Landsat 8 y cargar la mejor imagen disponible para nuestra región de interés\nlandsat8Collection = ee.ImageCollection(\n    'LANDSAT/LC08/C02/T1_TOA').filterBounds(geometry).filterDate('2022-01-01', '2022-12-31')\nLandmediana = ee.Image(landsat8Collection.median())\nLandClip = Landmediana.clip(geometry)\n# Simbologia comun para los indices\nPalette = ['FFFFFF', 'CE7E45', 'DF923D', 'F1B555', 'FCD163', '99B718', '74A901', '66A000',\n           '529400', '3E8601', '207401', '056201', '004C00', '023B01', '012E01', '011D01', '011301']\n", "functions": ["unknown_function.rename", "LandClip.normalizedDifference", "Map.addLayer"], "external_vars": ["Map", "min", "max", "Palette", "LandClip"], "defined_vars": ["GNDVI"], "parameters": ["GNDVI", "GNDVI", "GNDVI", "['B5', 'B3']", "{min: -0.2, max: 1, 'palette': Palette}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the median NDVI to the map\nMap.addLayer(median_ndvi, ndviviz, 'Median NDVI')\n\n\n", "task": "Add the `median_ndvi` layer to the `Map` using the visualization parameters defined in `ndviviz` and label the layer \"Median NDVI\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\nSelangor = ee.FeatureCollection(\n    'FAO/GAUL/2015/level1').filter(ee.Filter.eq('ADM1_NAME', 'Selangor'))\n# Get Landsat8 collection and filter it as in previous lab\nFiltered = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterBounds(\n    Selangor).filterDate('2020-06-01', '2020-12-31').sort('CLOUD_COVER')\n# Writing function to calculate, rename and add NDVI to an image\n\n\ndef add_ndvi(image):\n    ndvi = image.normalizedDifference(['SR_B5', 'SR_B4'])\n    ndvi = ndvi.rename('NDVI')\n    return image.addBands(ndvi)\n\n\n# Add to the map (select NDVI to visualize) and inspect\nndviviz = {'bands': ['NDVI'], 'min': -1, 'max': 1,\n           'palette': ['blue', 'white', 'green']}\n# Calculate and add NDVI for every single image in the filtered collection (Filtered)\nCollectionwithNDVI = Filtered.map(add_ndvi)\n# Make a median NDVI\nmedian_ndvi = CollectionwithNDVI.median()\n", "functions": ["Map.addLayer"], "external_vars": ["median_ndvi", "Map", "ndviviz"], "defined_vars": [], "parameters": ["median_ndvi", "ndviviz", "Median NDVI"], "libraries": ["import geemap", "import ee"]}
{"code": "# Exporting vector data\n# Make a collection of points\nfeatures = ee.FeatureCollection([\n  ee.Feature(ee.Geometry.Point(-8.00, 12.64), {\"name\": \"Bamako\"}),\n  ee.Feature(ee.Geometry.Point(2.13, 13.53), {\"name\": \"Niamey\"})\n])\n\n\n", "task": "Using the ee library, create a FeatureCollection named \"features\" containing two points: one at coordinates (-8.0, 12.64) named \"Bamako\" and another at coordinates (2.13, 13.53) named \"Niamey\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Create a MultiPoint geometry\ngeometry = ee.Geometry.MultiPoint()\n", "functions": ["ee.FeatureCollection", "ee.Feature", "ee.Geometry.Point", "ee.Feature", "ee.Geometry.Point"], "external_vars": ["ee"], "defined_vars": ["features"], "parameters": [12.64, 2.13, 13.53, "[ee.Feature(ee.Geometry.Point(-8.0, 12.64), {'name': 'Bamako'}), ee.Feature(ee.Geometry.Point(2.13, 13.53), {'name': 'Niamey'})]", "ee.Geometry.Point(-8.0, 12.64)", "{'name': 'Bamako'}", "-8.0", "ee.Geometry.Point(2.13, 13.53)", "{'name': 'Niamey'}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the Hansen Global Forest Change dataset.\nhansen_gfc = ee.Image(\"UMD/hansen/global_forest_change_2021_v1_9\")\n", "task": "Using the ee library, define a variable named `hansen_gfc` and assign it the Earth Engine image \"UMD/hansen/global_forest_change_2021_v1_9\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["hansen_gfc"], "parameters": ["UMD/hansen/global_forest_change_2021_v1_9"], "libraries": ["import geemap", "import ee"]}
{"code": "# Filter the dataset to select Tehran\nTehran = admin2.filter(ee.Filter.eq('ADM1_NAME', 'Tehran'))\n", "task": "Using the provided variables `admin2` and `ee`, filter the `admin2` dataset to select all features where the `ADM1_NAME` field is equal to \"Tehran\". Assign the resulting filtered dataset to a variable named `Tehran`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Load the FAO/GAUL_SIMPLIFIED_500m/2015/level2 dataset\nadmin2 = ee.FeatureCollection('FAO/GAUL_SIMPLIFIED_500m/2015/level2')\n", "functions": ["admin2.filter", "ee.Filter.eq"], "external_vars": ["ee", "admin2"], "defined_vars": ["Tehran"], "parameters": ["ADM1_NAME", "Tehran", "ee.Filter.eq('ADM1_NAME', 'Tehran')"], "libraries": ["import ee", "import geemap"]}
{"code": "# Filter the feature collection to select areas greater than 500,000 hectares\nsel_adm2 = areaAdded.filter(ee.Filter.gt('areaHa', 500000))\nprint(sel_adm2)\nprint('Number of selected features:', sel_adm2.size())\n", "task": "Using the `areaAdded` variable and the `ee.Filter.gt` function from the `ee` module, filter the features to select only those with an area greater than 500,000 hectares. Store the resulting filtered features in a variable called `sel_adm2`.  Then, print the selected features and the number of features in `sel_adm2`. You can use the `print` function to display the results.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Load the Malaysia administrative boundaries\nAdm_Malaysia = ee.FeatureCollection(\n    'users/rudiyanto/Workshop_INOS/gadm41_MYS_2')\n# Define a function to calculate the area of each feature in hectares\n\n\ndef addArea(feature):\n    area_ha = feature.geometry().area().divide(100 * 100)\n    return feature.set({'areaHa': area_ha})\n\n\n# Apply the function to the feature collection\nareaAdded = Adm_Malaysia.map(addArea)\n", "functions": ["areaAdded.filter", "ee.Filter.gt", "print", "print", "sel_adm2.size"], "external_vars": ["ee", "areaAdded", "print"], "defined_vars": ["sel_adm2"], "parameters": ["areaHa", 500000, "sel_adm2", "Number of selected features:", "ee.Filter.gt('areaHa', 500000)", "sel_adm2.size()"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add clipped image layer to the map.\nMap.addLayer(clippedLSTc, {\n  min: 20, max: 40,\n  'palette': ['blue', 'limegreen', 'yellow', 'darkorange', 'red']},\n  'Mean temperature, 2015')\n\n\n", "task": "Add a layer to the map named \"Mean temperature, 2015\" using the clippedLSTc data, with a color palette ranging from blue to red based on temperature values between the min and max values. Define the following variables: clippedLSTc (the clipped LST data), min (minimum temperature value), max (maximum temperature value), and Map (the map object).", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Import country boundaries feature collection.\ndataset = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017')\n# Apply filter where country name equals Uganda.\nSwazilandBorder = dataset.filter(ee.Filter.eq('country_na', 'Swaziland'))\n# Import LST image collection.\nmodis = ee.ImageCollection('MODIS/MOD11A2')\n# Define a date range of interest; here, a start date is defined and the end date is determined by advancing 1 year from the start date.\nstart = ee.Date('2015-01-01')\ndateRange = ee.DateRange(start, start.advance(1, 'year'))\n# Filter the LST collection to include only images intersecting the desired date range.\nmod11a2 = modis.filterDate(dateRange)\n# Select only the 1km day LST data band.\nmodLSTday = mod11a2.select('LST_Day_1km')\n# Scale to Kelvin and convert to Celsius, set image acquisition time.\nmodLSTc = modLSTday.map(lambda img: img.multiply(0.02).subtract(\n    273.15).copyProperties(img, ['system:time_start']))\n# Calculate 8-day mean temperature for Uganda in 2015.\nclippedLSTc = modLSTc.mean().clip(SwazilandBorder)\n", "functions": ["Map.addLayer"], "external_vars": ["clippedLSTc", "Map", "max", "min"], "defined_vars": [], "parameters": ["clippedLSTc", "Mean temperature, 2015", "{min: 20, max: 40, 'palette': ['blue', 'limegreen', 'yellow', 'darkorange', 'red']}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add the NDWI layer to the map.\nMap.addLayer(ndwi, {'min': -0.5, 'max': 1, 'palette': water_palette}, 'NDWI')\n\n\n", "task": "Add the normalized difference water index (NDWI) layer to the map, setting the minimum and maximum values for visualization to -0.5 and 1 respectively, using the `water_palette` for color representation. Label the layer as \"NDWI\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the Landsat 8 collection.\nlandsat8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_SR')\n# Define the region of interest.\ngeometry = ee.Geometry.Point([119.41792340169773, -5.133052890077648])\n# Filter the collection by date and region.\nimage = ee.Image(landsat8.filterDate(\n    '2019-01-01', '2019-12-31').filterBounds(geometry).sort('CLOUD_COVER').first())\n# 4. Calculate NDWI using the normalizedDifference function.\nndwi = image.normalizedDifference(['B5', 'B3'])\n# Define the visualization parameters for water bodies.\nwater_palette = ['white', 'blue']\n", "functions": ["Map.addLayer"], "external_vars": ["water_palette", "ndwi", "Map"], "defined_vars": [], "parameters": ["ndwi", "NDWI", "{'min': -0.5, 'max': 1, 'palette': water_palette}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the Sentinel-2 image collection.\nSentinel = ee.ImageCollection('COPERNICUS/S2') .filterDate('2022-01-01', '2022-05-30') .filterBounds(geometry)\n", "task": "Using the Earth Engine library (ee) and a user-defined geometry, create an ImageCollection named \"Sentinel\" containing Sentinel-2 imagery from the specified date range. The date range is from January 1, 2022 to May 30, 2022. Filter the collection to only include images that intersect the provided geometry.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the geometry of the area of interest.\ngeometry = ee.Geometry.Polygon([[-99.33029467326308, 19.51822325062694], [-99.33029467326308, 19.207276008218127],\n                               [-98.78097826701308, 19.207276008218127], [-98.78097826701308, 19.51822325062694]])\n", "functions": ["unknown_function.filterBounds", "unknown_function.filterDate", "ee.ImageCollection"], "external_vars": ["geometry", "ee"], "defined_vars": ["Sentinel"], "parameters": ["geometry", "2022-01-01", "2022-05-30", "COPERNICUS/S2"], "libraries": ["import geemap", "import ee"]}
{"code": "Map.addLayer(era1970.select('skin_temperature').first().clip(geometry), {min: 259 , max: 283}, 'original', False)  \nMap.addLayer(era1970.select('predicted').first().clip(geometry), {min: 260 , max: 290}, 'predicted', False)  \n", "task": "Add two layers to the map: the first layer should be the \"skin_temperature\" band of the era1970 dataset clipped to the geometry, with a minimum value of min and a maximum value of max. The second layer should be the \"predicted\" band of the era1970 dataset clipped to the geometry, with a minimum value of min and a maximum value of max.  The first layer should be named \"original\" and the second layer should be named \"predicted\". Both layers should be added to the map without being visible by default. **[Define the variables era1970, Map, min, geometry, max]**", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ncor = [[43.75779800247099, 32.06441993671384], [54.04100112747099, 32.06441993671384], [54.04100112747099,\n                                                                                        40.061675939018706], [43.75779800247099, 40.061675939018706], [43.75779800247099, 32.06441993671384]]\ngeometry = ee.Geometry.Polygon(cor)\ntime_start = '2010'\ntime_end = '2020'\nera = ee.ImageCollection('ECMWF/ERA5_LAND/DAILY_AGGR').select(\n    'skin_temperature').filterDate(time_start, time_end)\nmod = ee.ImageCollection(\n    'MODIS/061/MOD11A1').select('LST_Day_1km').filterDate(time_start, time_end)\njoin = ee.Join.inner()\nfilter = ee.Filter.equals(leftField='system:time_start',\n                          rightField='system:time_start')\njoin_collection = ee.ImageCollection(join.apply(era, mod, filter))\n\n\ndef func_(img):\n    era_img = ee.Image(img.get('primary'))\n    era_resample = era_img.resample().reproject(crs='EPSG:4326', scale=1000)\n    mod_img = ee.Image(img.get('secondary')).multiply(0.02)\n    cons = ee.Image.constant(1)\n    stack = ee.Image.cat([era_resample, cons, mod_img])\n    return stack\n\n\ncollection = join_collection.map(func_)\nmodel = collection.reduce(ee.Reducer.linearRegression(2, 1))\ngain = model.select('coefficients').arrayGet([0, 0])\noffset = model.select('coefficients').arrayGet([1, 0])\n\n\ndef func2_(img):\n    resampled = img.resample().reproject(crs='EPSG:4326', scale=1000)\n    predicted = resampled.multiply(gain).add(offset).rename('predicted')\n    return resampled.addBands(predicted).copyProperties(img, img.propertyNames())\n\n\nera1970 = ee.ImageCollection('ECMWF/ERA5_LAND/DAILY_AGGR').select(\n    'skin_temperature').filterDate('1970', '1971').map(func2_)\n", "functions": ["Map.addLayer", "unknown_function.clip", "unknown_function.first", "era1970.select", "Map.addLayer", "unknown_function.clip", "unknown_function.first", "era1970.select"], "external_vars": ["max", "geometry", "Map", "era1970", "min"], "defined_vars": [], "parameters": ["original", false, "geometry", "skin_temperature", "predicted", false, "geometry", "predicted", "era1970.select('skin_temperature').first().clip(geometry)", "{min: 259, max: 283}", "era1970.select('predicted').first().clip(geometry)", "{min: 260, max: 290}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the Landsat 8 collection.\nlandsat8 = ee.ImageCollection(\"LANDSAT/LC8_L1T_TOA_FMASK\")\n", "task": "Using the Earth Engine library (ee), define a variable named `landsat8` that represents the Landsat 8 Collection 1 Tier 1 TOA Reflectance with FMASK data. ", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["landsat8"], "parameters": ["LANDSAT/LC8_L1T_TOA_FMASK"], "libraries": ["import ee", "import geemap"]}
{"code": "# Map the CDOM calculation function over the S3 collection\ns3_cdom_collection = s3_collection.map(s3_cdom)\n\nprint(s3_cdom_collection)\n", "task": "Define a new variable called `s3_cdom_collection` by mapping the `s3_cdom` function over the `s3_collection` and then print the resulting collection.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ngeometry = ee.Geometry.Polygon([[-0.9527927646050638, 37.84070343595422], [-0.9527927646050638, 37.59519620216126],\n                               [-0.6506687411675638, 37.59519620216126], [-0.6506687411675638, 37.84070343595422]])\n# Load the Sentinel-3 OLCI collection\ns3_collection = ee.ImageCollection(\n    'COPERNICUS/S3/OLCI').filterDate('2018-02-01', '2018-04-04').filterBounds(geometry)\n# Define the expression for calculating CDOM from S3\nexp_cdom_s3 = '(Oa08_radiance * 0.00876539) / (Oa04_radiance * 0.0115198)'\n# Function to calculate CDOM from S3 image\n\n\ndef s3_cdom(image):\n    cdom_s3 = image.expression(exp_cdom_s3, {'Oa04_radiance': image.select(\n        'Oa04_radiance'), 'Oa08_radiance': image.select('Oa08_radiance')}).rename('CDOM_Sentinel3')\n    return cdom_s3\n", "functions": ["s3_collection.map", "print"], "external_vars": ["s3_collection", "s3_cdom", "print"], "defined_vars": ["s3_cdom_collection"], "parameters": ["s3_cdom", "s3_cdom_collection"], "libraries": ["import geemap", "import ee"]}
{"code": "# Center the map on the specified coordinates.\nMap.setCenter(-71.08807, -32.9418, 12)\n", "task": "Set the center of the map to the coordinates (-71.08807, -32.9418) and zoom level 12. You will need to define the following variable before running this code:  `Map`.", "exec_path": "GEE", "context": "import geemap\nMap = geemap.Map()\n", "functions": ["Map.setCenter"], "external_vars": ["Map"], "defined_vars": [], "parameters": [12, "-71.08807", "-32.9418"], "libraries": ["import geemap"]}
{"code": "# Center the map on the Lahore district.\nMap.centerObject(lahoreDistrict, 10)\n", "task": "Center the object representing Lahore District on the map, zooming in by a factor of 10. You will need to define the variables \"lahoreDistrict\" and \"Map\" before executing this instruction.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Load the Global Administrative Unit Layers (GAUL) dataset level 2.\ngaul = ee.FeatureCollection('FAO/GAUL/2015/level2')\n# Filter the GAUL dataset to get the boundary of Lahore district.\nlahoreDistrict = gaul.filter(ee.Filter.eq('ADM2_NAME', 'Lahore District'))\n", "functions": ["Map.centerObject"], "external_vars": ["Map", "lahoreDistrict"], "defined_vars": [], "parameters": ["lahoreDistrict", 10], "libraries": ["import ee", "import geemap"]}
{"code": "Map.centerObject(roi)\nMap.addLayer(roi)\n", "task": "Center the map on the region of interest (`roi`) and add it as a layer to the map (`Map`).  Make sure to define the `roi` and `Map` variables before running this code.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [[51.09050885517992, 35.57496936569026], [51.58214703877367, 35.57496936569026], [51.58214703877367,\n                                                                                        35.85149920592443], [51.09050885517992, 35.85149920592443], [51.09050885517992, 35.57496936569026]]\ngeometry = ee.Geometry.Polygon(cor)\ntable = ee.FeatureCollection('FAO/GAUL/2015/level1')\nroi = table.filterBounds(geometry).map(lambda feature: feature.simplify(500))\n", "functions": ["Map.centerObject", "Map.addLayer"], "external_vars": ["roi", "Map"], "defined_vars": [], "parameters": ["roi", "roi"], "libraries": ["import ee", "import geemap"]}
{"code": "# filter collection by date.And clip output\nprecip = CHIRPS.filterDate(StartDate, EndDate).map(clipR)\n", "task": "Filter the CHIRPS dataset between the StartDate and EndDate, then apply the clipR function to each element in the filtered dataset and store the result in the variable \"precip\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\nMY = ee.FeatureCollection(\n    'FAO/GAUL/2015/level0').filter(ee.Filter.eq('ADM0_NAME', 'Malaysia'))\n# Set starting and ending date\nStartDate = ee.Date('2019-01-01')\nEndDate = ee.Date('2020-01-01')\n# Select Image Collection of daily precipitation\nCHIRPS = ee.ImageCollection('UCSB-CHG/CHIRPS/DAILY')\n# Function to clip collection\n\n\ndef clipR(image):\n    return image.clip(MY)\n", "functions": ["unknown_function.map", "CHIRPS.filterDate"], "external_vars": ["CHIRPS", "StartDate", "clipR", "EndDate"], "defined_vars": ["precip"], "parameters": ["clipR", "StartDate", "EndDate"], "libraries": ["import geemap", "import ee"]}
{"code": "# Create a grid of points for sampling the image.\nfeatures = geometry.coveringGrid('EPSG:4326', 250)\n", "task": "Using the `geometry` object, create a covering grid with a resolution of 250 meters in the EPSG:4326 coordinate system. Assign the resulting grid features to the variable `features`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Set the region of interest.\ngeometry = ee.Geometry.Point([-122.4194, 37.7749])\n", "functions": ["geometry.coveringGrid"], "external_vars": ["geometry"], "defined_vars": ["features"], "parameters": ["EPSG:4326", 250], "libraries": ["import geemap", "import ee"]}
{"code": "# Define a variable for the median of the second half of 2020.\nmedian = secondHalf2020.median()\n", "task": "Calculate the median of the data in the DataFrame `secondHalf2020` and store it in the variable `median`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define a variable for the Landsat 8 collection.\nlandsat8 = ee.ImageCollection('LANDSAT/LC08/C02/T1')\n# Define a variable for the second half of 2020.\nsecondHalf2020 = landsat8.filterDate('2020-06-01', '2020-12-31')\n", "functions": ["secondHalf2020.median"], "external_vars": ["secondHalf2020"], "defined_vars": ["median"], "parameters": [], "libraries": ["import geemap", "import ee"]}
{"code": "# Create a Feature with the geometry and properties\nfeature = ee.Feature(geometry, {'name': 'First Class', 'location': 'henan'})\n", "task": "Create a new Earth Engine Feature named \"feature\" using the provided geometry. The feature should have properties \"name\" set to \"First Class\" and \"location\" set to \"henan\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nfrom ee.ee_exception import EEException\n# Create a list of points and create a MultiPoint geometry\npoints = [[114.474, 35.699], [114.217, 35.555], [114.835, 35.224],\n          [114.058, 35.029], [114.169, 33.766], [114.52, 34.942]]\ngeometry = ee.Geometry.MultiPoint(points)\n", "functions": ["ee.Feature"], "external_vars": ["ee", "geometry"], "defined_vars": ["feature"], "parameters": ["geometry", "{'name': 'First Class', 'location': 'henan'}"], "libraries": ["import ee", "from ee.ee_exception import EEException", "import geemap"]}
{"code": "# Define the LANDSAT 8 collection\nL8 = ee.ImageCollection(\"LANDSAT/LC08/C01/T1_TOA\")\n", "task": "Using the Earth Engine library (ee), load the Landsat 8 Collection 1 Tier 1 TOA data and assign it to the variable L8.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["L8"], "parameters": ["LANDSAT/LC08/C01/T1_TOA"], "libraries": ["import geemap", "import ee"]}
{"code": "# Filter the collection by date.And geometry.\nsentinel2TOA_filtered = sentinel2TOA.filterDate('2021-01-01', '2021-05-03').filterBounds(point)\n", "task": "Filter the Sentinel-2 TOA data (`sentinel2TOA`) for dates between 2021-01-01 and 2021-05-03 and within the bounds defined by the point (`point`). Store the filtered data in a new variable called `sentinel2TOA_filtered`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the point and area geometries.\npoint = ee.Geometry.Point([-4.3000244499904445, 11.172195759531249])\n# Define the Sentinel-2 Top-of-Atmosphere collection.\nsentinel2TOA = ee.ImageCollection('COPERNICUS/S2')\n", "functions": ["unknown_function.filterBounds", "sentinel2TOA.filterDate"], "external_vars": ["point", "sentinel2TOA"], "defined_vars": ["sentinel2TOA_filtered"], "parameters": ["point", "2021-01-01", "2021-05-03"], "libraries": ["import geemap", "import ee"]}
{"code": "# Get the coordinate reference system (CRS) of the projection.\ncrs = proj.crs()\n", "task": "Get the coordinate reference system (CRS) of the provided `proj` object and assign it to the variable `crs`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# This dataset contains Sentinel-1 Ground Range Detected (GRD) products.\ndataset = ee.ImageCollection('COPERNICUS/S1_GRD')\n# Define the coordinates of the area of interest (AOI).\ncoordinates = [[70.58174517005682, 21.913531643276908], [70.58163318783045, 21.913926678518507], [70.58154467493296, 21.913990443946926], [70.58152589946985, 21.914201958334374], [70.58133646845818, 21.91434286406814], [\n    70.58040037751198, 21.91404176731981], [70.5802297219634, 21.91382278746666], [70.58051940053701, 21.913245164278514], [70.58068636804819, 21.913180776411302], [70.58174517005682, 21.913531643276908]]\n# Create a geometry object from the coordinates.\nAOI = ee.Geometry.Polygon(coordinates)\n# Filter the dataset by the AOI and date range.\ns1 = dataset.filterBounds(AOI).filterDate('2022-06-01', '2022-06-15')\n# Get the first image from the filtered collection.\nimage = s1.first()\n# Get the projection of the image.\nproj = image.projection()\n", "functions": ["proj.crs"], "external_vars": ["proj"], "defined_vars": ["crs"], "parameters": [], "libraries": ["import geemap", "import ee"]}
{"code": "# Display the result\nvis_params = {'bands': ['B4', 'B3', 'B2'], 'max': 0.3}\nMap.addLayer(greenest_2, vis_params, 'Second Greenest pixel composite')\nMap.addLayer(greenest_2.select('NDVI_squared'), ndvi_params, 'NDVI squared image')\n\n\n", "task": "Define a visualization parameters dictionary called `vis_params` with bands `['B4', 'B3', 'B2']` and a maximum value of `0.3`. Then, add the `greenest_2` image to the `Map` using `vis_params` and label it \"Second Greenest pixel composite\". Finally, add the `NDVI_squared` band from the `greenest_2` image to the `Map` using `ndvi_params` and label it \"NDVI squared image\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# ee.Geometry.Point() function as demonstrated here.\npoint = ee.Geometry.Point([-41.4329728109325, -12.57788396003372])\n# Import the Landsat 8 TOA image collection.\nl8 = ee.ImageCollection('LANDSAT/LC08/C02/T1')\n# Get the least cloudy image in 2015\nimage = l8.filterBounds(point).filterDate(\n    '2015-01-01', '2015-12-31').sort('CLOUD_COVER').first()\nndvi_params = {'min': -1, 'max': 1, 'palette': ['blue', 'white', 'green']}\n\n\ndef add_ndvi_squared(image):\n    ndvi = image.normalizedDifference(['B5', 'B4'])\n    ndvi_squared = ndvi.multiply(ndvi).rename('NDVI_squared')\n    return image.addBands(ndvi_squared)\n\n\nwith_ndvi_squared = l8.map(add_ndvi_squared)\ngreenest_2 = with_ndvi_squared.qualityMosaic('NDVI_squared')\n", "functions": ["Map.addLayer", "Map.addLayer", "greenest_2.select"], "external_vars": ["Map", "ndvi_params", "greenest_2"], "defined_vars": ["vis_params"], "parameters": ["greenest_2", "vis_params", "Second Greenest pixel composite", "ndvi_params", "NDVI squared image", "NDVI_squared", "greenest_2.select('NDVI_squared')"], "libraries": ["import ee", "import geemap"]}
{"code": "#Aquesta funció afegeix una banda temporal a la imatge\ndef variació_temporal(img):\n    any = ee.Date(img.get(\"system:time_start\")).get(\"year\").subtract(1991)\n    return ee.Image(any).byte().addBands(img)\n", "task": "Using the ee library, define a function called `variació_temporal` that takes an image object `img` as input. Inside the function, calculate the difference in years between the image acquisition year and 1991, storing this value in a variable named `any`. Finally, convert `any` to a byte image and add it as a band to the original image `img`, returning the resulting multi-band image.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["unknown_function.subtract", "unknown_function.get", "ee.Date", "img.get", "unknown_function.addBands", "unknown_function.byte", "ee.Image"], "external_vars": ["ee"], "defined_vars": ["any", "img"], "parameters": [1991, "year", "system:time_start", "img", "any", "img.get('system:time_start')"], "libraries": ["import geemap", "import ee"]}
{"code": "# Print the elevation of Mount Everest.\ndem = ee.Image('USGS/SRTMGL1_003')\n", "task": "Using the Earth Engine library (ee), load the SRTMGL1_003 dataset and assign it to the variable `dem`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["dem"], "parameters": ["USGS/SRTMGL1_003"], "libraries": ["import ee", "import geemap"]}
{"code": "# This dataset contains Sentinel-1 Ground Range Detected (GRD) products.\ndataset = ee.ImageCollection(\"COPERNICUS/S1_GRD\")\n", "task": "Using the Earth Engine library (ee), load the Sentinel-1 Ground Range (GRD) image collection and assign it to the variable `dataset`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["dataset"], "parameters": ["COPERNICUS/S1_GRD"], "libraries": ["import geemap", "import ee"]}
{"code": "#Step 04: Get a list of the years of NAIP imagery for region \n#add year property to each image\ndef addYear(image):\n    imageYear = image.date().get('year')\n    bandNames = image.bandNames().length()\n    return image.set({'year':imageYear, 'bands':bandNames})\n", "task": "Define a function called `addYear` that takes an image object as input. The function should extract the year from the image's date and the number of bands from the image's band names. Then, update the image object by setting its `year` attribute to the extracted year and its `bands` attribute to the number of bands.  Return the updated image object. Ensure the following variables are defined: `image`, `imageYear`, `bandNames`.", "exec_path": "GEE", "context": "", "functions": ["unknown_function.get", "image.date", "unknown_function.length", "image.bandNames", "image.set"], "external_vars": [], "defined_vars": ["bandNames", "imageYear", "image"], "parameters": ["year", "{'year': imageYear, 'bands': bandNames}"], "libraries": []}
{"code": "# ALOS PALSAR DEM.\nalos = ee.Image(\"JAXA/ALOS/AW3D30/V2_2\")\n", "task": "Import the ee module and define a variable called \"alos\" to represent the ALOS AW3D30 V2_2 image from the JAXA dataset.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["alos"], "parameters": ["JAXA/ALOS/AW3D30/V2_2"], "libraries": ["import geemap", "import ee"]}
{"code": "def urban_layer(img):\n    urban_thr = img.eq(13)\n    urban_mask = urban_thr.updateMask(urban_thr)\n    urban_vector = urban_mask.reduceToVectors(\n    geometry=roi, scale=500\n    ).union(1)\n    return urban_vector\nurban_class = urban_layer(lc)\n\n\n", "task": "Define the variables `urban_mask`, `img`, `urban_class`, `urban_vector`, and `urban_thr`. Then, using the `urban_layer` function, create a variable called `urban_class` by passing the `lc` variable as an argument to the function. The `urban_layer` function takes an image `img` as input, determines urban areas by filtering pixels with a value of 13, creates a mask from the filtered pixels, converts the mask to a vector using the `roi` geometry and a scale of 500, and returns the vector.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\ncor = [[51.72646131195613, 35.78622502387334], [54.07753553070613, 35.78622502387334], [54.07753553070613,\n                                                                                        36.97144246810686], [51.72646131195613, 36.97144246810686], [51.72646131195613, 35.78622502387334]]\nroi = ee.Geometry.Polygon(cor)\nlc = ee.ImageCollection('MODIS/061/MCD12Q1').mode().select('LC_Type1')\n", "functions": ["img.eq", "urban_thr.updateMask", "unknown_function.union", "urban_mask.reduceToVectors", "urban_layer"], "external_vars": ["roi", "lc", "urban_layer"], "defined_vars": ["urban_thr", "urban_class", "urban_mask", "urban_vector", "img"], "parameters": [13, "urban_thr", 1, "lc"], "libraries": ["import ee", "import geemap"]}
{"code": "# Filter the image collection by location, date,.And metadata\nfilteredL8 = l8.filterBounds(delhi) .filterDate(\"2020-01-01\", \"2020-12-31\") .filterMetadata(\"CLOUD_COVER\", \"less_than\", 10)\n", "task": "Filter the Landsat 8 data (`l8`) to only include data within the bounds of `delhi`, collected between January 1st and December 31st, 2020, and with a cloud cover less than 10%. Store the resulting filtered data in the variable `filteredL8`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Import an uploaded feature collection\ndelhi = ee.FeatureCollection('users/geonextgis/Delhi_New')\n# Import the Landsat 8 image collection\nl8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n", "functions": ["unknown_function.filterMetadata", "unknown_function.filterDate", "l8.filterBounds"], "external_vars": ["delhi", "l8"], "defined_vars": ["filteredL8"], "parameters": ["CLOUD_COVER", "less_than", 10, "2020-01-01", "2020-12-31", "delhi"], "libraries": ["import geemap", "import ee"]}
{"code": "# Create a feature collection containing the buffered geometries.\ntwoCities = ee.FeatureCollection([bufferedYangon, bufferedBago])\n", "task": "Create a new feature collection named `twoCities` that combines the buffered geometries of `bufferedYangon` and `bufferedBago`. Use the `ee.FeatureCollection` function.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the point geometries for Yangon and Bago.\nyangon = ee.Feature(ee.Geometry.Point([96.1916595987808, 16.834921962155644]), {\n                    'cityName': 'Yangon', 'system:index': '0'})\nbago = ee.Feature(ee.Geometry.Point([96.4608246377835, 17.32408073236987]), {\n                  'cityName': 'Bago', 'system:index': '0'})\n# Buffer the point geometries by 30km.\nbufferedYangon = yangon.buffer(30000)\nbufferedBago = bago.buffer(30000)\n", "functions": ["ee.FeatureCollection"], "external_vars": ["ee", "bufferedYangon", "bufferedBago"], "defined_vars": ["twoCities"], "parameters": ["[bufferedYangon, bufferedBago]"], "libraries": ["import geemap", "import ee"]}
{"code": "# Center the map on a point.And set the zoom level\nMap.setCenter(115.856, -31.95, 12)\n\n\n", "task": "Set the center of the map to the coordinates (115.856, -31.95) and zoom to level 12. **Note:** This instruction assumes the variable `Map` has been defined and is a valid map object.", "exec_path": "GEE", "context": "import geemap\nMap = geemap.Map()\n", "functions": ["Map.setCenter"], "external_vars": ["Map"], "defined_vars": [], "parameters": [115.856, 12, "-31.95"], "libraries": ["import geemap"]}
{"code": "# Add the unioned buffered polygons to the map\nMap.addLayer(buffered_polys_union)\n\n\n", "task": "Add the union of buffered polygons, represented by the variable `buffered_polys_union`, as a layer to the map object `Map`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the input polygons\npolygons = ee.FeatureCollection(\n    'users/englishr18/AlleghenyCounty_Footprints201805')\n# Define a function to buffer the polygons\n\n\ndef buffer_poly(feature):\n    \"\"\"\n  Buffer a polygon by a given distance.\n\n  Args:\n    feature: The feature to buffer.\n    distance: The distance to buffer the feature by.\n\n  Returns:\n    The feature with the buffer added as a property.\n  \"\"\"\n    return feature.buffer(152.4)\n\n\n# Map the buffer_poly function over the polygons\nbuffered_polys = polygons.map(buffer_poly)\n# Union the buffered polygons\nbuffered_polys_union = buffered_polys.union()\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "buffered_polys_union"], "defined_vars": [], "parameters": ["buffered_polys_union"], "libraries": ["import geemap", "import ee"]}
{"code": "# Convert the SRTM elevation from meters to feet.\nsrtm_WA_Feet = srtm_WA.multiply(3.2808399)\n", "task": "Convert the SRTM elevation data for Western Australia (stored in the variable `srtm_WA`) from meters to feet and store the result in a new variable called `srtm_WA_Feet`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the SRTM elevation dataset.\nsrtm = ee.Image('USGS/SRTMGL1_003')\n# Load the West Africa boundary shapefile.\nWest_Africa = ee.FeatureCollection('users/Kwame/WestAfrica/WestAfrica_Outline')\n# Clip the SRTM elevation dataset to the West Africa boundary.\nsrtm_WA = srtm.clip(West_Africa)\n", "functions": ["srtm_WA.multiply"], "external_vars": ["srtm_WA"], "defined_vars": ["srtm_WA_Feet"], "parameters": [3.2808399], "libraries": ["import geemap", "import ee"]}
{"code": "# Create an empty image to paint the features onto.\nempty = ee.Image().byte()\n", "task": "Define an empty Earth Engine image and cast it to byte type. You will need to define the variable `empty` using the `ee` module.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["unknown_function.byte", "ee.Image"], "external_vars": ["ee"], "defined_vars": ["empty"], "parameters": [], "libraries": ["import ee", "import geemap"]}
{"code": "# Specify the Sentinel-2 SR dataset\ndataset = ee.ImageCollection(\"COPERNICUS/S2_SR\")\n", "task": "Using the Earth Engine library (ee), load the Sentinel-2 Surface Reflectance (SR) image collection and assign it to the variable `dataset`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["dataset"], "parameters": ["COPERNICUS/S2_SR"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the drainage direction.And flow accumulation layers to the map.\nMap.addLayer(drainage, {'min': 0, 'max': 255}, 'drainage direction')\nMap.addLayer(flow_accumulation, {'min': 0, 'max': 2.78651e+07}, 'flow accumulation')\n", "task": "Add the `drainage` and `flow_accumulation` layers to the `Map` object. Set the min and max values for the `drainage` layer to 0 and 255, respectively, and label it \"drainage direction\". Set the min and max values for the `flow_accumulation` layer to 0 and 27865100.0, respectively, and label it \"flow accumulation\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the region of interest (AOI).\nAOI = ee.Geometry.Polygon([[[3.616162109374992, 11.61537540662609], [3.616162109374992, 8.56553473569282], [\n                          6.373730468749992, 8.56553473569282], [6.373730468749992, 11.61537540662609]]])\n# Import the drainage direction and flow accumulation data sets.\ndrainage = ee.Image('WWF/HydroSHEDS/03DIR').clip(AOI)\nflow_accumulation = ee.Image('WWF/HydroSHEDS/15ACC').clip(AOI)\n", "functions": ["Map.addLayer", "Map.addLayer"], "external_vars": ["Map", "flow_accumulation", "drainage"], "defined_vars": [], "parameters": ["drainage", "drainage direction", "flow_accumulation", "flow accumulation", "{'min': 0, 'max': 255}", "{'min': 0, 'max': 27865100.0}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the states feature collection and filter to Colorado\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\ncolorado = states.filter(ee.Filter.eq(\"NAME\", \"Colorado\"))\nMap.centerObject(colorado, 7)\n", "task": "Using the Earth Engine library (`ee`) and the Google Earth Engine map (`Map`),  define a variable called `states` as a FeatureCollection representing US states from the TIGER/2018 dataset. Then, define a variable called `colorado` representing the state of Colorado by filtering `states` based on the \"NAME\" property. Finally, center the map on `colorado` with a zoom level of 7.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n", "functions": ["ee.FeatureCollection", "states.filter", "ee.Filter.eq", "Map.centerObject"], "external_vars": ["ee", "Map"], "defined_vars": ["colorado", "states"], "parameters": ["TIGER/2018/States", "NAME", "Colorado", "colorado", 7, "ee.Filter.eq('NAME', 'Colorado')"], "libraries": ["import ee", "import geemap"]}
{"code": "# Sum the geartype bands to get total effort across geartypes\neffort_all_2016 = effort_2016.reduce(ee.Reducer.sum())\n", "task": "Define a variable named `effort_all_2016` that represents the sum of all values in the `effort_2016` variable using the `ee.Reducer.sum()` method from the `ee` library.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Fishing effort, measured in hours of inferred fishing activity.\ngfw = ee.ImageCollection('GFW/GFF/V1/fishing_hours')\n# Filter by \"WLD\" to get all global fishing effort rasters in 2016\neffort_all = gfw.filterMetadata(\n    'country', 'equals', 'WLD').filterDate('2016-01-01', '2017-01-01')\n# Aggregate 2016 collection to single image of global fishing effort\neffort_2016 = effort_all.sum()\n", "functions": ["effort_2016.reduce", "ee.Reducer.sum"], "external_vars": ["effort_2016", "ee"], "defined_vars": ["effort_all_2016"], "parameters": ["ee.Reducer.sum()"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add.And inspect min/max: 0-30000\nMap.addLayer(rgb_renamed, {'bands': ['Red', 'Green', 'Blue'], 'min': 0, 'max': 30000}, 'RGB Image with Renamed Bands')\n", "task": "Add a new layer to the map named \"RGB Image with Renamed Bands\" using the image `rgb_renamed`. Set the bands to `[\"Red\", \"Green\", \"Blue\"]` and the color scale range from 0 to 30000. **Make sure to define the following variables before running this code**: `Map`, `rgb_renamed`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\nSelangor = ee.FeatureCollection(\n    'FAO/GAUL/2015/level1').filter(ee.Filter.eq('ADM1_NAME', 'Selangor'))\n# Get Landsat8 collection and filter it as in previous lab\nFiltered = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterBounds(\n    Selangor).filterDate('2020-06-01', '2020-12-31').sort('CLOUD_COVER')\n# Composite median\nCompositeMedian = Filtered.median()\n# Specify the RGB bands names and put them into a list\nbands = ['B5', 'B4', 'B3']\n# Select RGB image using the list of name\nrgb = CompositeMedian.select(bands)\n# Change band name using select\nnew_names = ['Red', 'Green', 'Blue']\n# Use select with two inputs to change the band names\nrgb_renamed = rgb.select(bands, new_names)\n", "functions": ["Map.addLayer"], "external_vars": ["rgb_renamed", "Map"], "defined_vars": [], "parameters": ["rgb_renamed", "RGB Image with Renamed Bands", "{'bands': ['Red', 'Green', 'Blue'], 'min': 0, 'max': 30000}"], "libraries": ["import geemap", "import ee"]}
{"code": "def func2_(img):\n    ndvi_full = img.select('ndvi').gt(0.3)\n    lst_full = img.select('lst').updateMask(ndvi_full)\n    return lst_full.copyProperties(img, img.propertyNames())\n\nlst_full_cover = parameters.map(func2_)\n\ndef func3_(img):\n    ndvi_bareland = img.select('ndvi').gte(0) and (img.select('ndvi').lt(0.2))\n    lst_bareland = img.select('lst').updateMask(ndvi_bareland)\n    return lst_bareland.copyProperties(img, img.propertyNames())\n\nlst_bareland = parameters.map(func3_)\n\nvw = ee.Number(lst_full_cover.min().reduceRegion(\n  reducer=ee.Reducer.min(), geometry=roi, scale=100\n  ).values().get(0))\n\nvd = ee.Number(lst_full_cover.max().reduceRegion(\n  reducer=ee.Reducer.max(), geometry=roi, scale=100\n  ).values().get(0))\n\niw = ee.Number(lst_bareland.min().reduceRegion(\n  reducer=ee.Reducer.min(), geometry=roi, scale=100\n  ).values().get(0))\n\nid = ee.Number(lst_bareland.max().reduceRegion(\n  reducer=ee.Reducer.max(), geometry=roi, scale=100\n  ).values().get(0))\n\nsd = id.subtract(vd)\nsw = iw.subtract(vw)\n", "task": "Using the external variables `ee`, `func3_`, `func2_`, `parameters`, and `roi`, define the variables `lst_full`, `ndvi_bareland`, `lst_bareland`, `ndvi_full`, `lst_full_cover`, `iw`, `sw`, `vd`, `vw`, `img`, `sd`, and `id` using the provided code.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [[47.808901137191114, 31.621192173639276], [49.259096449691114, 31.621192173639276], [49.259096449691114,\n                                                                                            32.70003070644645], [47.808901137191114, 32.70003070644645], [47.808901137191114, 31.621192173639276]]\nroi = ee.Geometry.Polygon(cor)\n# landsat collection data\nlandsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterBounds(roi).filterDate('2020', '2022').filter(\n    ee.Filter.lt('CLOUD_COVER', 10)).filter(ee.Filter.eq('WRS_PATH', 165)).filter(ee.Filter.eq('WRS_ROW', 38))\n\n\ndef func_(img):\n    ms = img.select('SR_B.*').multiply(2.75e-05).add(-0.2)\n    ndvi = ms.normalizedDifference(['SR_B5', 'SR_B4']).rename('ndvi')\n    lst = img.select('ST_B10').multiply(0.00341802).add(149).rename('lst')\n    return ee.Image.cat(ndvi, lst).copyProperties(img, img.propertyNames())\n\n\nparameters = landsat.map(func_)\n", "functions": ["unknown_function.gt", "img.select", "unknown_function.updateMask", "img.select", "lst_full.copyProperties", "img.propertyNames", "parameters.map", "unknown_function.gte", "img.select", "unknown_function.lt", "img.select", "unknown_function.updateMask", "img.select", "lst_bareland.copyProperties", "img.propertyNames", "parameters.map", "ee.Number", "unknown_function.get", "unknown_function.values", "unknown_function.reduceRegion", "lst_full_cover.min", "ee.Reducer.min", "ee.Number", "unknown_function.get", "unknown_function.values", "unknown_function.reduceRegion", "lst_full_cover.max", "ee.Reducer.max", "ee.Number", "unknown_function.get", "unknown_function.values", "unknown_function.reduceRegion", "lst_bareland.min", "ee.Reducer.min", "ee.Number", "unknown_function.get", "unknown_function.values", "unknown_function.reduceRegion", "lst_bareland.max", "ee.Reducer.max", "id.subtract", "iw.subtract"], "external_vars": ["ee", "roi", "func3_", "func2_", "parameters"], "defined_vars": ["lst_full", "sw", "ndvi_full", "vw", "id", "iw", "vd", "ndvi_bareland", "lst_bareland", "sd", "lst_full_cover", "img"], "parameters": [0.3, "ndvi", "ndvi_full", "lst", "img", "func2_", 0, "ndvi", 0.2, "ndvi", "ndvi_bareland", "lst", "img", "func3_", 0, 0, 0, 0, "vd", "vw", "img.propertyNames()", "img.propertyNames()", "lst_full_cover.min().reduceRegion(reducer=ee.Reducer.min(), geometry=roi, scale=100).values().get(0)", "lst_full_cover.max().reduceRegion(reducer=ee.Reducer.max(), geometry=roi, scale=100).values().get(0)", "lst_bareland.min().reduceRegion(reducer=ee.Reducer.min(), geometry=roi, scale=100).values().get(0)", "lst_bareland.max().reduceRegion(reducer=ee.Reducer.max(), geometry=roi, scale=100).values().get(0)"], "libraries": ["import ee", "import geemap"]}
{"code": "#Step 01 : Import NAIP imagery\n#Step 02: Import addison_county\nnaip = ee.ImageCollection(\"USDA/NAIP/DOQQ\")\ngeometry = ee.FeatureCollection(\"users/geogenvs150/VERMONT/addison_county\")\nlandforms = ee.Image(\"CSP/ERGo/1_0/US/landforms\")\n", "task": "Using the ee library, define the following variables:\\n\\n* **naip**: An ImageCollection from the USDA/NAIP/DOQQ dataset\\n* **geometry**: A FeatureCollection representing the Addison County, Vermont region from the `users/geogenvs150/VERMONT` folder\\n* **landforms**: An Image representing US landforms from the CSP/ERGo/1_0/US dataset", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection", "ee.FeatureCollection", "ee.Image"], "external_vars": ["ee"], "defined_vars": ["landforms", "geometry", "naip"], "parameters": ["USDA/NAIP/DOQQ", "users/geogenvs150/VERMONT/addison_county", "CSP/ERGo/1_0/US/landforms"], "libraries": ["import geemap", "import ee"]}
{"code": "# Center the map and set zoom level.\nMap.setCenter(-115.0, 53.5, 6) # Alberta, Canada\n", "task": "Using the Map object, set the center of the map to the coordinates (-115.0, 53.5) and zoom to level 6.  Make sure to define the following variables before running this code:  []", "exec_path": "GEE", "context": "import geemap\nMap = geemap.Map()\n", "functions": ["Map.setCenter"], "external_vars": ["Map"], "defined_vars": [], "parameters": [53.5, 6, "-115.0"], "libraries": ["import geemap"]}
{"code": "# Display NBR on the map\nMap.addLayer(nbr, nbr_vis_params, \"NBR\")\n", "task": "Add the layer `nbr` to the map `Map` using the visualization parameters `nbr_vis_params` and name it \"NBR\". Make sure to define the variables `Map`, `nbr_vis_params`, and `nbr` before executing this instruction.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the Sentinel-2 image collection\nimage_collection = ee.ImageCollection('COPERNICUS/S2')\n# Define the geometry (point) of interest\ngeometry = ee.Geometry.Point([-116.96939553275278, 32.790786772668355])\n# Filter the Sentinel-2 image collection by date and geometry\nimage_a = image_collection.filterDate(\n    '2020-09-01', '2020-10-31').filterBounds(geometry).sort('CLOUD_COVERAGE_ASSESSMENT', True)\n# Get the first image from the filtered collection\nimage = image_a.first()\n# Define the visualization parameters for NBR\nnbr_vis_params = {'min': -0.2, 'max': 0.8, 'palette': ['white', 'green']}\n# Calculate NBR from the Sentinel-2 image\nnbr = image.normalizedDifference(['B8A', 'B12'])\n", "functions": ["Map.addLayer"], "external_vars": ["nbr_vis_params", "Map", "nbr"], "defined_vars": [], "parameters": ["nbr", "nbr_vis_params", "NBR"], "libraries": ["import ee", "import geemap"]}
{"code": "temp = ee.ImageCollection(\"MODIS/061/MOD11A1\").select('LST_.*').filterDate(time_start, time_end)\n", "task": "Using the Earth Engine library (`ee`), load the MODIS Land Surface Temperature (LST) data from the `MODIS/061/MOD11A1` collection for the period between `time_start` and `time_end`. Select the LST bands (those starting with \"LST_\") and store the resulting image collection in a variable named `temp`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\ntime_start = ee.Date('2023')\ntime_end = ee.Date('2024')\n", "functions": ["unknown_function.filterDate", "unknown_function.select", "ee.ImageCollection"], "external_vars": ["time_end", "ee", "time_start"], "defined_vars": ["temp"], "parameters": ["time_start", "time_end", "LST_.*", "MODIS/061/MOD11A1"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the region of interest\ngeometry = ee.Geometry.Point([59.61490461344121, 42.46221041587113])\n", "task": "Using the Earth Engine library (ee), define a variable named `geometry` as a point with the coordinates [59.61490461344121, 42.46221041587113].", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Geometry.Point"], "external_vars": ["ee"], "defined_vars": ["geometry"], "parameters": ["[59.61490461344121, 42.46221041587113]"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the kernel for morphological operations.\nthisKernel = ee.Kernel.square(radius=9, units=\"pixels\")\n", "task": "Define a variable called `thisKernel` using the `ee.Kernel.square()` function with a radius of 9 pixels. Make sure to specify the units as \"pixels\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Kernel.square"], "external_vars": ["ee"], "defined_vars": ["thisKernel"], "parameters": [], "libraries": ["import geemap", "import ee"]}
{"code": "# Add Thermal layer to the map\nMap.addLayer(composite, tempVis, \"Thermal\")\n", "task": "Add a layer to the map named \"Thermal\" using the `composite` layer as the source and `tempVis` as the visualization parameters. Make sure that `Map`, `tempVis`, and `composite` are defined.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the Landsat collection\nlandsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_RT_TOA')\n# Define the geometry (point) of interest\ngeometry = ee.Geometry.Point(88.35946443973363, 22.562462115407975)\n# Filter the Landsat collection by date range and geometry\nfiltered = landsat.filterDate(\n    '2022-01-01', '2023-03-01').filterBounds(geometry)\n# Create a composite from all filtered images by computing the median\ncomposite = filtered.median()\n# Visualization parameters for thermal band\ntempVis = {'bands': ['B10'], 'min': 280, 'max': 310,\n           'palette': ['blue', 'yellow', 'orange', 'red']}\n", "functions": ["Map.addLayer"], "external_vars": ["tempVis", "composite", "Map"], "defined_vars": [], "parameters": ["composite", "tempVis", "Thermal"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the slope data to the map\nMap.addLayer(slope, {'min': 0, 'max': 60}, 'slope')\n\n\n", "task": "Add the \"slope\" layer to the \"Map\" object, using a color ramp with a minimum value of 0 and a maximum value of 60, and label the layer \"slope\". **[You must define the \"slope\" and \"Map\" variables before executing this instruction]**", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the SRTM elevation data\nsrtm = ee.Image('CGIAR/SRTM90_V4')\n# Compute the slope of the terrain\nslope = ee.Terrain.slope(srtm)\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "slope"], "defined_vars": [], "parameters": ["slope", "slope", "{'min': 0, 'max': 60}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the Sentinel-5P CO data\nsentinel5 = ee.ImageCollection('COPERNICUS/S5P/NRTI/L3_CO') .select('CO_column_number_density') .filterDate(start_date, end_date) .filterBounds(thailand) .map(lambda image: image.clip(thailand))\n", "task": "Define a variable called `sentinel5` using the `ee.ImageCollection` function to access the Sentinel-5P data for carbon monoxide (CO) with the following steps:\\n\\n1. Specify the collection ID: \"COPERNICUS/S5P/NRTI/L3_CO\"\\n2. Select the band named \"CO_column_number_density\".\\n3. Filter the collection by date using the `start_date` and `end_date` variables.\\n4. Filter the collection by the `thailand` geometry.\\n5. Map over the filtered image collection, clipping each image to the `thailand` geometry using the `clip` method. The `image` variable is accessible within the `map` function.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Load the Thailand boundary data\nthailand = ee.FeatureCollection(\n    'FAO/GAUL/2015/level0').filter(ee.Filter.eq('ADM0_NAME', 'Thailand'))\n# Define the start and end dates for the Sentinel-5P data\nstart_date = '2019-10-01'\nend_date = '2023-04-05'\n", "functions": ["unknown_function.map", "unknown_function.filterBounds", "unknown_function.filterDate", "unknown_function.select", "ee.ImageCollection", "image.clip"], "external_vars": ["ee", "thailand", "image", "end_date", "start_date"], "defined_vars": ["sentinel5"], "parameters": ["thailand", "start_date", "end_date", "CO_column_number_density", "COPERNICUS/S5P/NRTI/L3_CO", "thailand", "lambda image: image.clip(thailand)"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add the benthic habitat classification to the map\nMap.addLayer(benthic_habitat, {}, \"Benthic habitat map\")\n", "task": "Add the benthic habitat layer to the map, named \"Benthic habitat map\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the dataset\ndataset = ee.Image('ACA/reef_habitat/v1_0')\n# Extract the benthic habitat classification from the dataset\nbenthic_habitat = dataset.select('benthic').selfMask()\n", "functions": ["Map.addLayer"], "external_vars": ["benthic_habitat", "Map"], "defined_vars": [], "parameters": ["benthic_habitat", "Benthic habitat map", "{}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Compute hillshade from SRTM elevation data\nhillshade = ee.Terrain.hillshade(srtm)\n", "task": "Using the Earth Engine library (ee), calculate the hillshade of the SRTM elevation data (srtm). Store the resulting hillshade data in a variable named hillshade.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the SRTM elevation dataset\nsrtm = ee.Image('USGS/SRTMGL1_003')\n", "functions": ["ee.Terrain.hillshade"], "external_vars": ["ee", "srtm"], "defined_vars": ["hillshade"], "parameters": ["srtm"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the ALOS AW3D30 dataset.\ndataset = ee.ImageCollection('JAXA/ALOS/AW3D30/V3_2')\nelevation = dataset.select('DSM')\n", "task": "Using the Earth Engine library (ee), load the JAXA/ALOS/AW3D30/V3_2 image collection and assign it to the variable \"dataset\". Then, select the \"DSM\" band from this dataset and assign it to the variable \"elevation\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection", "dataset.select"], "external_vars": ["ee"], "defined_vars": ["dataset", "elevation"], "parameters": ["JAXA/ALOS/AW3D30/V3_2", "DSM"], "libraries": ["import geemap", "import ee"]}
{"code": "roi = ee.Geometry.Polygon(cor)\n", "task": "Define a variable called `roi` and assign it the value of an Earth Engine polygon geometry constructed using the coordinates stored in the variable `cor`. Use the `ee.Geometry.Polygon()` function from the Earth Engine library.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\ncor = [[43.89239103939352, 35.313917425058115], [49.165828539393516, 35.313917425058115], [49.165828539393516,\n                                                                                           39.29702833107737], [43.89239103939352, 39.29702833107737], [43.89239103939352, 35.313917425058115]]\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["cor", "ee"], "defined_vars": ["roi"], "parameters": ["cor"], "libraries": ["import geemap", "import ee"]}
{"code": "# Display the region and point on the map\nMap.addLayer(region, {'color': 'yellow'}, \"Region\")\nMap.addLayer(point, {'color': '000000'}, \"CentrePoint\")\nMap.centerObject(point, 10)\n\n\n", "task": "Add a layer for the region in yellow and a layer for the point in black. Center the map on the point with a zoom level of 10. You will need to define the following variables: `region`, `point`, and `Map`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the region of interest as a point\npoint = ee.Geometry.Point([137.18066295505758, 36.84483839273])\n# Define the buffer region around the point\nregion = point.buffer(2300)\n", "functions": ["Map.addLayer", "Map.addLayer", "Map.centerObject"], "external_vars": ["Map", "region", "point"], "defined_vars": [], "parameters": ["region", "Region", "point", "CentrePoint", "point", 10, "{'color': 'yellow'}", "{'color': '000000'}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the SRTM image\nsrtm = ee.Image(\"USGS/SRTMGL1_003\")\n", "task": "Using the Earth Engine library (`ee`), import the SRTMGL1_003 dataset and assign it to the variable `srtm`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["srtm"], "parameters": ["USGS/SRTMGL1_003"], "libraries": ["import geemap", "import ee"]}
{"code": "# Filter the collection by date.\nfiltered = landsat8.filterDate('2019-09-01', '2019-09-15')\n", "task": "Filter the Landsat 8 dataset (`landsat8`) to include only images acquired between September 1st, 2019 and September 15th, 2019. Store the resulting filtered dataset in a variable named `filtered`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Define the Landsat 8 collection.\nlandsat8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n", "functions": ["landsat8.filterDate"], "external_vars": ["landsat8"], "defined_vars": ["filtered"], "parameters": ["2019-09-01", "2019-09-15"], "libraries": ["import ee", "import geemap"]}
{"code": "# Initialize the map.And display the point geometry.\nMap.centerObject(point, 8)\n", "task": "Center the object at the given point with a radius of 8. You will need to define the following variables: [Map, point].", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\npoint = ee.Geometry.Point([9.401940805000821, 40.36582831667849])\n", "functions": ["Map.centerObject"], "external_vars": ["point", "Map"], "defined_vars": [], "parameters": ["point", 8], "libraries": ["import geemap", "import ee"]}
{"code": "# Compute the slope of the SRTM image.\nslope = ee.Terrain.slope(srtm)\n", "task": "Using the Earth Engine library (`ee`) and an SRTM elevation dataset (`srtm`), calculate the slope and store it in a variable named `slope`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Define the SRTM image.\nsrtm = ee.Image('USGS/SRTMGL1_003')\n", "functions": ["ee.Terrain.slope"], "external_vars": ["ee", "srtm"], "defined_vars": ["slope"], "parameters": ["srtm"], "libraries": ["import ee", "import geemap"]}
{"code": "# Hydroshed\nbasins5 = ee.FeatureCollection(\"WWF/HydroSHEDS/v1/Basins/hybas_5\")\n", "task": "Using the Earth Engine library (ee), define a variable named `basins5` and assign it to the FeatureCollection representing the HydroSHEDS level 5 basins.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.FeatureCollection"], "external_vars": ["ee"], "defined_vars": ["basins5"], "parameters": ["WWF/HydroSHEDS/v1/Basins/hybas_5"], "libraries": ["import geemap", "import ee"]}
{"code": "# Use the normalizedDifference(A, B) to compute (A - B) / (A + B)\nndvi = img.normalizedDifference(['sur_refl_b02', 'sur_refl_b01'])\n", "task": "Calculate the Normalized Difference Vegetation Index (NDVI) using the provided image data (`img`).  Use the \"sur_refl_b02\" and \"sur_refl_b01\" bands for the calculation. Store the result in a variable named `ndvi`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Load a single MODIS image from 2012-03-09\nimg = ee.Image('MODIS/006/MOD09GA/2017_08_05')\n", "functions": ["img.normalizedDifference"], "external_vars": ["img"], "defined_vars": ["ndvi"], "parameters": ["['sur_refl_b02', 'sur_refl_b01']"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add the NDVI as a layer to the map.\nMap.addLayer(SentNDVI, {'palette': ['FF0000', 'FFFE00'], 'min': 0, 'max': 0.8}, 'Sent2NDVIstretched')\n", "task": "Add a layer to the map named \"Sent2NDVIstretched\" using the SentNDVI data. Use a color palette with red (FF0000) for the minimum value and yellow (FFFE00) for the maximum value. Set the minimum value to 0 and the maximum value to 0.8. You will need to define the following variables: `SentNDVI`, `Map`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the buffer geometry.\nbuffer = ee.Geometry.Polygon([[[-122.50940483747485, 37.644236681307106], [-122.39816826520922, 37.564814296553855], [-122.32675713239672, 37.56045993487149], [-122.0287529820061, 37.66054584536868],\n                             [-122.22238701520922, 37.91667147969052], [-122.34049004255297, 37.91233776572774], [-122.35422295270922, 37.84730142489402], [-122.55197685895922, 37.79740134848523]]])\n# Define the Sentinel-2 image collection.\nSent2 = ee.ImageCollection('COPERNICUS/S2').filterDate('2016-04-01',\n                                                       '2016-08-01').filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 5))\n# Calculate the NDVI from the median Sentinel-2 image.\nSentNDVI = Sent2.median().clip(buffer).normalizedDifference(['B8', 'B4'])\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "SentNDVI"], "defined_vars": [], "parameters": ["SentNDVI", "Sent2NDVIstretched", "{'palette': ['FF0000', 'FFFE00'], 'min': 0, 'max': 0.8}"], "libraries": ["import geemap", "import ee"]}
{"code": "lan4 = ee.ImageCollection(\"LANDSAT/LT04/C02/T1_L2\").select(['ST_B6'],['LST']).filterDate('1982','1994').filterBounds(roi).filter(ee.Filter.eq('WRS_PATH', 164)).filter(ee.Filter.eq('WRS_ROW', 35))\n", "task": "Using the Earth Engine library (ee), create an image collection named \"lan4\" from the Landsat 4 collection (\"LANDSAT/LT04/C02/T1_L2\"). Select the band \"ST_B6\" and rename it to \"LST\". Filter the collection by date between 1982 and 1994, within the provided region of interest (roi), and for WRS path 164 and row 35.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\ncor = [[51.02815260405151, 35.50852818710441], [51.69282545561401, 35.50852818710441], [51.69282545561401,\n                                                                                        35.8988380759623], [51.02815260405151, 35.8988380759623], [51.02815260405151, 35.50852818710441]]\nroi = ee.Geometry.Polygon(cor)\n", "functions": ["unknown_function.filter", "unknown_function.filter", "unknown_function.filterBounds", "unknown_function.filterDate", "unknown_function.select", "ee.ImageCollection", "ee.Filter.eq", "ee.Filter.eq"], "external_vars": ["ee", "roi"], "defined_vars": ["lan4"], "parameters": ["roi", "1982", "1994", "LANDSAT/LT04/C02/T1_L2", "WRS_PATH", 164, "WRS_ROW", 35, "ee.Filter.eq('WRS_ROW', 35)", "ee.Filter.eq('WRS_PATH', 164)", "['ST_B6']", "['LST']"], "libraries": ["import geemap", "import ee"]}
{"code": "# Import country boundaries feature collection.\ndataset = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017')\n", "task": "Using the Earth Engine library (ee), load the \"USDOS/LSIB_SIMPLE/2017\" dataset into a variable called `dataset`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.FeatureCollection"], "external_vars": ["ee"], "defined_vars": ["dataset"], "parameters": ["USDOS/LSIB_SIMPLE/2017"], "libraries": ["import ee", "import geemap"]}
{"code": "Map.addLayer(predicted_agb.clip(geometry), {}, 'predicted_agb', False)\n", "task": "Add the clipped predicted above-ground biomass (AGB) layer to the map. Clip the predicted AGB layer using the provided geometry. The layer should be named \"predicted_agb\" and should not be displayed by default. Make sure to define the following variables before running this code: `predicted_agb`, `Map`, and `geometry`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [[1.921468397822803, 52.382854413832085], [48.3277183978228, 52.382854413832085], [48.3277183978228,\n                                                                                         71.58428687506868], [1.921468397822803, 71.58428687506868], [1.921468397822803, 52.382854413832085]]\ngeometry = ee.Geometry.Polygon(cor)\nbiomass = ee.ImageCollection(\n    'NASA/ORNL/biomass_carbon_density/v1').select('agb').first().toInt()\ntime_start = '2010'\ntime_end = '2011'\nndvi = ee.ImageCollection('MODIS/061/MOD13Q1').select('NDVI', 'EVI').filterDate(time_start, time_end).filter(\n    ee.Filter.calendarRange(5, 9, 'month')).map(lambda img: img.multiply(0.0001).copyProperties(img, img.propertyNames())).median()\n\n\ndef func_(img):\n    lai = img.select('Lai_500m').multiply(0.1)\n    fpar = img.select('Fpar_500m').multiply(0.01)\n    return lai.addBands(fpar).copyProperties(img, img.propertyNames())\n\n\nlai = ee.ImageCollection('MODIS/061/MOD15A2H').select('Lai_500m', 'Fpar_500m').filterDate(\n    time_start, time_end).filter(ee.Filter.calendarRange(5, 9, 'month')).map(func_).median()\nlandcover = ee.ImageCollection('MODIS/061/MCD12Q1').select('LC_Type1').mode()\ndataset = ee.Image.cat([biomass, ndvi, lai, landcover])\ntraining = dataset.stratifiedSample(\n    numPoints=100, classBand='agb', region=geometry, scale=500)\nmodel = ee.Classifier.smileRandomForest(80).train(\n    features=training, classProperty='agb', inputProperties=dataset.bandNames()).setOutputMode('REGRESSION')\npredictors = dataset.bandNames().remove('agb')\npredicted_agb = dataset.select(predictors).classify(\n    model).rename('agb_predicted')\n", "functions": ["Map.addLayer", "predicted_agb.clip"], "external_vars": ["geometry", "predicted_agb", "Map"], "defined_vars": [], "parameters": ["predicted_agb", false, "geometry", "predicted_agb.clip(geometry)", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Make a \"greenest\" pixel composite.  This is a kind of reduction\n# in which the output is the pixel for which NDVI is maximized.\n# NDVI is passed to the qualityMosaic() finction as a 'qualityBand'\n# So that the composite is created with pixels with the highest NDVI value\ngreenest = withNDVI.qualityMosaic('NDVI')\n", "task": "Using the `withNDVI` object, define a new variable named `greenest` by applying the `qualityMosaic` method with the argument `'NDVI'`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\nL9 = ee.ImageCollection('LANDSAT/LC09/C02/T1_L2')\n# Define a function that will add an NDVI band to a Landsat 9 image.\n\n\ndef addNDVI(image):\n    ndvi = image.normalizedDifference(['SR_B5', 'SR_B4']).rename('NDVI')\n    return image.addBands(ndvi)\n\n\n# Filter and map the function over the L9 collection.\nwithNDVI = L9.filterDate('2022-01-01', '2023-02-28').map(addNDVI)\n", "functions": ["withNDVI.qualityMosaic"], "external_vars": ["withNDVI"], "defined_vars": ["greenest"], "parameters": ["NDVI"], "libraries": ["import ee", "import geemap"]}
{"code": "# Import Sentinel-1 imagery\nS1 = ee.ImageCollection('COPERNICUS/S1_GRD') .filterDate(startDate, endDate) .filterBounds(region) .select(['VV', 'VH']).map(lambda image: image.clip(region))\n", "task": "Define a variable named `S1` and assign it an Earth Engine ImageCollection of Sentinel-1 GRD data. Filter the collection by date using the `startDate` and `endDate` variables. Then filter the collection by bounds using the `region` variable. Select the `VV` and `VH` bands from the collection. Finally, clip each image in the collection to the `region` using the `image` variable.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the input parameters\nprov = 'ACEH'\nstartDate = '2022-01-01'\nendDate = '2022-12-31'\n# Filter the AOI based on the selected province\naoi = ee.FeatureCollection(\n    'users/yogadwiputra/Provinsi_Indonesia').filterMetadata('PROVINSI', 'equals', prov)\n# Define the region of interest based on the filtered AOI\nregion = aoi.geometry()\n", "functions": ["unknown_function.map", "unknown_function.select", "unknown_function.filterBounds", "unknown_function.filterDate", "ee.ImageCollection", "image.clip"], "external_vars": ["ee", "image", "startDate", "region", "endDate"], "defined_vars": ["S1"], "parameters": ["region", "startDate", "endDate", "COPERNICUS/S1_GRD", "region", "lambda image: image.clip(region)", "['VV', 'VH']"], "libraries": ["import ee", "import geemap"]}
{"code": "def func_(month):\n    asc_month = asc.filter(ee.Filter.calendarRange(month, month, 'month')).mean().rename('asc')\n    des_month = des.filter(ee.Filter.calendarRange(month, month, 'month')).mean().rename('des')\n    date = ee.Date.fromYMD(2020, month, 1)\n    return asc_month.addBands(des_month).set('system:time_start', date.millis()).set('system:index', date.format('YYYY-MM'))\n\nsen1_monthly = ee.ImageCollection(ee.List.sequence(1,12).map(func_))\n", "task": "Define the following variables: `des_month`, `date`, `month`, `asc_month`, and `sen1_monthly`. Use the provided variables `des`, `asc`, `ee`, and `func_` to create an ImageCollection named `sen1_monthly` that contains the monthly means of the `asc` and `des` datasets for each month of the year 2020.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [[48.42331357710716, 31.94100799817005], [48.75839658491966, 31.94100799817005], [48.75839658491966,\n                                                                                        32.18773294099697], [48.42331357710716, 32.18773294099697], [48.42331357710716, 31.94100799817005]]\ngeometry = ee.Geometry.Polygon(cor)\ntime_start = '2020'\ntime_end = '2021'\nsen1 = ee.ImageCollection('COPERNICUS/S1_GRD').filterDate(time_start, time_end).filterBounds(geometry).filter(\n    ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')).filter(ee.Filter.eq('instrumentMode', 'IW')).select('VV')\nasc = sen1.filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING'))\ndes = sen1.filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'))\n", "functions": ["unknown_function.rename", "unknown_function.mean", "asc.filter", "ee.Filter.calendarRange", "unknown_function.rename", "unknown_function.mean", "des.filter", "ee.Filter.calendarRange", "ee.Date.fromYMD", "unknown_function.set", "unknown_function.set", "asc_month.addBands", "date.millis", "date.format", "ee.ImageCollection", "unknown_function.map", "ee.List.sequence"], "external_vars": ["ee", "des", "asc", "func_"], "defined_vars": ["des_month", "asc_month", "sen1_monthly", "month", "date"], "parameters": ["asc", "month", "month", "month", "des", "month", "month", "month", 2020, "month", 1, "system:index", "system:time_start", "des_month", "YYYY-MM", "func_", 1, 12, "ee.Filter.calendarRange(month, month, 'month')", "ee.Filter.calendarRange(month, month, 'month')", "date.format('YYYY-MM')", "date.millis()", "ee.List.sequence(1, 12).map(func_)"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the geometry (Point)\ngeometry = ee.Geometry.Point([-2.026048565592131, 11.909898502781271])\n", "task": "Using the Earth Engine library (ee), define a variable named `geometry` as a point geometry with the coordinates [-2.026048565592131, 11.909898502781271].", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Geometry.Point"], "external_vars": ["ee"], "defined_vars": ["geometry"], "parameters": ["[-2.026048565592131, 11.909898502781271]"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the selected scene to the map as a layer\nMap.addLayer(scene.clip(table), {'bands': ['B6', 'B5', 'B3'], max: [0.3, 0.4, 0.3]}, 'Citra Satelit')\n\n\n", "task": "Add a layer to the Map, using the clipped scene based on the table. The layer should use bands B6, B5, and B3 with maximum values defined in the `max` list. Name the layer \"Citra Satelit\".\\n\\n**Required variables:**\\n- Map\\n- table\\n- scene\\n- max", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the feature collection that contains the location of interest\ntable = ee.FeatureCollection('users/laundrygis/hutanharapan')\n# Define the Landsat 8 collection to search for images\nl8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n# Filter the collection to only include images that intersect the region of interest\nspatial_filtered = l8.filterBounds(table)\n# Filter the collection to only include images acquired within a specified date range\ntemporal_filtered = spatial_filtered.filterDate('2016-01-01', '2020-5-30')\n# Sort the collection by cloud cover in ascending order\nsorted = temporal_filtered.sort('CLOUD_COVER')\n# Select the image with the least cloud cover\nscene = sorted.first()\n", "functions": ["Map.addLayer", "scene.clip"], "external_vars": ["Map", "table", "max", "scene"], "defined_vars": [], "parameters": ["Citra Satelit", "table", "scene.clip(table)", "{'bands': ['B6', 'B5', 'B3'], max: [0.3, 0.4, 0.3]}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Each asset in the collection is the effort for a given flag state.And day,\n# with one band for the fishing activity of each gear type.\n# Bands:\n# 0: \"drifting_longlines\"\n# 1: \"fixed_gear\"\n# 2: \"other_fishing\"\n# 3: \"purse_seines\"\n# 4: \"squid_jigger\"\n# 5: \"trawlers\"\n# Example 1: Global fishing effort in 2016\n# Filter by \"WLD\" to get all global fishing effort rasters in 2016\neffort_all = gfw.filterMetadata('country', 'equals', 'WLD').filterDate('2016-01-01', '2017-01-01')\n", "task": "Using the `gfw` object, filter the data to include only entries with `country` equal to \"WLD\" and date between \"2016-01-01\" and \"2017-01-01\". Assign the resulting filtered data to a new variable called `effort_all`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Fishing effort, measured in hours of inferred fishing activity.\ngfw = ee.ImageCollection('GFW/GFF/V1/fishing_hours')\n", "functions": ["unknown_function.filterDate", "gfw.filterMetadata"], "external_vars": ["gfw"], "defined_vars": ["effort_all"], "parameters": ["2016-01-01", "2017-01-01", "country", "equals", "WLD"], "libraries": ["import geemap", "import ee"]}
{"code": "#3. The default most recent composite isn't usually that interesting, below we have some code which for each pixel finds the maximum SIF value and returns a single image. Find the full range of values covered by this image by using the \"layers\" tab, selecting the small gear symbol by the layer name and under the range section changing the box which reads \"custom\" to \"stretch 100%\". Change the min and max in the visparams2 variable to match these.\nvisparms2 = {\n  min:0,\n  max:0,\n  'palette': [\"#000000\",\"#25CF22\"]\n}\nMap.addLayer(SIF.max(),visparms2,\"SIF Time Series Max\",False) #Change the false to true to see the image appear on the map, or tick the box on the layers tab\n", "task": "Define a variable called `visparms2` with the following parameters: `min` set to 0, `max` set to 0, and a `palette` with colors `#000000` and `#25CF22`. Then, add a layer to the `Map` using the maximum value of `SIF` with the defined `visparms2`, label it \"SIF Time Series Max\", and set it to be not visible initially.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\nSIF = ee.ImageCollection('users/MaxFancourt/updatedSIFTERID')\n", "functions": ["Map.addLayer", "SIF.max"], "external_vars": ["Map", "max", "SIF", "min"], "defined_vars": ["visparms2"], "parameters": ["visparms2", "SIF Time Series Max", false, "SIF.max()"], "libraries": ["import ee", "import geemap"]}
{"code": "#1.4 combine the yearly maps to one multi-band image \nnewimage = img_2015.addBands([img_2016,img_2017,img_2018,img_2019])\nprint(newimage,\"new water image\")\n", "task": "Define a new variable named \"newimage\" by adding the bands of images \"img_2016\", \"img_2017\", \"img_2018\", and \"img_2019\" to the image \"img_2015\". Then, use the \"print\" function to display the \"newimage\" along with the text \"new water image\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# 1.1 Load CGLS-LC100 yearly (2015-2019) maps\nCGLSCollection = ee.ImageCollection(\n    'COPERNICUS/Landcover/100m/Proba-V-C3/Global')\n# 1.2 Get the ID of each image object (element).\nimageList = CGLSCollection.toList(5)\n# /1.3 Obtain the yearly (2015-2019) discrecte land cover maps and rename\nimg_2015 = ee.Image(imageList.get(0)).select(\n    ['discrete_classification'], ['discrete_2015'])\nimg_2016 = ee.Image(imageList.get(1)).select(\n    ['discrete_classification'], ['discrete_2016'])\nimg_2017 = ee.Image(imageList.get(2)).select(\n    ['discrete_classification'], ['discrete_2017'])\nimg_2018 = ee.Image(imageList.get(3)).select(\n    ['discrete_classification'], ['discrete_2018'])\nimg_2019 = ee.Image(imageList.get(4)).select(\n    ['discrete_classification'], ['discrete_2019'])\n", "functions": ["img_2015.addBands", "print"], "external_vars": ["img_2015", "img_2018", "img_2017", "print", "img_2016", "img_2019"], "defined_vars": ["newimage"], "parameters": ["newimage", "new water image", "[img_2016, img_2017, img_2018, img_2019]"], "libraries": ["import geemap", "import ee"]}
{"code": "# Get the tree cover band from the GFC dataset.\ntree_cover = gfc2021_clip.select(['treecover2000'])\n", "task": "Using the variable `gfc2021_clip`, select the band named \"treecover2000\" and store the result in a new variable named `tree_cover`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the Global Forest Cover Hansen 2021 dataset.\ngfc2021 = ee.Image('UMD/hansen/global_forest_change_2021_v1_9')\n# Load a feature collection of Thailand.\nc = ee.FeatureCollection(\n    'USDOS/LSIB_SIMPLE/2017').filter(ee.Filter.eq('country_na', 'Thailand'))\n# Clip the GFC dataset to the boundary of Thailand.\ngfc2021_clip = gfc2021.clip(c)\n", "functions": ["gfc2021_clip.select"], "external_vars": ["gfc2021_clip"], "defined_vars": ["tree_cover"], "parameters": ["['treecover2000']"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the Landsat 8 Collection 2, Level-2 Top of Atmosphere Reflectance (TOA) image collection.\nlandsatCollection = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_L2\")\n", "task": "Using the Earth Engine library (ee), load the Landsat 8 Collection 2 Tier 1 Level 2 data into a variable called `landsatCollection`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["landsatCollection"], "parameters": ["LANDSAT/LC08/C02/T1_L2"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the SRTM data.And clip it to the region of interest.\nsrtm = ee.Image('USGS/SRTMGL1_003').clip(geometry)\n", "task": "Using the Earth Engine library (`ee`) and a previously defined geometry (`geometry`), clip the SRTMGL1_003 image to the geometry and assign it to the variable `srtm`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the geometry of the region of interest.\ngeometry = ee.Geometry.Polygon([[-60.83851061628087, -9.75333649767007], [-60.83851061628087, -26.550099707672082],\n                               [-26.385385616280928, -26.550099707672082], [-26.385385616280928, -9.75333649767007]])\n", "functions": ["unknown_function.clip", "ee.Image"], "external_vars": ["geometry", "ee"], "defined_vars": ["srtm"], "parameters": ["geometry", "USGS/SRTMGL1_003"], "libraries": ["import geemap", "import ee"]}
{"code": "# Select plots in South America \nplotsSA = plots.filterMetadata('Continent','equals', 'SA')\n# Select Biomass property only\nplotsSA = plotsSA.select('AGB')\nprint(plotsSA, 'plots in Amazon with only Biomass')\nMap.addLayer(plotsSA, {}, 'plots in South America')\n", "task": "Using the variable `plots`, filter the data to only include plots in South America and save it to a new variable `plotsSA`. Then, select the `AGB` column from `plotsSA`. Print the filtered data and add it as a layer to the `Map` object with the label \"plots in South America\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\nplots = ee.FeatureCollection(\n    'users/wangyxtina/ForestPlots/MartinSullivan2020Science_AllPlots')\n", "functions": ["plots.filterMetadata", "plotsSA.select", "print", "Map.addLayer"], "external_vars": ["plots", "print", "Map"], "defined_vars": ["plotsSA"], "parameters": ["Continent", "equals", "SA", "AGB", "plotsSA", "plots in Amazon with only Biomass", "plotsSA", "plots in South America", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Filter the s2 dataset to select only the images that are less than 30% cloudy,\n# that were acquired between 2019-01-01.And 2020-10-01,.And that intersect the geometry of Nairobi.\nfiltered = s2.filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 30)) .filter(ee.Filter.date('2019-01-01', '2020-10-01')) .filter(ee.Filter.bounds(geometry))\n", "task": "Using the Earth Engine library (`ee`), filter the Sentinel-2 collection (`s2`) to include only images with a cloudy pixel percentage less than 30%, taken between January 1, 2019 and October 1, 2020, and within the specified geometry (`geometry`). Store the filtered collection in the variable `filtered`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the admin2 and s2 datasets.\nadmin2 = ee.FeatureCollection('FAO/GAUL_SIMPLIFIED_500m/2015/level2')\ns2 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')\n# Filter the admin2 dataset to select only the features that represent Nairobi.\nnairobi = admin2.filter(ee.Filter.eq('ADM2_NAME', 'Nairobi'))\ngeometry = nairobi.geometry()\n", "functions": ["unknown_function.filter", "unknown_function.filter", "s2.filter", "ee.Filter.lt", "ee.Filter.date", "ee.Filter.bounds"], "external_vars": ["ee", "s2", "geometry"], "defined_vars": ["filtered"], "parameters": ["CLOUDY_PIXEL_PERCENTAGE", 30, "2019-01-01", "2020-10-01", "geometry", "ee.Filter.bounds(geometry)", "ee.Filter.date('2019-01-01', '2020-10-01')", "ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 30)"], "libraries": ["import geemap", "import ee"]}
{"code": "des = sen1.filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'))\n", "task": "Using the `sen1` and `ee` variables, filter the `sen1` dataset to only include images with a descending orbit pass. Define the resulting dataset as `des`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\ncor = [[48.42331357710716, 31.94100799817005], [48.75839658491966, 31.94100799817005], [48.75839658491966,\n                                                                                        32.18773294099697], [48.42331357710716, 32.18773294099697], [48.42331357710716, 31.94100799817005]]\ngeometry = ee.Geometry.Polygon(cor)\ntime_start = '2020'\ntime_end = '2021'\nsen1 = ee.ImageCollection('COPERNICUS/S1_GRD').filterDate(time_start, time_end).filterBounds(geometry).filter(\n    ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')).filter(ee.Filter.eq('instrumentMode', 'IW')).select('VV')\n", "functions": ["sen1.filter", "ee.Filter.eq"], "external_vars": ["ee", "sen1"], "defined_vars": ["des"], "parameters": ["orbitProperties_pass", "DESCENDING", "ee.Filter.eq('orbitProperties_pass', 'DESCENDING')"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add the random points layer to the map.\nMap.addLayer(random_points, {}, 'Random points')\n\n\n", "task": "Add a layer to the map called \"Random points\" displaying the data in the `random_points` variable. Make sure the `Map` variable is defined and initialized.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the region for generating random points.\nregion = ee.Geometry.Polygon([[[94.37268522041539, 6.649010097923157], [94.37268522041539, -11.710649628473183], [\n                             142.00940397041538, -11.710649628473183], [142.00940397041538, 6.649010097923157]]])\n# Generate 1000 random points within the specified region.\nrandom_points = ee.FeatureCollection.randomPoints(region, 1000)\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "random_points"], "defined_vars": [], "parameters": ["random_points", "Random points", "{}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the Sentinel-2 SR image collection\nim_col = ee.ImageCollection('COPERNICUS/S2_SR')\n", "task": "Using the Earth Engine library (`ee`), load the Sentinel-2 Surface Reflectance (SR) image collection and store it in a variable called `im_col`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["im_col"], "parameters": ["COPERNICUS/S2_SR"], "libraries": ["import geemap", "import ee"]}
{"code": "# Filter water to be less than 50%\nwaterLessThan50 = water.lt(1)\n", "task": "Define a variable called `waterLessThan50` that is `True` if the variable `water` is less than 1, and `False` otherwise.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the JRC max water extent layer\nwater = ee.Image('JRC/GSW1_4/GlobalSurfaceWater').select('max_extent')\n", "functions": ["water.lt"], "external_vars": ["water"], "defined_vars": ["waterLessThan50"], "parameters": [1], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the most cloudy image to the map\nMap.addLayer(cloud_affected_image, rgb_vis, \"Cloud Affected Image\")\n", "task": "Add a layer to the map called \"Cloud Affected Image\" using the `cloud_affected_image` variable. Use the `rgb_vis` variable to specify the visualization style. **Make sure to define the variables `Map`, `cloud_affected_image`, and `rgb_vis` before running this code.**", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Extract the most cloudy image\ncloud_affected_image = ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_138045_20200828')\n# Define the RGB visualization parameters\nrgb_vis = {'min': 8000, 'max': 17000, 'bands': ['SR_B4', 'SR_B3', 'SR_B2']}\n", "functions": ["Map.addLayer"], "external_vars": ["cloud_affected_image", "Map", "rgb_vis"], "defined_vars": [], "parameters": ["cloud_affected_image", "rgb_vis", "Cloud Affected Image"], "libraries": ["import geemap", "import ee"]}
{"code": "# Set the map center over Cairo\nMap.setCenter(31.42217, 29.99157, 10)\n", "task": "Center the map on the coordinates (31.42217, 29.99157) with a zoom level of 10.  You will need to define the `Map` variable before running this code.", "exec_path": "GEE", "context": "import geemap\nMap = geemap.Map()\n", "functions": ["Map.setCenter"], "external_vars": ["Map"], "defined_vars": [], "parameters": [31.42217, 29.99157, 10], "libraries": ["import geemap"]}
{"code": "roi = ee.FeatureCollection(\"WWF/HydroSHEDS/v1/Basins/hybas_5\").filterBounds(loc)\n", "task": "Using the Earth Engine library (ee), define a variable named `roi` that represents a FeatureCollection of the HydroSHEDS v1 basins (hybas_5) filtered by the bounds of the location `loc`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\ncor = [46.00719637247596, 37.199483887704204]\nloc = ee.Geometry.Point(cor)\n", "functions": ["unknown_function.filterBounds", "ee.FeatureCollection"], "external_vars": ["ee", "loc"], "defined_vars": ["roi"], "parameters": ["loc", "WWF/HydroSHEDS/v1/Basins/hybas_5"], "libraries": ["import ee", "import geemap"]}
{"code": "countries = ee.FeatureCollection(\"FAO/GAUL/2015/level0\")\nglo30 = ee.ImageCollection(\"projects/sat-io/open-datasets/GLO-30\")\nprint('GLO-30 Collection size :',glo30.size())\n", "task": "Using the external variables `ee` and `print`, define the variables `countries` as an Earth Engine FeatureCollection of countries from FAO/GAUL/2015/level0 and `glo30` as an Earth Engine ImageCollection from `projects/sat-io/open-datasets/GLO-30`. Then print the size of the `glo30` collection.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.FeatureCollection", "ee.ImageCollection", "print", "glo30.size"], "external_vars": ["print", "ee"], "defined_vars": ["glo30", "countries"], "parameters": ["FAO/GAUL/2015/level0", "projects/sat-io/open-datasets/GLO-30", "GLO-30 Collection size :", "glo30.size()"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the NDVI to the map.\nMap.addLayer(ndvi, colors, 'NDVI')\n", "task": "Add a layer to the map named \"NDVI\" using the `ndvi` data and the `colors` colormap. Make sure to define `ndvi`, `colors`, and `Map` variables before running this code.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# a) Define the Sentinel-2 image used for the analysis.\nS2 = ee.Image('COPERNICUS/S2_SR/20200719T031539_20200719T032500_T48QYD')\n# b) Extract the red and infra-red bands from the image.\nred_band = S2.select('B4')\nir_band = S2.select('B8')\n# c) Calculate the Normalized Difference Vegetation Index (NDVI).\nndvi = ir_band.subtract(red_band).divide(ir_band.add(red_band))\n# Define a color scheme for the NDVI display.\ncolors = {'min': -1, 'max': 1, 'palette': ['blue', 'white', 'green']}\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "ndvi", "colors"], "defined_vars": [], "parameters": ["ndvi", "colors", "NDVI"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define a function to mask clouds using the Sentinel-2 QA band\ndef maskS2clouds(image):\n    \"\"\"\n    Function to mask clouds using the Sentinel-2 QA band.\n\n    Args:\n        image (ee.Image): Sentinel-2 image\n\n    Returns:\n        ee.Image: Sentinel-2 image with clouds masked\n    \"\"\"\n\n    qa = image.select('QA60')\n    cloud_bit_mask = ee.Number(2).pow(10).int()\n    cirrus_bit_mask = ee.Number(2).pow(11).int()\n    mask = qa.bitwiseAnd(cloud_bit_mask).eq(0) and(\n        qa.bitwiseAnd(cirrus_bit_mask).eq(0)\n    )\n    return image.updateMask(mask).divide(10000)\n", "task": "Create a boolean mask called \"mask\" using the \"ee\" object that filters out cloud and cirrus pixels based on the \"cloud_bit_mask\" and \"cirrus_bit_mask\" from the \"qa\" band of the \"image\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["image.select", "unknown_function.int", "unknown_function.pow", "ee.Number", "unknown_function.int", "unknown_function.pow", "ee.Number", "unknown_function.eq", "qa.bitwiseAnd", "unknown_function.eq", "qa.bitwiseAnd", "unknown_function.divide", "image.updateMask"], "external_vars": ["ee"], "defined_vars": ["image", "cloud_bit_mask", "mask", "qa", "cirrus_bit_mask"], "parameters": ["QA60", 10, 2, 11, 2, 0, "cloud_bit_mask", 0, "cirrus_bit_mask", 10000, "mask"], "libraries": ["import ee", "import geemap"]}
{"code": "# 1. Import MODIS burned area data into Earth Engine.\ndataset = ee.ImageCollection('MODIS/006/MCD64A1') .filter(ee.Filter.date('2022-01-01', '2022-12-31'))\nburned_area = dataset.select('BurnDate')\n", "task": "Using the Earth Engine library (ee), load the MODIS burned area product for the year 2022 and define two variables: `dataset` which stores the image collection and `burned_area` which stores only the BurnDate band from the collection.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["unknown_function.filter", "ee.ImageCollection", "ee.Filter.date", "dataset.select"], "external_vars": ["ee"], "defined_vars": ["burned_area", "dataset"], "parameters": ["MODIS/006/MCD64A1", "2022-01-01", "2022-12-31", "BurnDate", "ee.Filter.date('2022-01-01', '2022-12-31')"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add the SRTM and slope layers to the map.\nMap.addLayer(srtm, {'min': 0, 'max': 3000}, 'DEM')\nMap.addLayer(slope, {'min': 0, 'max': 60}, 'Slope')\n", "task": "Add the \"srtm\" and \"slope\" layers to the \"Map\" object. For \"srtm\", set the minimum value to 0 and the maximum value to 3000, and name the layer \"DEM\". For \"slope\", set the minimum value to 0 and the maximum value to 60, and name the layer \"Slope\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Load the SRTM and forest loss data.\nsrtm = ee.Image('USGS/SRTMGL1_003')\n# Compute the slope from the SRTM data.\nslope = ee.Terrain.slope(srtm)\n", "functions": ["Map.addLayer", "Map.addLayer"], "external_vars": ["slope", "Map", "srtm"], "defined_vars": [], "parameters": ["srtm", "DEM", "slope", "Slope", "{'min': 0, 'max': 3000}", "{'min': 0, 'max': 60}"], "libraries": ["import ee", "import geemap"]}
{"code": "#temporal collection function\ndef temporal_collection(collection, start, count, interval, unit):\n    seq = ee.List.sequence(0, ee.Number(count).subtract(1))\n    origin_date = ee.Date(start)\n    def func_(i):\n        start_date = origin_date.advance(ee.Number(interval).multiply(i), unit)\n        end_date = origin_date.advance(ee.Number(interval).multiply(ee.Number(i).add(1)), unit)\n        return collection.filterDate(start_date, end_date).mode().set('system:time_start', start_date.millis()).set('system:time_end', end_date.millis())\n    return ee.ImageCollection(seq.map(func_))\nweekly = temporal_collection(modis, '2020', 104, 1, 'week')\n\n\n", "task": "Define the variables `unit`, `end_date`, `collection`, `origin_date`, `weekly`, `start_date`, `count`, `start`, `interval`, `i`, `seq`. The function `temporal_collection` takes as input `collection`, `start`, `count`, `interval`, and `unit` and returns a collection of images. Use `ee.List.sequence` to create a list of numbers from 0 to `count-1`. Define a function `func_` which advances the origin date by `i*interval*unit` to get the start date and `(i+1)*interval*unit` to get the end date. Filter the input collection by date using `filterDate` and return the mode of the filtered collection with `system:time_start` and `system:time_end` properties set to the corresponding dates.  Use `ee.ImageCollection(seq.map(func_))` to return the collection of images. Finally, use `temporal_collection` to get a weekly image collection named `weekly` from `modis` starting from `2020` for a total of `104` weeks.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# call modis ocean product\nmodis = ee.ImageCollection(\n    'NASA/OCEANDATA/MODIS-Terra/L3SMI').filterDate('2020', '2022')\n", "functions": ["ee.List.sequence", "unknown_function.subtract", "ee.Number", "ee.Date", "origin_date.advance", "unknown_function.multiply", "ee.Number", "origin_date.advance", "unknown_function.multiply", "ee.Number", "unknown_function.add", "ee.Number", "unknown_function.set", "unknown_function.set", "unknown_function.mode", "collection.filterDate", "start_date.millis", "end_date.millis", "ee.ImageCollection", "seq.map", "temporal_collection"], "external_vars": ["modis", "func_", "temporal_collection", "ee"], "defined_vars": ["start", "interval", "start_date", "end_date", "origin_date", "collection", "count", "seq", "unit", "weekly", "i"], "parameters": [0, 1, "count", "start", "unit", "i", "interval", "unit", "interval", 1, "i", "system:time_end", "system:time_start", "start_date", "end_date", "func_", "modis", "2020", 104, 1, "week", "ee.Number(count).subtract(1)", "ee.Number(interval).multiply(i)", "ee.Number(interval).multiply(ee.Number(i).add(1))", "ee.Number(i).add(1)", "end_date.millis()", "start_date.millis()", "seq.map(func_)"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the geometry for extracting AOD values\ngeom = ee.Geometry.Rectangle([-66.1939254455482, -17.429160212303483,\n                               -66.1115279846107, -17.38100252728992], None, False)\n\n\n", "task": "Using the Earth Engine library (ee), define a variable named `geom` as a rectangular geometry with the following coordinates: [-66.1939254455482, -17.429160212303483, -66.1115279846107, -17.38100252728992].", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Geometry.Rectangle"], "external_vars": ["ee"], "defined_vars": ["geom"], "parameters": [null, false, "[-66.1939254455482, -17.429160212303483, -66.1115279846107, -17.38100252728992]"], "libraries": ["import ee", "import geemap"]}
{"code": "table = ee.FeatureCollection(\"WWF/HydroSHEDS/v1/Basins/hybas_5\")\n", "task": "Using the Earth Engine library (ee), load the HydroSHEDS v1 Basins feature collection (hybas_5) and assign it to the variable `table`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.FeatureCollection"], "external_vars": ["ee"], "defined_vars": ["table"], "parameters": ["WWF/HydroSHEDS/v1/Basins/hybas_5"], "libraries": ["import geemap", "import ee"]}
{"code": "#slope in Prozent konvertieren\n#Display the result.\nMap.setCenter(11.40, 47.36, 9) # Center on Innsbruck\n#Koordinaten finden durch Punkt setzen und in oberste Zeile nachschauen\nMap.addLayer(srtm, {min: 0, max :2500, 'palette': ['blue', 'green', 'red']}, 'srtm');\nMap.addLayer(slope, {min: 0, max :60, 'palette': ['yellow', 'purple', 'orange']}, 'slope');\n", "task": "Center the map at coordinates 11.4 longitude and 47.36 latitude, with a zoom level of 9. Add a layer called \"srtm\" using the `srtm` variable with a color palette ranging from blue to green to red, where the minimum value is 0 and the maximum value is 2500. Also add a layer called \"slope\" using the `slope` variable with a color palette ranging from yellow to purple to orange, where the minimum value is 0 and the maximum value is 60.  You will need to define the variables `Map`, `slope`, `srtm`, `min`, `max`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the SRTM image.\nsrtm = ee.Image('CGIAR/SRTM90_V4')\n# slope verwendet Grad\nslope = ee.Terrain.slope(srtm)\n", "functions": ["Map.setCenter", "Map.addLayer", "Map.addLayer"], "external_vars": ["srtm", "max", "Map", "min", "slope"], "defined_vars": [], "parameters": [11.4, 47.36, 9, "srtm", "srtm", "slope", "slope", "{min: 0, max: 2500, 'palette': ['blue', 'green', 'red']}", "{min: 0, max: 60, 'palette': ['yellow', 'purple', 'orange']}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the geometry of the Twente region\nTwente = ee.Geometry.Polygon([[[-4.041052552535658, 52.94090567638422],\n                               [-4.041052552535658, 51.722482350154216],\n                               [ 7.155676575973158, 51.722482350154216],\n                               [ 7.155676575973158, 52.94090567638422]]])\n", "task": "Define a variable called **Twente** using the **ee.Geometry.Polygon** function. The coordinates of the polygon are [[[-4.041052552535658, 52.94090567638422], [-4.041052552535658, 51.722482350154216], [7.155676575973158, 51.722482350154216], [7.155676575973158, 52.94090567638422]]].", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee"], "defined_vars": ["Twente"], "parameters": ["[[[-4.041052552535658, 52.94090567638422], [-4.041052552535658, 51.722482350154216], [7.155676575973158, 51.722482350154216], [7.155676575973158, 52.94090567638422]]]"], "libraries": ["import geemap", "import ee"]}
{"code": "# Create a mask for the flooded areas.\nfloods = categorical.updateMask(categorical.select(\"Class\").eq(2))\n", "task": "Using the provided `categorical` dataframe, create a new dataframe called `floods` where all rows with a \"Class\" value of 2 are selected and all other rows are masked out.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Load the Sentinel-1 images.\nbefore = ee.ImageCollection('COPERNICUS/S1_GRD').filterDate('2019-11-13', '2019-11-14').filter(ee.Filter.listContains('transmitterReceiverPolarisation',\n                                                                                                                      'VV')).filter(ee.Filter.eq('instrumentMode', 'IW')).filterMetadata('resolution_meters', 'equals', 10).select('VV').median()\nafter = ee.ImageCollection('COPERNICUS/S1_GRD').filterDate('2019-11-25', '2019-11-26').filter(ee.Filter.listContains('transmitterReceiverPolarisation',\n                                                                                                                     'VV')).filter(ee.Filter.eq('instrumentMode', 'IW')).filterMetadata('resolution_meters', 'equals', 10).select('VV').median()\n# Calculate the changes between the two images.\nChanges = after.subtract(before)\n# Create a categorical image.\ncategorical = ee.Image(1).rename('Class').where(\n    Changes.gt(-10), 1).where(Changes.lt(-10), 2)\n", "functions": ["categorical.updateMask", "unknown_function.eq", "categorical.select"], "external_vars": ["categorical"], "defined_vars": ["floods"], "parameters": [2, "Class", "categorical.select('Class').eq(2)"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add the loss layer in red.\nMap.addLayer(lossImage.updateMask(lossImage),\n    {'palette': ['FF0000']}, 'Loss')\n", "task": "Add a layer to the Map object named \"Loss\" that displays the lossImage with a red color palette. The lossImage should be masked with itself to remove any background pixels. You will need to define the following variables before running this code:  \\n\\n* **Map:** The Map object to which the layer will be added. \\n* **lossImage:** The image representing the loss values.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the data and select the bands of interest.\ngfc2014 = ee.Image('UMD/hansen/global_forest_change_2015')\nlossImage = gfc2014.select(['loss'])\n", "functions": ["Map.addLayer", "lossImage.updateMask"], "external_vars": ["Map", "lossImage"], "defined_vars": [], "parameters": ["Loss", "lossImage", "lossImage.updateMask(lossImage)", "{'palette': ['FF0000']}"], "libraries": ["import geemap", "import ee"]}
{"code": "def func3_(img):\n    cons = ee.Image.constant(1)\n    return img.select('modis').addBands(cons).addBands(img.select('landsat'))\n\nmodel = collection.map(func3_).reduce(ee.Reducer.linearRegression(2, 1)) \ngain = model.select('coefficients').arrayGet([0,0])\noffset = model.select('coefficients').arrayGet([1,0])\n", "task": "Using the Earth Engine library (`ee`), apply a linear regression model to a collection of images (`collection`). Define a function `func3_` which takes an image (`img`) as input, adds a constant image (`cons`) to the \"modis\" band, and then adds the \"landsat\" band from the original image. Map this function over the collection, then reduce the result using a linear regression reducer with 2 predictors and 1 response. From the resulting model, extract the gain (`gain`) from the coefficients at index [0, 0] and the offset (`offset`) from the coefficients at index [1, 0].", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ncor = [[48.09247807376013, 32.24597202127133], [48.32868412844763, 32.24597202127133], [48.32868412844763,\n                                                                                        32.41654922827216], [48.09247807376013, 32.41654922827216], [48.09247807376013, 32.24597202127133]]\ngeometry = ee.Geometry.Polygon(cor)\ntime_start = '2020'\ntime_end = '2021'\n\n\ndef func_(img):\n    gain = ee.Number(img.get('REFLECTANCE_MULT_BAND_3'))\n    offset = ee.Number(img.get('REFLECTANCE_ADD_BAND_3'))\n    ms = img.select('SR_B.*').multiply(gain).add(offset)\n    ndvi = ms.normalizedDifference(['SR_B5', 'SR_B4']).rename('landsat')\n    return ndvi.copyProperties(img, ['system:time_start', 'system:time_end'])\n\n\nlandsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterBounds(geometry).filterDate(time_start, time_end).filter(\n    ee.Filter.eq('WRS_PATH', 166)).filter(ee.Filter.eq('WRS_ROW', 38)).filter(ee.Filter.lt('CLOUD_COVER', 10)).map(func_)\nmodis = ee.ImageCollection(\n    'MODIS/MOD09GA_006_NDVI').filterDate(time_start, time_end)\ndays = 3\nmills = ee.Number(days).multiply(1000 * 3600 * 24)\nfilter = ee.Filter.maxDifference(\n    mills, 'system:time_start', 'null', 'system:time_start', 'null')\njoin = ee.Join.saveAll('modis')\njoin_data = ee.ImageCollection(join.apply(landsat, modis, filter))\n\n\ndef func2_(img):\n    images = ee.ImageCollection.fromImages(img.get('modis')).max()\n    return img.addBands(images.rename('modis'))\n\n\ncollection = join_data.map(func2_)\n", "functions": ["ee.Image.constant", "unknown_function.addBands", "unknown_function.addBands", "img.select", "img.select", "unknown_function.reduce", "collection.map", "ee.Reducer.linearRegression", "unknown_function.arrayGet", "model.select", "unknown_function.arrayGet", "model.select"], "external_vars": ["func3_", "ee", "collection"], "defined_vars": ["gain", "offset", "cons", "img", "model"], "parameters": [1, "cons", "modis", "landsat", "func3_", 2, 1, "coefficients", "coefficients", "img.select('landsat')", "ee.Reducer.linearRegression(2, 1)", "[0, 0]", "[1, 0]"], "libraries": ["import geemap", "import ee"]}
{"code": "temp= ee.ImageCollection(\"MODIS/061/MOD11A2\").select('LST_Day_1km').filterDate(time_start, time_end)\n", "task": "Define a variable named `temp` as an Earth Engine image collection containing the daily MODIS Land Surface Temperature (LST) data for the time period between `time_start` and `time_end`. Select the `LST_Day_1km` band from the collection. Use the `ee` object for Earth Engine interactions.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\ntime_start = '2001'\ntime_end = '2024'\n", "functions": ["unknown_function.filterDate", "unknown_function.select", "ee.ImageCollection"], "external_vars": ["ee", "time_start", "time_end"], "defined_vars": ["temp"], "parameters": ["time_start", "time_end", "LST_Day_1km", "MODIS/061/MOD11A2"], "libraries": ["import ee", "import geemap"]}
{"code": "iw = ee.Number(str_bareland.max().reduceRegion(\n  reducer=ee.Reducer.max(), geometry=roi, scale=100\n  ).values().get(0))\n", "task": "Define a variable named `iw` as an `ee.Number` object representing the maximum value of the `str_bareland` image within the `roi` region using a scale of 100.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ncor1 = [[45.779592977269836, 36.1375555993027], [47.28471993039483, 36.1375555993027], [47.28471993039483,\n                                                                                        37.221265803646695], [45.779592977269836, 37.221265803646695], [45.779592977269836, 36.1375555993027]]\nroi = ee.Geometry.Polygon(cor1)\nsentinel = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED').filterBounds(\n    roi).filterDate('2020', '2021').filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 45))\n# temporal collection function\n\n\ndef temporal_collection(collection, start, count, interval, unit):\n    seq = ee.List.sequence(0, ee.Number(count).subtract(1))\n    origin_date = ee.Date(start)\n\n    def func_(i):\n        start_date = origin_date.advance(ee.Number(interval).multiply(i), unit)\n        end_date = origin_date.advance(\n            ee.Number(interval).multiply(ee.Number(i).add(1)), unit)\n        return collection.filterDate(start_date, end_date).median().set('system:time_start', start_date.millis()).set('system:time_end', end_date.millis())\n    return ee.ImageCollection(seq.map(func_))\n\n\nmonthly = temporal_collection(sentinel, '2020', 12, 1, 'month')\n\n\ndef func_(img):\n    bands = img.select('B.*').multiply(0.0001)\n    ndvi = bands.normalizedDifference(['B8', 'B4']).rename('ndvi')\n    str = bands.expression('((1 - swir) ** 2)/(2 * swir)',\n                           {'swir': bands.select('B12')}).rename('str')\n    stack = ee.Image.cat([ndvi, str])\n    return stack.copyProperties(img, img.propertyNames())\n\n\nparameters = monthly.map(func_)\n\n\ndef func3_(img):\n    thr_bare = img.select('ndvi').gte(0) and img.select('ndvi').lt(0.2)\n    str_bare = img.select('str').updateMask(thr_bare)\n    return str_bare.copyProperties(img, img.propertyNames())\n\n\nstr_bareland = parameters.map(func3_)\n", "functions": ["ee.Number", "unknown_function.get", "unknown_function.values", "unknown_function.reduceRegion", "str_bareland.max", "ee.Reducer.max"], "external_vars": ["str_bareland", "ee", "roi"], "defined_vars": ["iw"], "parameters": [0, "str_bareland.max().reduceRegion(reducer=ee.Reducer.max(), geometry=roi, scale=100).values().get(0)"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define a function to create a 1 ha box around a given point\ndef bounding_box_func(feature):\n    intermediate_buffer = feature.buffer(50)  # buffer radius, half your box width in m\n    intermediate_box = intermediate_buffer.bounds()  # Draw a bounding box around the circle\n    return intermediate_box  # Return the bounding box\n", "task": "Define a function called `bounding_box_func` that takes a geometric feature called `feature` as input. Inside the function, create a new feature called `intermediate_buffer` by buffering `feature` by 50 units. Then, obtain the bounding box of `intermediate_buffer` and store it in a variable called `intermediate_box`. Finally, return `intermediate_box`.", "exec_path": "GEE", "context": "", "functions": ["feature.buffer", "intermediate_buffer.bounds"], "external_vars": [], "defined_vars": ["feature", "intermediate_buffer", "intermediate_box"], "parameters": [50], "libraries": []}
{"code": "modis = ee.ImageCollection(\"MODIS/061/MOD09A1\").filterDate(time_start, time_end)\n", "task": "Using the Earth Engine library (`ee`), define a variable called `modis` to represent an ImageCollection of MODIS data from the `MODIS/061/MOD09A1` collection. Filter the collection for dates between `time_start` and `time_end`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\ntime_start = '2001'\ntime_end = '2023'\n", "functions": ["unknown_function.filterDate", "ee.ImageCollection"], "external_vars": ["ee", "time_start", "time_end"], "defined_vars": ["modis"], "parameters": ["time_start", "time_end", "MODIS/061/MOD09A1"], "libraries": ["import ee", "import geemap"]}
{"code": "# Convert the 500 random points into 1ha boxes\nbox_1ha = Random_pts_ft_subset.map(bounding_box_func)\n", "task": "Define a new variable called `box_1ha` and assign it the result of applying the `bounding_box_func` to each element in the `Random_pts_ft_subset` list.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ntable2 = ee.FeatureCollection(\n    'users/Chiquitania/random_500_1hapoints_MCD64_Control_noALOS')\n# Get the 500 random points\nRandom_pts_ft = table2\n# Define a function to create a 1 ha box around a given point\n\n\ndef bounding_box_func(feature):\n    \"\"\"\n    Creates a 1 ha box around a given point.\n\n    Args:\n        feature (ee.Feature): The point feature.\n\n    Returns:\n        ee.Geometry: The 1 ha box.\n    \"\"\"\n    intermediate_buffer = feature.buffer(50)\n    intermediate_box = intermediate_buffer.bounds()\n    return intermediate_box\n\n\n# Convert the 500 points into a feature collection\nRandom_pts_ft_subset = ee.FeatureCollection(Random_pts_ft.toList(500))\n", "functions": ["Random_pts_ft_subset.map"], "external_vars": ["bounding_box_func", "Random_pts_ft_subset"], "defined_vars": ["box_1ha"], "parameters": ["bounding_box_func"], "libraries": ["import ee", "import geemap"]}
{"code": "# Display the slope, SRTM30m DEM,.And Global Surface Water layers on the map.\nMap.addLayer(slope, {'min': 0, 'max': 45}, 'Slope')\nMap.addLayer(srtm, {'min': 0, 'max': 400}, 'SRTM')\nMap.addLayer(water, {'bands': 'occurrence', 'min': 0, 'max': 100, 'palette': 'lightblue, blue'}, 'Water')\n\n\n", "task": "Add three layers to the map: \"Slope\", \"SRTM\", and \"Water\". Use the following variables: `slope`, `Map`, `water`, `srtm`.  Please define the following variables: `slope`, `srtm`, `water`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the SRTM30m digital elevation model.\nsrtm = ee.Image('USGS/SRTMGL1_003')\n# Load the Global Surface Water dataset.\nwater = ee.Image('JRC/GSW1_3/GlobalSurfaceWater')\n# Calculate the terrain slope from the SRTM30m DEM.\nslope = ee.Terrain.slope(srtm)\n", "functions": ["Map.addLayer", "Map.addLayer", "Map.addLayer"], "external_vars": ["water", "srtm", "Map", "slope"], "defined_vars": [], "parameters": ["slope", "Slope", "srtm", "SRTM", "water", "Water", "{'min': 0, 'max': 45}", "{'min': 0, 'max': 400}", "{'bands': 'occurrence', 'min': 0, 'max': 100, 'palette': 'lightblue, blue'}"], "libraries": ["import geemap", "import ee"]}
{"code": "landsat9 = ee.ImageCollection(\"LANDSAT/LC09/C02/T1_L2\").filterDate(time_start, time_end).filterBounds(geometry)\n", "task": "Define a variable called `landsat9` and assign it an Earth Engine ImageCollection object. The collection should be 'LANDSAT/LC09/C02/T1_L2' filtered by date using `time_start` and `time_end` and spatially filtered by the `geometry` using `filterBounds`. You will need to use the `ee` object to access the Earth Engine API.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\ncor1 = [[-113.80502319704019, 42.704955393175936], [-113.56057739625894, 42.704955393175936], [-113.56057739625894,\n                                                                                               42.862689736716995], [-113.80502319704019, 42.862689736716995], [-113.80502319704019, 42.704955393175936]]\ngeometry = ee.Geometry.Polygon(cor1)\ntime_start = '2023'\ntime_end = '2024'\n", "functions": ["unknown_function.filterBounds", "unknown_function.filterDate", "ee.ImageCollection"], "external_vars": ["ee", "geometry", "time_start", "time_end"], "defined_vars": ["landsat9"], "parameters": ["geometry", "time_start", "time_end", "LANDSAT/LC09/C02/T1_L2"], "libraries": ["import geemap", "import ee"]}
{"code": "# Select the image with the least cloud cover.\nthai_cloud = thai.sort('CLOUD_COVER').first()\n", "task": "Sort the `thai` DataFrame by the \"CLOUD_COVER\" column in ascending order and store the first row in a new variable called `thai_cloud`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the Landsat 8 collection.\nl8 = ee.ImageCollection('LANDSAT/LC8_L1T_TOA')\n# Filter the collection by date and path/row.\nthai = l8.filterDate('2016-01-01', '2016-12-31').filter(\n    ee.Filter.eq('WRS_PATH', 130)).filter(ee.Filter.eq('WRS_ROW', 50))\n", "functions": ["unknown_function.first", "thai.sort"], "external_vars": ["thai"], "defined_vars": ["thai_cloud"], "parameters": ["CLOUD_COVER"], "libraries": ["import geemap", "import ee"]}
{"code": "Map.addLayer(change.clip(roi),{},'flood', False)\n", "task": "Add a layer to the map called \"flood\" displaying the clipped change data within the specified region of interest (ROI). The layer should not be visible by default. Make sure to define the following variables before executing this instruction: `roi`, `change`, `Map`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ncor = [[54.07394733345745, 36.81321992370517], [54.79904498970745, 36.81321992370517], [54.79904498970745,\n                                                                                        37.45259869689526], [54.07394733345745, 37.45259869689526], [54.07394733345745, 36.81321992370517]]\nroi = ee.Geometry.Polygon(cor)\nyear_start = '2019'\nyear_end = '2020'\nafter = ee.ImageCollection('COPERNICUS/S1_GRD').filterBounds(roi).filterDate(year_start, year_end).filter(ee.Filter.calendarRange(3, 3, 'month')).filter(ee.Filter.listContains(\n    'transmitterReceiverPolarisation', 'VV')).filter(ee.Filter.eq('instrumentMode', 'IW')).select('VV').map(lambda img: img.focalMedian(100, 'square', 'meters').copyProperties(img, img.propertyNames())).min()\nbefore = ee.ImageCollection('COPERNICUS/S1_GRD').filterBounds(roi).filterDate(year_start, year_end).filter(ee.Filter.calendarRange(2, 2, 'month')).filter(ee.Filter.listContains(\n    'transmitterReceiverPolarisation', 'VV')).filter(ee.Filter.eq('instrumentMode', 'IW')).select('VV').map(lambda img: img.focalMedian(100, 'square', 'meters').copyProperties(img, img.propertyNames())).min()\nchange = before.subtract(after).rename('flood')\n", "functions": ["Map.addLayer", "change.clip"], "external_vars": ["Map", "roi", "change"], "defined_vars": [], "parameters": ["flood", false, "roi", "change.clip(roi)", "{}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Select the 'fnf' band.\nforest = dataset.select('fnf')\n", "task": "Using the dataset, select the column named \"fnf\" and assign the resulting data to a new variable called \"forest\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the Global PALSAR-2/PALSAR dataset.\ndataset = ee.ImageCollection(\n    'JAXA/ALOS/PALSAR/YEARLY/FNF').filterDate('2016-01-01', '2021-12-31')\n", "functions": ["dataset.select"], "external_vars": ["dataset"], "defined_vars": ["forest"], "parameters": ["fnf"], "libraries": ["import geemap", "import ee"]}
{"code": "# This is a function to pass to Iterate().\n# As anomaly images are computed, add them to the list.\ndef accumulate(image, list):\n  # Get the latest cumulative anomaly image from the end of the list with\n  # get(-1).  Since the type of the list argument to the function is unknown,\n  # it needs to be cast to a List.  Since the return type of get() is unknown,\n  # cast it to Image.\n  previous = ee.Image(ee.List(list).get(-1))\n\n  # Add the current anomaly to make a new cumulative anomaly image.\n  added = image.add(previous).set('system:time_start', image.get('system:time_start'))\n\n  # Return the list with the cumulative anomaly inserted.\n  return ee.List(list).add(added)\n", "task": "Define a function called `accumulate` that takes an `image` and a `list` as input. The function should use the `ee` module to access the last element of the `list` and store it in a variable called `previous`. Then, add the `image` to `previous` and store the result in a variable called `added`. Set the `system:time_start` property of `added` to the `system:time_start` property of `image`. Finally, return the `list` with `added` appended to it.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Image", "unknown_function.get", "ee.List", "unknown_function.set", "image.add", "image.get", "unknown_function.add", "ee.List"], "external_vars": ["ee"], "defined_vars": ["previous", "image", "added", "list"], "parameters": ["list", "system:time_start", "previous", "system:time_start", "added", "list", "ee.List(list).get(-1)", "-1", "image.get('system:time_start')"], "libraries": ["import geemap", "import ee"]}
{"code": "Map.addLayer(sen1.clip(roi),{},'sen1',False)\n", "task": "Add a layer to the Map called \"sen1\" by clipping the `sen1` layer to the region of interest `roi`. The layer should be added with no specific style. You need to define the variables `sen1`, `roi`, and `Map`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [[32.33741352024498, 31.356500050396157], [32.59559223118248, 31.356500050396157], [32.59559223118248,\n                                                                                          31.58490130730319], [32.33741352024498, 31.58490130730319], [32.33741352024498, 31.356500050396157]]\nroi = ee.Geometry.Polygon(cor)\nsen1 = ee.ImageCollection('COPERNICUS/S1_GRD').select('VV').filterDate('2014', '2015').filterBounds(roi).filter(ee.Filter.calendarRange(10, 10, 'month')).filter(\n    ee.Filter.calendarRange(4, 4, 'day_of_month')).filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')).filter(ee.Filter.eq('instrumentMode', 'IW')).mosaic()\n", "functions": ["Map.addLayer", "sen1.clip"], "external_vars": ["sen1", "roi", "Map"], "defined_vars": [], "parameters": ["sen1", false, "roi", "sen1.clip(roi)", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Import the Landsat 8 image collection\nl8 = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_L2\")\n", "task": "Using the Earth Engine library (ee), load the Landsat 8 Collection 2 Tier 1 Level-2 data and assign it to the variable `l8`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["l8"], "parameters": ["LANDSAT/LC08/C02/T1_L2"], "libraries": ["import geemap", "import ee"]}
{"code": "# Chinese effort across all gear types\nchina_all = china.reduce(ee.Reducer.sum())\n", "task": "Using the Earth Engine library (ee) and the variable `china`, calculate the sum of all values in the image collection and assign it to the variable `china_all`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Fishing effort, measured in hours of inferred fishing activity.\ngfw = ee.ImageCollection('GFW/GFF/V1/fishing_hours')\n# Define a function that aggregates data for a given flag state and date range\n\n\ndef flag_totals(flag, start_date, end_date):\n    effort_flag = gfw.filterMetadata('country', 'equals', flag).filterDate(\n        start_date, end_date).sum().float()\n    return effort_flag\n\n\n# Run function for China\nchina = flag_totals('CHN', '2016-01-01', '2017-01-01')\n", "functions": ["china.reduce", "ee.Reducer.sum"], "external_vars": ["ee", "china"], "defined_vars": ["china_all"], "parameters": ["ee.Reducer.sum()"], "libraries": ["import geemap", "import ee"]}
{"code": "salinity2 = ee.ImageCollection(\"HYCOM/sea_temp_salinity\").select('salinity_0').filterDate('2000','2020')\n", "task": "Using the Earth Engine library (ee), create an ImageCollection called `salinity2` from the `HYCOM/sea_temp_salinity` dataset. Select the `salinity_0` band and filter the collection to include data between the years 2000 and 2020.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["unknown_function.filterDate", "unknown_function.select", "ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["salinity2"], "parameters": ["2000", "2020", "salinity_0", "HYCOM/sea_temp_salinity"], "libraries": ["import ee", "import geemap"]}
{"code": "canopy_max = forest.reduceRegion(\n  reducer=ee.Reducer.max(), geometry=roi, scale=100\n  ).values().get(0)\nprint('canopy_max', canopy_max)\n", "task": "Calculate the maximum canopy height within the region of interest (ROI) using the \"forest\" image and define the variable \"canopy_max\" with the result. Print the value of \"canopy_max\" using the \"print\" function.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nbasin = ee.FeatureCollection('WWF/HydroSHEDS/v1/Basins/hybas_6')\ncor = [28.577460872036138, 64.5593101743747]\npoint = ee.Geometry.Point(cor)\nroi = basin.filterBounds(point)\ncanopy = ee.ImageCollection(\n    'projects/meta-forest-monitoring-okw37/assets/CanopyHeight').mosaic()\nforest_thr = canopy.gt(0)\nforest = canopy.updateMask(forest_thr)\n", "functions": ["unknown_function.get", "unknown_function.values", "forest.reduceRegion", "ee.Reducer.max", "print"], "external_vars": ["forest", "roi", "print", "ee"], "defined_vars": ["canopy_max"], "parameters": [0, "canopy_max", "canopy_max"], "libraries": ["import geemap", "import ee"]}
{"code": "# Convert the bands to a 2D 7x1 array. The toArray() call concatenates pixels from each band along the default axis 0 into a 1D vector per pixel, and the toArray(1) call concatenates each band (in this case just the one band of 1D vectors) along axis 1, forming a 2D array.\ninputValues = allBandMosaic.toArray().toArray(1)\n", "task": "Convert the `allBandMosaic` multi-dimensional array into a one-dimensional array and store it in the variable `inputValues`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Create a mosaic of Landsat 5 images from June through September, 2007.\nallBandMosaic = ee.ImageCollection(\n    'LANDSAT/LT05/C02/T2').filterDate('2007-06-01', '2007-09-30').select('B[0-7]').median()\n", "functions": ["unknown_function.toArray", "allBandMosaic.toArray"], "external_vars": ["allBandMosaic"], "defined_vars": ["inputValues"], "parameters": [1], "libraries": ["import geemap", "import ee"]}
{"code": "temp_stat = temp_map.reduceRegion(\n  reducer=ee.Reducer.minMax().group(1), geometry=geometry, scale=10000\n  )\nclass3 = climate_map.eq(3)\nndvi = ee.ImageCollection(\"MODIS/061/MOD13A1\").filterDate('2002','2020').map(lambda img:img.select('NDVI').multiply(0.0001).updateMask(class3).copyProperties(img, img.propertyNames()))\n\n\n", "task": "Calculate the minimum and maximum temperature values within the specified geometry using the `temp_map` and store them in the variable `temp_stat`. Then, select the pixels in the `climate_map` that are equal to 3 and store the result in the variable `class3`. Finally, create an ImageCollection called `ndvi` by filtering the `MODIS/061/MOD13A1` collection between the years 2002 and 2020 and mapping a function that extracts the NDVI band, scales it by 0.0001, masks it with `class3`, and copies properties from the original image. Use the `ee` object for all Earth Engine operations.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ncor = [[43.35677604381791, 23.674610360519907], [63.30794791881791, 23.674610360519907], [63.30794791881791,\n                                                                                          40.069578895767485], [43.35677604381791, 40.069578895767485], [43.35677604381791, 23.674610360519907]]\ngeometry = ee.Geometry.Polygon(cor)\nera = ee.ImageCollection(\n    'ECMWF/ERA5_LAND/MONTHLY_AGGR').filterDate('2000', '2020')\nclimate = era.select('temperature_2m', 'total_precipitation_sum')\nclimate_stack = climate.toBands()\nsample = climate_stack.sample(region=geometry, scale=10000, numPixels=100)\nmodel = ee.Clusterer.wekaKMeans(4).train(sample)\nclimate_map = climate_stack.cluster(model).rename('climate_map')\ntemp = era.select('temperature_2m').mean().subtract(273.15)\ntemp_map = temp.addBands(climate_map)\n", "functions": ["temp_map.reduceRegion", "unknown_function.group", "ee.Reducer.minMax", "climate_map.eq", "unknown_function.map", "unknown_function.filterDate", "ee.ImageCollection", "unknown_function.copyProperties", "unknown_function.updateMask", "unknown_function.multiply", "img.select", "img.propertyNames"], "external_vars": ["climate_map", "geometry", "img", "temp_map", "ee"], "defined_vars": ["ndvi", "class3", "temp_stat"], "parameters": [1, 3, "2002", "2020", "MODIS/061/MOD13A1", "img", "class3", 0.0001, "NDVI", "lambda img: img.select('NDVI').multiply(0.0001).updateMask(class3).copyProperties(img, img.propertyNames())", "img.propertyNames()"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the array image to the map for visualization.\nMap.addLayer(thearrayimage, {}, \"single array\")\n", "task": "Add a layer to the map using the array image data stored in `thearrayimage`. The layer should be named \"single array\" and have no additional styling options.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the image you want to work with.\nthearrayimage = ee.Image([3, 4, 1, 55, 2]).toArray()\n", "functions": ["Map.addLayer"], "external_vars": ["thearrayimage", "Map"], "defined_vars": [], "parameters": ["thearrayimage", "single array", "{}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Display the SRTM elevation.And the areas higher than 500m on the map.\nMap.addLayer(srtm_WA_Feet, {min: 0, max: 4920}, \"SRTM West Africa in feet\")\nMap.addLayer(srtm_WA_gt500, {min: 0, max: 1, 'palette': [\"white\", \"red\"]}, \"Elev. > 500m\")\n", "task": "Add two layers to the map. The first layer is `srtm_WA_Feet` with a minimum value of `min` 0 and a maximum value of `max` 4920.  The layer label is \"SRTM West Africa in feet\". The second layer is `srtm_WA_gt500` with a minimum value of `min` 0 and a maximum value of `max` 1. Set the palette to `[\"white\", \"red\"]`. The layer label is \"Elev. > 500m\".  You will need to define the variables `srtm_WA_Feet`, `srtm_WA_gt500`, `Map`, `min`, and `max`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the SRTM elevation dataset.\nsrtm = ee.Image('USGS/SRTMGL1_003')\n# Load the West Africa boundary shapefile.\nWest_Africa = ee.FeatureCollection('users/Kwame/WestAfrica/WestAfrica_Outline')\n# Clip the SRTM elevation dataset to the West Africa boundary.\nsrtm_WA = srtm.clip(West_Africa)\n# Convert the SRTM elevation from meters to feet.\nsrtm_WA_Feet = srtm_WA.multiply(3.2808399)\n# Find all places higher than 500m.\nsrtm_WA_gt500 = srtm_WA.gt(500)\n", "functions": ["Map.addLayer", "Map.addLayer"], "external_vars": ["max", "srtm_WA_gt500", "srtm_WA_Feet", "Map", "min"], "defined_vars": [], "parameters": ["srtm_WA_Feet", "SRTM West Africa in feet", "srtm_WA_gt500", "Elev. > 500m", "{min: 0, max: 4920}", "{min: 0, max: 1, 'palette': ['white', 'red']}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Calculate the area of the geometry\narea = geometry.area()\nprint(area)\n", "task": "Calculate the area of a geometric shape using the `geometry` object and print the result using the `print` function.  Define a variable named `area` to store the calculated area.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the geometry as a polygon\ngeometry = ee.Geometry.Polygon([[175.65420985221863, -39.13437121286583], [175.65410256385803, -39.13457510191529], [175.65424740314484, -39.1349163026774], [175.65453171730042, -39.13506193664559], [\n                               175.65478920936584, -39.13502448793968], [175.65471410751343, -39.1346291948293], [175.6545478105545, -39.13444194994987], [175.654456615448, -39.1343379248017]])\n", "functions": ["geometry.area", "print"], "external_vars": ["geometry", "print"], "defined_vars": ["area"], "parameters": ["area"], "libraries": ["import geemap", "import ee"]}
{"code": "# a) Define the Sentinel-2 image used for the analysis.\nS2 = ee.Image('COPERNICUS/S2_SR/20200719T031539_20200719T032500_T48QYD')\n", "task": "Define a variable named `S2` using the `ee.Image` function to load a Sentinel-2 Surface Reflectance image from the specified date and tile ID. This image is accessible from the `COPERNICUS/S2_SR` collection.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["S2"], "parameters": ["COPERNICUS/S2_SR/20200719T031539_20200719T032500_T48QYD"], "libraries": ["import ee", "import geemap"]}
{"code": "def func2_(img):\n    lai = img.select('Lai_500m').multiply(0.1)\n    fpar = img.select('Fpar_500m').multiply(0.01)\n    return lai.addBands(fpar).copyProperties(img, img.propertyNames())\n\nlai2020 = ee.ImageCollection(\"MODIS/061/MOD15A2H\").select('Lai_500m','Fpar_500m').filterDate('2020', '2021').filter(ee.Filter.calendarRange(5,9,'month')).map(func2_).median()\ndataset2020 = ee.Image.cat([ndvi2020, lai2020, landcover])\n", "task": "Define variables **lai2020**, **img**, **lai**, **dataset2020**, and **fpar**. Then, calculate the median LAI (**lai2020**) for the year 2020 using the MODIS 15A2H product from May to September. Use the provided function **func2_** to process each image in the collection. Finally, create a new image collection (**dataset2020**) by concatenating **ndvi2020**, **lai2020**, and **landcover**. Use the **ee** library for all operations.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\nlandcover = ee.ImageCollection('MODIS/061/MCD12Q1').select('LC_Type1').mode()\n# prediction 2020\nndvi2020 = ee.ImageCollection('MODIS/061/MOD13Q1').select('NDVI', 'EVI').filterDate('2020', '2021').filter(\n    ee.Filter.calendarRange(5, 9, 'month')).map(lambda img: img.multiply(0.0001).copyProperties(img, img.propertyNames())).median()\n", "functions": ["unknown_function.multiply", "img.select", "unknown_function.multiply", "img.select", "unknown_function.copyProperties", "lai.addBands", "img.propertyNames", "unknown_function.median", "unknown_function.map", "unknown_function.filter", "unknown_function.filterDate", "unknown_function.select", "ee.ImageCollection", "ee.Filter.calendarRange", "ee.Image.cat"], "external_vars": ["ee", "ndvi2020", "landcover", "func2_"], "defined_vars": ["lai", "dataset2020", "lai2020", "fpar", "img"], "parameters": [0.1, "Lai_500m", 0.01, "Fpar_500m", "img", "fpar", "func2_", "2020", "2021", "Lai_500m", "Fpar_500m", "MODIS/061/MOD15A2H", 5, 9, "month", "img.propertyNames()", "ee.Filter.calendarRange(5, 9, 'month')", "[ndvi2020, lai2020, landcover]"], "libraries": ["import ee", "import geemap"]}
{"code": "# Clip the Hansen Global Forest Change dataset to the region of interest.\nargentina_hansen_gfc_clip = hansen_gfc.clip(argentina)\n", "task": "Clip the `hansen_gfc` dataset to the region defined by `argentina`. Store the resulting clipped dataset in the variable `argentina_hansen_gfc_clip`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the Hansen Global Forest Change dataset.\nhansen_gfc = ee.Image('UMD/hansen/global_forest_change_2021_v1_9')\n# Define the region of interest (Argentina).\nargentina = ee.Geometry.Polygon([[[-77.02323123962842, -29.899320425532334], [-77.02323123962842, -50.1076084156841],\n                                [-59.62088748962842, -50.1076084156841], [-59.62088748962842, -29.899320425532334]]], None, False)\n", "functions": ["hansen_gfc.clip"], "external_vars": ["hansen_gfc", "argentina"], "defined_vars": ["argentina_hansen_gfc_clip"], "parameters": ["argentina"], "libraries": ["import geemap", "import ee"]}
{"code": "# Center the map on the geometry\nMap.centerObject(geometry)\n", "task": "Center the object represented by the `geometry` variable on the `Map`.  Make sure you have already defined `geometry` and `Map` before running this code.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the geometry of interest, in this case a rectangle\ngeometry = ee.Geometry.Polygon([[115.81810323928907, -31.94727319521792], [115.81810323928907, -31.98295314826852], [\n                               115.91749517654493, -31.98295314826852], [115.91749517654493, -31.94727319521792]])\n", "functions": ["Map.centerObject"], "external_vars": ["geometry", "Map"], "defined_vars": [], "parameters": ["geometry"], "libraries": ["import geemap", "import ee"]}
{"code": "def func_(img):\n    band = img.multiply(0.0001)\n    ndwi = band.normalizedDifference(['sur_refl_b01','sur_refl_b02']).rename('ndwi')\n    return ndwi\n\nmodis2001 = ee.ImageCollection(\"MODIS/061/MOD09Q1\").select('sur.*').filterDate('2001','2002').map(func_).median()\n\nMap.addLayer(modis2001.clip(roi),{},'ndwi_2001', False)\n", "task": "Define a function called `func_` that takes an image `img` as input. Multiply the image by 0.0001 and store the result in a variable called `band`. Calculate the normalized difference water index (NDWI) using the bands `sur_refl_b01` and `sur_refl_b02` from the `band` variable and store it in a variable called `ndwi`. Rename the NDWI band to \"ndwi\" and return the `ndwi` image. Then, using the `ee` library, load the MODIS 09Q1 collection for the year 2001, select bands that start with \"sur\", and apply the `func_` function to each image in the collection. Calculate the median of the resulting image collection and store it in a variable called `modis2001`. Finally, use the `Map` object to add the `modis2001` image clipped to the `roi` region to the map with the label \"ndwi_2001\" and visibility set to False.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [[44.86557382828752, 37.08659871132482], [46.08505625016252, 37.08659871132482], [46.08505625016252,\n                                                                                        38.34669285754838], [44.86557382828752, 38.34669285754838], [44.86557382828752, 37.08659871132482]]\nroi = ee.Geometry.Polygon(cor)\n", "functions": ["img.multiply", "unknown_function.rename", "band.normalizedDifference", "unknown_function.median", "unknown_function.map", "unknown_function.filterDate", "unknown_function.select", "ee.ImageCollection", "Map.addLayer", "modis2001.clip"], "external_vars": ["ee", "roi", "Map", "func_"], "defined_vars": ["ndwi", "img", "band", "modis2001"], "parameters": [0.0001, "ndwi", "func_", "2001", "2002", "sur.*", "MODIS/061/MOD09Q1", "ndwi_2001", false, "roi", "['sur_refl_b01', 'sur_refl_b02']", "modis2001.clip(roi)", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Compute the slope of the SRTM image.\nslope = ee.Terrain.slope(srtm)\nMap.addLayer(slope, {min: 0, max: 60}, 'slope')\n", "task": "Using the Earth Engine library (ee), calculate the slope of the SRTM elevation data (srtm) and define a variable called `slope` to store the result. Then, add the slope layer to the map (Map) with a minimum value of `min` (0) and a maximum value of `max` (60), labeling the layer \"slope\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the SRTM image and the geometry.\nsrtm = ee.Image('USGS/SRTMGL1_003')\n", "functions": ["ee.Terrain.slope", "Map.addLayer"], "external_vars": ["max", "srtm", "Map", "min", "ee"], "defined_vars": ["slope"], "parameters": ["srtm", "slope", "slope", "{min: 0, max: 60}"], "libraries": ["import geemap", "import ee"]}
{"code": "roi1 = ee.Geometry.Point(cor1)\n", "task": "Define a variable named **roi1** representing a point geometry using the **ee.Geometry.Point** function and the coordinates stored in the variable **cor1**. The variable **ee** should already be defined.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\ncor1 = [52.08596517173183, 26.6366657681643]\n", "functions": ["ee.Geometry.Point"], "external_vars": ["ee", "cor1"], "defined_vars": ["roi1"], "parameters": ["cor1"], "libraries": ["import ee", "import geemap"]}
{"code": "def func5_(img):\n    modis = img.select('modis')\n    landsat = img.select('landsat')\n    cons = ee.Image.constant(1)\n    indep = modis.addBands(cons)\n    dep = landsat\n    return indep.addBands(dep)\n", "task": "Using the Earth Engine library (ee), create a function called `func5_` that takes an image `img` as input.  First, select the bands labeled \"modis\" and \"landsat\" from the input image and assign them to variables `modis` and `landsat`, respectively. Then, create a constant image with value 1 using `ee.Image.constant(1)` and assign it to `cons`.  Add the `cons` image as a band to the `modis` image and assign the result to `indep`.  Finally, add the `dep` (which is the `landsat` image) as a band to `indep` and return the combined image.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["img.select", "img.select", "ee.Image.constant", "modis.addBands", "indep.addBands"], "external_vars": ["ee"], "defined_vars": ["landsat", "indep", "modis", "cons", "img", "dep"], "parameters": ["modis", "landsat", 1, "cons", "dep"], "libraries": ["import geemap", "import ee"]}
{"code": "# Calculate the area of the flooded areas.\nareaFlooded = (\n    ee.Image.pixelArea()\n.updateMask(floods.select(\"Class\"))\n.divide(1e6)\n.reduceRegion(\n        reducer=ee.Reducer.sum(),\n        geometry=region,\n        scale=10,\n        maxPixels=1e13,\n    )\n)\n", "task": "Calculate the area flooded in the given region, taking into account the flood data and the environmental impact (ee). Define the variable `areaFlooded` to store the result.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Define the region of interest.\ngeometry = ee.Geometry.Polygon([[[8.700000466538688, 45.21167860639626], [8.700000466538688, 44.80583871013256], [\n                               9.775287331773063, 44.80583871013256], [9.775287331773063, 45.21167860639626]]])\nregion = geometry\n# Load the Sentinel-1 images.\nbefore = ee.ImageCollection('COPERNICUS/S1_GRD').filterDate('2019-11-13', '2019-11-14').filter(ee.Filter.listContains('transmitterReceiverPolarisation',\n                                                                                                                      'VV')).filter(ee.Filter.eq('instrumentMode', 'IW')).filterMetadata('resolution_meters', 'equals', 10).select('VV').median()\nafter = ee.ImageCollection('COPERNICUS/S1_GRD').filterDate('2019-11-25', '2019-11-26').filter(ee.Filter.listContains('transmitterReceiverPolarisation',\n                                                                                                                     'VV')).filter(ee.Filter.eq('instrumentMode', 'IW')).filterMetadata('resolution_meters', 'equals', 10).select('VV').median()\n# Calculate the changes between the two images.\nChanges = after.subtract(before)\n# Create a categorical image.\ncategorical = ee.Image(1).rename('Class').where(\n    Changes.gt(-10), 1).where(Changes.lt(-10), 2)\n# Create a mask for the flooded areas.\nfloods = categorical.updateMask(categorical.select('Class').eq(2))\n", "functions": ["unknown_function.reduceRegion", "unknown_function.divide", "unknown_function.updateMask", "ee.Image.pixelArea", "floods.select", "ee.Reducer.sum"], "external_vars": ["ee", "floods", "region"], "defined_vars": ["areaFlooded"], "parameters": [1000000.0, "Class", "floods.select('Class')"], "libraries": ["import ee", "import geemap"]}
{"code": "# Center the map on the Chennai ward.\nMap.centerObject(chennai, 8)\n", "task": "Center the object represented by the variable \"chennai\" on the map represented by the variable \"Map\" using the `centerObject` function with a zoom level of 8.  Make sure the variables \"chennai\" and \"Map\" are defined beforehand.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the Ahmedabad wards dataset.\nahmedabad_g = ee.FeatureCollection(\n    'users/ce15btech11022/Metropolitan_Wards/Ahmedabad_Wards')\n# Get the geometry of the Chennai ward.\nchennai = ahmedabad_g.geometry()\n", "functions": ["Map.centerObject"], "external_vars": ["Map", "chennai"], "defined_vars": [], "parameters": ["chennai", 8], "libraries": ["import geemap", "import ee"]}
{"code": "# Import the SRTM 30m resolution image.\nsrtm_30m = ee.Image(\"USGS/SRTMGL1_003\")\nprint(srtm_30m)\n", "task": "Using the Earth Engine library (ee), load the SRTM 30m elevation data, assign it to the variable \"srtm_30m\", and print the image object to the console.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Image", "print"], "external_vars": ["ee", "print"], "defined_vars": ["srtm_30m"], "parameters": ["USGS/SRTMGL1_003", "srtm_30m"], "libraries": ["import ee", "import geemap"]}
{"code": "# Get scale (in meters) information from band 1.\nband1_scale = image.select('O3_column_number_density').projection().nominalScale()\nprint('Band 1 scale: ', band1_scale)  # ee.Number\n", "task": "Using the provided `image` object, extract the nominal scale of the band corresponding to \"O3_column_number_density\". Store the scale in a variable named `band1_scale` and then use the `print` function to display the value of `band1_scale`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load an image from Sentinel 5P Near Rear Time Ozone collection.\nimage = ee.Image('COPERNICUS/S5P/NRTI/L3_O3/20210425T134303_20210425T143314')\n", "functions": ["unknown_function.nominalScale", "unknown_function.projection", "image.select", "print"], "external_vars": ["print", "image"], "defined_vars": ["band1_scale"], "parameters": ["O3_column_number_density", "Band 1 scale: ", "band1_scale"], "libraries": ["import geemap", "import ee"]}
{"code": "# Select a specific date\nera5_mydate = era5.filterDate(\"2019-01-01\")\n", "task": "Using the `era5` object, filter the data for the date \"2019-01-01\" and store the result in the variable `era5_mydate`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Load the ERA5 data\nera5 = ee.ImageCollection('ECMWF/ERA5/DAILY')\n", "functions": ["era5.filterDate"], "external_vars": ["era5"], "defined_vars": ["era5_mydate"], "parameters": ["2019-01-01"], "libraries": ["import ee", "import geemap"]}
{"code": "# Load the Landsat 8.And Sentinel-2 collections\nl8 = ee.ImageCollection(\"LANDSAT/LC08/C01/T1_SR\")\ns2 = ee.ImageCollection(\"COPERNICUS/S2_SR\")\n", "task": "Using the Earth Engine library (ee), define two image collections: \"l8\" for Landsat 8 Collection 1 Tier 1 Surface Reflectance and \"s2\" for Sentinel-2 Surface Reflectance.", "exec_path": "GEE", "context": "from ee import batch\nimport geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection", "ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["l8", "s2"], "parameters": ["LANDSAT/LC08/C01/T1_SR", "COPERNICUS/S2_SR"], "libraries": ["from ee import batch", "import geemap", "import ee"]}
{"code": "# Definir variável Parque do Xingu com o dataset de áreas protegidas do UNEP.\nprqXingu = ee.FeatureCollection('WCMC/WDPA/current/polygons').filter(ee.Filter.eq('NAME', 'Parque do Xingu'))\nMap.addLayer(prqXingu, {}, 'Parque do Xingu')\n", "task": "Using the Earth Engine library (`ee`) and the `Map` object, define a variable named `prqXingu` to represent the Parque do Xingu protected area. Filter the `WCMC/WDPA/current/polygons` feature collection for the feature with the name \"Parque do Xingu\" and assign the result to `prqXingu`. Then, add this layer to the map using the `Map.addLayer` function with an empty dictionary as the visualization parameters and \"Parque do Xingu\" as the layer name.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n", "functions": ["unknown_function.filter", "ee.FeatureCollection", "ee.Filter.eq", "Map.addLayer"], "external_vars": ["ee", "Map"], "defined_vars": ["prqXingu"], "parameters": ["WCMC/WDPA/current/polygons", "NAME", "Parque do Xingu", "prqXingu", "Parque do Xingu", "ee.Filter.eq('NAME', 'Parque do Xingu')", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "def func_(img):\n    index = img.expression('(ndvi - min) / (max - min)',\n  {'ndvi': img.select('NDVI').multiply(0.0001), 'min': ndvi_min, 'max': ndvi_max})\n    return index.rename('VCI').copyProperties(img, img.propertyNames())\n\nvci = ndvi_monthly.map(func_)\n", "task": "Define a function called `func_` that takes an image `img` as input. Inside the function, calculate an index using the expression `(ndvi - min) / (max - min)`, where `ndvi` is the NDVI band of the image multiplied by 0.0001, `min` is `ndvi_min`, and `max` is `ndvi_max`. Rename the index to `VCI` and copy the properties of the input image to the index. Apply the function `func_` to the image collection `ndvi_monthly` and assign the result to a variable named `vci`.  Define the variables `img`, `index`, and `vci` within the function and its scope.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ntime_start = '2001'\ntime_end = '2024'\nndvi = ee.ImageCollection(\n    'MODIS/061/MOD13A2').select('NDVI').filterDate(time_start, time_end)\n# v ci: vegetation condition index\nndvi_min = ndvi.min().multiply(0.0001)\nndvi_max = ndvi.max().multiply(0.0001)\n# temporal collection function\n\n\ndef temporal_collection(collection, start, count, interval, unit):\n    seq = ee.List.sequence(0, ee.Number(count).subtract(1))\n    origin_date = ee.Date(start)\n\n    def func_(i):\n        start_date = origin_date.advance(ee.Number(interval).multiply(i), unit)\n        end_date = origin_date.advance(\n            ee.Number(interval).multiply(ee.Number(i).add(1)), unit)\n        return collection.filterDate(start_date, end_date).mean().set('system:time_start', start_date.millis()).set('system:time_end', end_date.millis())\n    return ee.ImageCollection(seq.map(func_))\n\n\nndvi_monthly = temporal_collection(ndvi, time_start, 276, 1, 'month')\n", "functions": ["img.expression", "unknown_function.multiply", "img.select", "unknown_function.copyProperties", "index.rename", "img.propertyNames", "ndvi_monthly.map"], "external_vars": ["ndvi_min", "ndvi_monthly", "ndvi_max", "func_"], "defined_vars": ["img", "vci", "index"], "parameters": ["(ndvi - min) / (max - min)", 0.0001, "NDVI", "img", "VCI", "func_", "{'ndvi': img.select('NDVI').multiply(0.0001), 'min': ndvi_min, 'max': ndvi_max}", "img.propertyNames()"], "libraries": ["import ee", "import geemap"]}
{"code": "# Set the base map to satellite imagery\nMap.setOptions('SATELLITE')\nMap.centerObject(AOI, 17)\n# Uncomment to display the AOI on the map\n# Map.addLayer(AOI)\n", "task": "Set the map view to satellite imagery and center it on the Area of Interest (AOI) with a zoom level of 17. You need to define the variables `AOI` (representing the geographic area of interest) and `Map` (representing the map object).", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the geometry (Area of Interest)\ncoordinates = [[70.58174517005682, 21.913531643276908], [70.58163318783045, 21.913926678518507], [70.58154467493296, 21.913990443946926], [70.58152589946985, 21.914201958334374], [70.58133646845818, 21.91434286406814], [\n    70.58040037751198, 21.91404176731981], [70.5802297219634, 21.91382278746666], [70.58051940053701, 21.913245164278514], [70.58068636804819, 21.913180776411302], [70.58174517005682, 21.913531643276908]]\nAOI = ee.Geometry.Polygon(coordinates)\n", "functions": ["Map.setOptions", "Map.centerObject"], "external_vars": ["AOI", "Map"], "defined_vars": [], "parameters": ["SATELLITE", "AOI", 17], "libraries": ["import geemap", "import ee"]}
{"code": "# Define a function to mask snow.And clouds\ndef mask_snow_and_clouds(image):\n  summary_qa = image.select('SummaryQA')\n  # Select pixels which are less than or equals to 1 (0 or 1)\n  qa_mask = bitwise_extract(summary_qa, 0, 1).lte(1)\n  masked_image = image.updateMask(qa_mask)\n  return masked_image.copyProperties(image, ['system:index', 'system:time_start'])\n", "task": "Create a function called `mask_snow_and_clouds` that takes an image as input and returns a masked version of the image. The function should use the `bitwise_extract` function to extract the SummaryQA band from the input image. Then, it should create a mask using the `lte` function, which checks if the extracted band is less than or equal to 1. This mask will be applied to the image using the `updateMask` function. Finally, the function should return the masked image with its `system:index` and `system:time_start` properties copied from the original image. Make sure to define the following variables: `qa_mask`, `masked_image`, `image`, and `summary_qa`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define a function to extract bits from an image\n\n\ndef bitwise_extract(image, from_bit, to_bit):\n    mask_size = ee.Number(1).add(to_bit).subtract(from_bit)\n    mask = ee.Number(1).leftShift(mask_size).subtract(1)\n    return image.rightShift(from_bit).bitwiseAnd(mask)\n", "functions": ["image.select", "unknown_function.lte", "bitwise_extract", "image.updateMask", "masked_image.copyProperties"], "external_vars": ["bitwise_extract"], "defined_vars": ["summary_qa", "image", "masked_image", "qa_mask"], "parameters": ["SummaryQA", 1, "summary_qa", 0, 1, "qa_mask", "image", "['system:index', 'system:time_start']"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the geometry (point)\ngeometry = ee.Geometry.Point([103.08836120221319, 5.408336927461861])\n# Center the map on the geometry with a zoom level of 10\nMap.centerObject(geometry, 10)\n", "task": "Using the Earth Engine library (`ee`) and the Google Earth Engine Map (`Map`), create a point geometry object named `geometry` at the coordinates [103.08836120221319, 5.408336927461861] and center the map on this point with a zoom level of 10.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n", "functions": ["ee.Geometry.Point", "Map.centerObject"], "external_vars": ["ee", "Map"], "defined_vars": ["geometry"], "parameters": ["geometry", 10, "[103.08836120221319, 5.408336927461861]"], "libraries": ["import geemap", "import ee"]}
{"code": "# Improve the palette by adding blue-white-green.And Add to the map.And \nndviz = {'bands': ['NDVI'], 'min': -1, 'max': 1, 'palette': ['blue','white', 'green']}\nMap.addLayer(ndvi_renamed, ndviz, 'NDVI with Improved Palette')\n", "task": "Define a variable named `ndviz` with the following parameters: `bands`: `['NDVI']`, `min`: `-1`, `max`: `1`, `palette`: `['blue', 'white', 'green']`. Then, add the layer `ndvi_renamed` to the `Map` using the defined `ndviz` parameters and label it \"NDVI with Improved Palette\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\nSelangor = ee.FeatureCollection(\n    'FAO/GAUL/2015/level1').filter(ee.Filter.eq('ADM1_NAME', 'Selangor'))\n# Get Landsat8 collection and filter it as in previous lab\nFiltered = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterBounds(\n    Selangor).filterDate('2020-06-01', '2020-12-31').sort('CLOUD_COVER')\n# Composite median\nCompositeMedian = Filtered.median()\n# Calculate NDVI from the median composite (CompositeMedian) using .normalizedDifference\nndvi = CompositeMedian.normalizedDifference(['SR_B5', 'SR_B4'])\nndvi_renamed = ndvi.rename('NDVI')\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "ndvi_renamed"], "defined_vars": ["ndviz"], "parameters": ["ndvi_renamed", "ndviz", "NDVI with Improved Palette"], "libraries": ["import geemap", "import ee"]}
{"code": "landsat8 = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_L2\").select('SR_B.*').filterDate('2013','2024').filterBounds(roi).filter(ee.Filter.lt('CLOUD_COVER',45)).filter(ee.Filter.eq('WRS_PATH', 165)).filter(ee.Filter.eq('WRS_ROW', 38)).map(ndvi_oli)\n", "task": "Using the Earth Engine library (`ee`), define a variable called `landsat8` that represents an ImageCollection of Landsat 8 data (collection ID: `LANDSAT/LC08/C02/T1_L2`). Filter the collection to include images from 2013 to 2024 that fall within the `roi` region, have cloud cover less than 45%, are within path 165 and row 38, and apply the `ndvi_oli` function to each image. This will be used for further analysis.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [[48.62559911358055, 31.65418476680761], [48.91124364483055, 31.65418476680761], [48.91124364483055,\n                                                                                        31.885355756064595], [48.62559911358055, 31.885355756064595], [48.62559911358055, 31.65418476680761]]\nroi = ee.Geometry.Polygon(cor)\n\n\ndef ndvi_oli(img):\n    bands = img.multiply(2.75e-05).add(-0.2)\n    ndvi = bands.normalizedDifference(['SR_B5', 'SR_B4']).rename('ndvi')\n    return ndvi.copyProperties(img, img.propertyNames())\n", "functions": ["unknown_function.map", "unknown_function.filter", "unknown_function.filter", "unknown_function.filter", "unknown_function.filterBounds", "unknown_function.filterDate", "unknown_function.select", "ee.ImageCollection", "ee.Filter.lt", "ee.Filter.eq", "ee.Filter.eq"], "external_vars": ["ee", "ndvi_oli", "roi"], "defined_vars": ["landsat8"], "parameters": ["ndvi_oli", "roi", "2013", "2024", "SR_B.*", "LANDSAT/LC08/C02/T1_L2", "CLOUD_COVER", 45, "WRS_PATH", 165, "WRS_ROW", 38, "ee.Filter.eq('WRS_ROW', 38)", "ee.Filter.eq('WRS_PATH', 165)", "ee.Filter.lt('CLOUD_COVER', 45)"], "libraries": ["import ee", "import geemap"]}
{"code": "Map.addLayer(change.clip(roi),{},'coastline_change',False)\n", "task": "Add a layer to the map named \"coastline_change\" displaying the clipped change data within the region of interest (roi). The layer should be added with no additional styling options. Make sure to define the following variables: `roi`, `change`, `Map`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ncor = [[44.9080614872616, 37.10065044621631], [46.1220507450741, 37.10065044621631], [46.1220507450741,\n                                                                                      38.343276286611825], [44.9080614872616, 38.343276286611825], [44.9080614872616, 37.10065044621631]]\nroi = ee.Geometry.Polygon(cor)\n# calculate ndwi median for each date\n\n\ndef func_(img):\n    bands = img.select('sur.*').multiply(0.0001)\n    ndwi = bands.normalizedDifference(\n        ['sur_refl_b01', 'sur_refl_b02']).rename('ndwi')\n    return ndwi\n\n\nmod2001 = ee.ImageCollection(\n    'MODIS/061/MOD09Q1').filterDate('2001', '2002').map(func_).median().gt(0.1)\nmod2023 = ee.ImageCollection(\n    'MODIS/061/MOD09Q1').filterDate('2023', '2024').map(func_).median().gt(0.1)\n# change detection using subtraction\nchange = mod2001.subtract(mod2023)\n", "functions": ["Map.addLayer", "change.clip"], "external_vars": ["change", "Map", "roi"], "defined_vars": [], "parameters": ["coastline_change", false, "roi", "change.clip(roi)", "{}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Clip the study area to the Sunraysia region.\nstudyArea_clipped = studyArea.clip(Sunraysia)\n", "task": "Clip the `studyArea` using the `Sunraysia` object and store the result in a new variable called `studyArea_clipped`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the Sunraysia region of interest.\nSunraysia = ee.Geometry.Polygon([[140.24252010057364, -33.878291364895354], [140.24252010057364, -34.70087292355624], [\n                                142.49471736619864, -34.70087292355624], [142.49471736619864, -33.878291364895354]])\n# Load the Sentinel-2 Level 2A image collection.\ns2l2a = ee.ImageCollection('COPERNICUS/S2_SR')\n# Filter the image collection by date and cloud cover.\nstudyArea = s2l2a.filterBounds(Sunraysia).filterDate(\n    '2020-01-01', '2021-11-30').filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10)).mean()\n", "functions": ["studyArea.clip"], "external_vars": ["Sunraysia", "studyArea"], "defined_vars": ["studyArea_clipped"], "parameters": ["Sunraysia"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the aspect layer to the map.\nMap.addLayer(aspect, {}, \"custom visualization\")\n\n\n", "task": "Add a new layer to the Map object called \"custom visualization\" using the aspect variable. This layer should have no additional styling options.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Load the SRTM90 DEM image.\nimage = ee.Image('CGIAR/SRTM90_V4')\n# Calculate the aspect of the DEM.\naspect = ee.Terrain.aspect(image)\n", "functions": ["Map.addLayer"], "external_vars": ["aspect", "Map"], "defined_vars": [], "parameters": ["aspect", "custom visualization", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "# #################################################################\n#                            GETTING THE RANDOM 500 POINTS\n# #################################################################\n# Get the 500 random points shapefile\nrandom_500_1hapoints_mcd64_2007_2010_noalos = ee.FeatureCollection(\"users/Chiquitania/random_500_1hapoints_MCD64_2007_2010_noALOS\")\n", "task": "Using the Earth Engine library (ee), define a variable called `random_500_1hapoints_mcd64_2007_2010_noalos` that represents a FeatureCollection loaded from the asset `users/Chiquitania/random_500_1hapoints_MCD64_2007_2010_noALOS`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.FeatureCollection"], "external_vars": ["ee"], "defined_vars": ["random_500_1hapoints_mcd64_2007_2010_noalos"], "parameters": ["users/Chiquitania/random_500_1hapoints_MCD64_2007_2010_noALOS"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the raw NAIP image collection.\nraw_naip = ee.ImageCollection(\"USDA/NAIP/DOQQ\")\n", "task": "Using the Earth Engine library (ee), load the USDA National Agriculture Imagery Program (NAIP) data collection and assign it to the variable `raw_naip`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["raw_naip"], "parameters": ["USDA/NAIP/DOQQ"], "libraries": ["import geemap", "import ee"]}
{"code": "# Compute the NBR image\nnir = m.select('B4')\nswir = m.select('B7')\nnbr = nir.subtract(swir).divide(nir.add(swir)).rename('NBR')\n", "task": "Using the dataframe `m`, select the column \"B4\" and assign it to the variable `nir`. Then, select the column \"B7\" and assign it to the variable `swir`. Calculate the difference between `nir` and `swir`, divide it by the sum of `nir` and `swir`, and assign the result to a new variable named `nbr`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the Thailand PA feature collection\ncountry = ee.FeatureCollection('USDOS/LSIB/2013')\npa = country.filter(ee.Filter.eq('cc', 'TH'))\n# Load a Landsat 5 collection\ncollection = ee.ImageCollection('LANDSAT/LT05/C02/T1').filter(ee.Filter.lt(\n    'CLOUD_COVER', 0.6)).filterBounds(pa).filterDate('2004-01-01', '2004-12-31')\n# Compute minimum statistics from the image collection\nm = collection.median()\n", "functions": ["m.select", "m.select", "unknown_function.rename", "unknown_function.divide", "nir.subtract", "nir.add"], "external_vars": ["m"], "defined_vars": ["swir", "nir", "nbr"], "parameters": ["B4", "B7", "NBR", "swir", "swir", "nir.add(swir)"], "libraries": ["import geemap", "import ee"]}
{"code": "# Create a single composite image\ncomposite = l7collection.median().clip(Bound_geom)\n", "task": "Calculate the median of the `l7collection` and clip the result to the bounding geometry `Bound_geom`. Store the result in a variable named `composite`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Define the bounding geometry for the area of interest\nBound_geom = ee.Geometry.Polygon([[[-93.11310959151902, 18.112334929829487], [-93.11310959151902, 17.86416393364247],\n                                 [-92.74781418136277, 17.86416393364247], [-92.74781418136277, 18.112334929829487]]], None, False)\n# Load the Landsat collection\nl7collection = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR').filterBounds(\n    Bound_geom).filterMetadata('CLOUD_COVER', 'less_than', 4).filterDate('1989-01-01', '1991-12-31')\n", "functions": ["unknown_function.clip", "l7collection.median"], "external_vars": ["Bound_geom", "l7collection"], "defined_vars": ["composite"], "parameters": ["Bound_geom"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the country of interest.\ncountry_name = 'Uzbekistan'\ncountry = countries.filterMetadata('NAME', 'Contains', country_name)\n", "task": "Define a variable called `country_name` and assign it the string \"Uzbekistan\". Then, use the `countries` variable (which is assumed to be an object with a `filterMetadata` method) to filter for countries whose name contains the value of `country_name`, and assign the resulting filtered data to a variable called `country`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the Natural Earth country boundaries dataset.\ncountries = ee.FeatureCollection(\n    'users/soneruereyen/NaturalEarth_country_boundaries')\n", "functions": ["countries.filterMetadata"], "external_vars": ["countries"], "defined_vars": ["country", "country_name"], "parameters": ["NAME", "Contains", "country_name"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define a bounding box\nbbox = ee.Geometry.BBox(-1, 5, 1, 7)\n", "task": "Using the Earth Engine library (ee), define a bounding box named `bbox` with coordinates (-1, 5) for the lower left corner and (1, 7) for the upper right corner.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Define the input geometries\ngeometry = ee.Geometry.Point([-2.481398773193373, 6.822477794917577])\n", "functions": ["ee.Geometry.BBox"], "external_vars": ["ee"], "defined_vars": ["bbox"], "parameters": [5, 1, 7, "-1"], "libraries": ["import ee", "import geemap"]}
{"code": "# Import image collection.\nera5_complete = ee.ImageCollection(\"ECMWF/ERA5/MONTHLY\")\n", "task": "Using the Earth Engine library (`ee`), define a variable named `era5_complete` and assign it to an Earth Engine ImageCollection object representing the entire ECMWF ERA5 monthly dataset.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["era5_complete"], "parameters": ["ECMWF/ERA5/MONTHLY"], "libraries": ["import geemap", "import ee"]}
{"code": "# Compute the median composite of the collection.\nS2_median = S2.median()\n", "task": "Calculate the median of the values in the series `S2` and store it in a new variable called `S2_median`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the cloud masking function.\n\n\ndef cloudmask(image):\n    return ee.Image(image).clip(AOI).select(['B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B11', 'B12']).addBands(image.select('QA60'))\n# Define the function to add the albedo band to the image.\n\n\ndef add_albedo(image):\n    albedo = image.expression('((0.1836 * Blue) + (0.1759 * Green) + (0.1456 * Red) + (0.1347 * RedEdge1) + (0.1233 * RedEdge2) + (0.1134 * RedEdge3) + (0.1001 * NIR) +  (0.0231* SWIR1) + (0.0003 * SWIR2))', {'Blue': image.select('B2'), 'Green': image.select(\n        'B3'), 'Red': image.select('B4'), 'RedEdge1': image.select('B5'), 'RedEdge2': image.select('B6'), 'RedEdge3': image.select('B7'), 'NIR': image.select('B8'), 'SWIR1': image.select('B11'), 'SWIR2': image.select('B12')}).rename('albedo')\n    return image.addBands(albedo)\n\n\n# Define the start and end dates for the image collection.\nSTART_DATE = '2020-02-01'\nEND_DATE = '2020-03-01'\n# Define the region of interest.\nAOI = ee.Geometry.Polygon([[[-3.6986687010466013, 37.21688213750424], [-3.6986687010466013, 36.86830941857497],\n                          [-2.5135185545622263, 36.86830941857497], [-2.5135185545622263, 37.21688213750424]]])\n# Get the Sentinel-2 SR collection.\nS2 = ee.ImageCollection('COPERNICUS/S2_SR').filterDate(START_DATE,\n                                                       END_DATE).filterBounds(AOI).map(cloudmask).map(add_albedo)\n", "functions": ["S2.median"], "external_vars": ["S2"], "defined_vars": ["S2_median"], "parameters": [], "libraries": ["import geemap", "import ee"]}
{"code": "Map.addLayer(aot_max,{'palette':['black','red']},'aot_max',False)\n", "task": "Add a layer to the map named \"aot_max\" using the `aot_max` variable, with a palette of \"black\" and \"red\". Set the layer visibility to `False`. You need to define the following variables: `Map`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\naot = ee.ImageCollection('NASA/GSFC/MERRA/aer/2').select('DUSCATAU').filterDate(\n    '2020', '2021').filter(ee.Filter.calendarRange(12, 12, 'hour'))\naot_max = aot.max()\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "aot_max"], "defined_vars": [], "parameters": ["aot_max", "aot_max", false, "{'palette': ['black', 'red']}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Calculate the Normalized Difference Vegetation Index (NDVI).\nndvi = image.normalizedDifference(['B5', 'B4'])\n", "task": "Calculate the Normalized Difference Vegetation Index (NDVI) using the provided image object. Define a new variable named \"ndvi\" and assign the result of the normalized difference calculation between bands \"B5\" and \"B4\" to it.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Import the Landsat 8 collection.\nL8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n# Define the geometry of the area of interest.\ngeometry = ee.Geometry.Point([-2.1832785610535965, 12.101696637755918])\n# Filter the collection by date and geometry.\nfiltered = L8.filterDate('2021-05-01', '2021-08-15').filterBounds(geometry)\n# Get the first image in the filtered collection.\nimage = filtered.first()\n", "functions": ["image.normalizedDifference"], "external_vars": ["image"], "defined_vars": ["ndvi"], "parameters": ["['B5', 'B4']"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the SRTM DEM image.\nsrtm = ee.Image(\"CGIAR/SRTM90_V4\")\n", "task": "Using the Earth Engine library (`ee`), import the SRTM90_V4 dataset and assign it to the variable `srtm`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["srtm"], "parameters": ["CGIAR/SRTM90_V4"], "libraries": ["import geemap", "import ee"]}
{"code": "# Generate combined DEM + Slope + Aspect + Hillshade products.\ntopography = ee.Terrain.products(srtm)\n", "task": "Using the Earth Engine library (ee) and the SRTM elevation data (srtm), define a variable named \"topography\" to store the terrain products.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the SRTM DEM image.\nsrtm = ee.Image('CGIAR/SRTM90_V4')\n", "functions": ["ee.Terrain.products"], "external_vars": ["ee", "srtm"], "defined_vars": ["topography"], "parameters": ["srtm"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the ROI to the map\nMap.addLayer(roi, {}, \"Region of Interest\")\n", "task": "Add a layer to the map named \"Region of Interest\" representing the given region of interest (roi). Make sure the Map and roi variables are defined before running this code.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the region of interest (ROI) as a polygon\nroi = ee.Geometry.Polygon([[-0.7150612887152907, 51.876572902736974], [-0.7150612887152907, 51.12946730062637],\n                          [0.47970189487847925, 51.12946730062637], [0.47970189487847925, 51.876572902736974]])\n", "functions": ["Map.addLayer"], "external_vars": ["roi", "Map"], "defined_vars": [], "parameters": ["roi", "Region of Interest", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Display the least cloudy image.\nMap.addLayer(least_cloudy_image, {}, 'Least Cloudy Image')\n", "task": "Add the `least_cloudy_image` to the `Map` as a layer named \"Least Cloudy Image\".  You will need to define the variables `Map` and `least_cloudy_image` before executing this code.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the point of interest.\npoint = ee.Geometry.Point([-41.45931791095892, -12.590869262752728])\n# Filter the Landsat 8 collection by the point and time range.\nl8_collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\nspatial_filtered = l8_collection.filterBounds(point)\ntemporal_filtered = spatial_filtered.filterDate('2015-01-01', '2015-12-31')\n# Sort the images from least to most cloudy.\nsorted_collection = temporal_filtered.sort('CLOUD_COVER')\n# Get the least cloudy image.\nleast_cloudy_image = sorted_collection.first()\n", "functions": ["Map.addLayer"], "external_vars": ["least_cloudy_image", "Map"], "defined_vars": [], "parameters": ["least_cloudy_image", "Least Cloudy Image", "{}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the Sentinel-2 image collection\ns2 = ee.ImageCollection(\"COPERNICUS/S2\")\n", "task": "Using the Earth Engine library (ee), load the Sentinel-2 image collection and store it in a variable named s2.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["s2"], "parameters": ["COPERNICUS/S2"], "libraries": ["import ee", "import geemap"]}
{"code": "# Load the MODIS Terra 8-day land surface temperature (LST) dataset. Filter for the date range June-August 2019. Select the layer with daytime LST values.\ntempMOD_19 = ee.ImageCollection(\"MODIS/006/MOD11A2\").filterDate('2019-06-01', '2019-09-01').select('LST_Day_1km');\nprint(\"Summer month mean 8-day mean temperatures 2019:\", tempMOD_19)\n", "task": "Using the `ee` library, load the MODIS Terra Land Surface Temperature 8-day product (MOD11A2) for June 1st to September 1st, 2019. Select the LST_Day_1km band and store the resulting image collection in a variable called `tempMOD_19`. Then, use the `print` function to display the `tempMOD_19` variable.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["unknown_function.select", "unknown_function.filterDate", "ee.ImageCollection", "print"], "external_vars": ["ee", "print"], "defined_vars": ["tempMOD_19"], "parameters": ["LST_Day_1km", "2019-06-01", "2019-09-01", "MODIS/006/MOD11A2", "Summer month mean 8-day mean temperatures 2019:", "tempMOD_19"], "libraries": ["import geemap", "import ee"]}
{"code": "# Filter the image collection by date.And cloud cover.\nstudyArea = s2l2a.filterBounds(Sunraysia) .filterDate('2020-01-01', '2021-11-30') .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10)) .mean()\n", "task": "Using the provided variables `s2l2a`, `Sunraysia`, and `ee`, define a variable named `studyArea` by filtering the `s2l2a` dataset to include data within the bounds of `Sunraysia`, between the dates `2020-01-01` and `2021-11-30`, and with a `CLOUDY_PIXEL_PERCENTAGE` less than 10. Then calculate the mean of the filtered dataset.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the Sunraysia region of interest.\nSunraysia = ee.Geometry.Polygon([[140.24252010057364, -33.878291364895354], [140.24252010057364, -34.70087292355624], [\n                                142.49471736619864, -34.70087292355624], [142.49471736619864, -33.878291364895354]])\n# Load the Sentinel-2 Level 2A image collection.\ns2l2a = ee.ImageCollection('COPERNICUS/S2_SR')\n", "functions": ["unknown_function.mean", "unknown_function.filter", "unknown_function.filterDate", "s2l2a.filterBounds", "ee.Filter.lt"], "external_vars": ["s2l2a", "Sunraysia", "ee"], "defined_vars": ["studyArea"], "parameters": ["2020-01-01", "2021-11-30", "Sunraysia", "CLOUDY_PIXEL_PERCENTAGE", 10, "ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10)"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the polygon of interest\ngeometry = ee.Geometry.MultiPoint()  # Start with an empty geometry\ngeometry2 = ee.Geometry.Polygon([\n    [[-97.626953125, 36.36377812021711],\n     [-98.59375, 35.64338283540844],\n     [-104.16748046875, 24.82006926739896],\n     [-93.06640625, 18.42783531614582],\n     [-80.72265625, 20.591126064534558],\n     [-73.486328125, 19.8346446389986],\n     [-69.8828125, 18.466704340928396],\n     [-66.89453125, 17.05220263825414],\n     [-64.35546875, 17.181637528663432],\n     [-60.634765625, 20.208892854469138],\n     [-62.65625, 23.437570166994498],\n     [-75.234375, 26.15173896623708],\n     [-94.130859375, 34.20827701981127]]])\n", "task": "Using the ee library, define two geometric objects: `geometry` as a MultiPoint and `geometry2` as a Polygon. The coordinates for the polygon are provided.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Geometry.MultiPoint", "ee.Geometry.Polygon"], "external_vars": ["ee"], "defined_vars": ["geometry", "geometry2"], "parameters": ["[[[-97.626953125, 36.36377812021711], [-98.59375, 35.64338283540844], [-104.16748046875, 24.82006926739896], [-93.06640625, 18.42783531614582], [-80.72265625, 20.591126064534556], [-73.486328125, 19.8346446389986], [-69.8828125, 18.466704340928395], [-66.89453125, 17.05220263825414], [-64.35546875, 17.181637528663433], [-60.634765625, 20.208892854469138], [-62.65625, 23.437570166994497], [-75.234375, 26.15173896623708], [-94.130859375, 34.20827701981127]]]"], "libraries": ["import ee", "import geemap"]}
{"code": "# Load the Landsat 8 collection and filter it by date and geometry.\ncomposite = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_TOA\") .filterDate('2015-02-01', '2015-09-01') .filterBounds(geometry) .map(add_ndvi) .qualityMosaic('ndvi')\n", "task": "Using the Earth Engine library (`ee`), create an image collection named `composite` from the Landsat 8 Collection 2 TOA data (`LANDSAT/LC08/C02/T1_TOA`). Filter the collection to include data from February 1st, 2015 to September 1st, 2015 and only within the specified `geometry`. Apply the `add_ndvi` function to each image in the collection and then create a quality mosaic based on the `ndvi` band, naming the mosaic `composite`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the geometry of the region of interest.\ngeometry = ee.Geometry.Polygon([[-72.79833268778783, -12.79955106647952], [-72.79833268778783, -14.124393053355513],\n                               [-70.57909440653783, -14.124393053355513], [-70.57909440653783, -12.79955106647952]])\n# Define a function to add the NDVI band to an image.\n\n\ndef add_ndvi(image):\n    return image.addBands(image.normalizedDifference(['B5', 'B4']).rename('ndvi'))\n", "functions": ["unknown_function.qualityMosaic", "unknown_function.map", "unknown_function.filterBounds", "unknown_function.filterDate", "ee.ImageCollection"], "external_vars": ["ee", "geometry", "add_ndvi"], "defined_vars": ["composite"], "parameters": ["ndvi", "add_ndvi", "geometry", "2015-02-01", "2015-09-01", "LANDSAT/LC08/C02/T1_TOA"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add the DEM to the map.\nMap.addLayer(DEM)\n", "task": "Add the Digital Elevation Model (DEM) layer to the Map object. This requires the following variables to be defined: [DEM, Map]", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Add the Shuttle Radar Topography Mission (SRTM) Digital Elevation Model (DEM) to the map.\nDEM = ee.Image('USGS/SRTMGL1_003')\n", "functions": ["Map.addLayer"], "external_vars": ["DEM", "Map"], "defined_vars": [], "parameters": ["DEM"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the region of interest.\nregion = ee.Geometry.Polygon([\n    [[80.00572880873028, 13.274754435874124],\n      [80.00544985899273, 13.274749214792516],\n      [80.00545187859075, 13.274484752924272],\n      [80.00573149888055, 13.274486710832019]]])\n", "task": "Using the ee library, define a variable named \"region\" as a polygon with the following coordinates: [[80.00572880873028, 13.274754435874124], [80.00544985899273, 13.274749214792516], [80.00545187859075, 13.274484752924272], [80.00573149888055, 13.274486710832019]]", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee"], "defined_vars": ["region"], "parameters": ["[[[80.00572880873028, 13.274754435874124], [80.00544985899273, 13.274749214792516], [80.00545187859075, 13.274484752924272], [80.00573149888055, 13.274486710832019]]]"], "libraries": ["import ee", "import geemap"]}
{"code": "# Print the names of the Sentinel-2 satellites.\nprint('s2', s2.aggregate_array('SPACECRAFT_NAME'))\n", "task": "Print the label \"s2\" and the aggregated array of SPACECRAFT_NAME from the variable s2, which is assumed to be a Spark DataFrame or similar object. Make sure that \"print\" and \"s2\" are defined in the code environment. You may need to define the following variables: [].", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the region of interest (ROI).\ngeometry_1 = ee.Geometry.Polygon([[[102.5169909562906, 5.913869905077349], [102.3851550187906, 5.717133871434274], [102.4400866594156, 4.995207095254813], [\n                                 102.7257311906656, 4.699637539840421], [103.5497058000406, 3.8670161318123597], [103.6815417375406, 4.721535977369975], [103.3519518937906, 5.782720179885445]]])\n# Define the start and end dates for the Sentinel-2 data.\nstartDate = '2021-01-01'\nendDate = '2021-12-31'\n# Load the Sentinel-2 data.\ns2 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED').filterBounds(geometry_1).filterDate(\n    startDate, endDate).filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 20))\n", "functions": ["print", "s2.aggregate_array"], "external_vars": ["print", "s2"], "defined_vars": [], "parameters": ["s2", "SPACECRAFT_NAME", "s2.aggregate_array('SPACECRAFT_NAME')"], "libraries": ["import geemap", "import ee"]}
{"code": "# #################################################################\n# GETTING THE RANDOM 500 POINTS\n# #################################################################\n# Get the 500 random points shapefile\nRandom_pts_ft = ee.FeatureCollection(\"users/Chiquitania/500_random_points_MCD64_2010\")\n# Convert the shapefile table into an actual geometry\nRandom_pts = Random_pts_ft.geometry()\n", "task": "Using the ee library, define a variable named \"Random_pts_ft\" as an ee.FeatureCollection object loaded from \"users/Chiquitania/500_random_points_MCD64_2010\". Then, define another variable named \"Random_pts\" by extracting the geometries from the \"Random_pts_ft\" feature collection.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.FeatureCollection", "Random_pts_ft.geometry"], "external_vars": ["ee"], "defined_vars": ["Random_pts", "Random_pts_ft"], "parameters": ["users/Chiquitania/500_random_points_MCD64_2010"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the input DEM dataset.\ndataset = ee.ImageCollection('AU/GA/AUSTRALIA_5M_DEM')\n", "task": "Using the Earth Engine library (`ee`), load the \"AU/GA/AUSTRALIA_5M_DEM\" image collection and assign it to the variable `dataset`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["dataset"], "parameters": ["AU/GA/AUSTRALIA_5M_DEM"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the output geographic region of interest (ROI)\noutput_geom = ee.Geometry.Rectangle([91.17, 22.35, 91.56, 22.172])\n", "task": "Define a variable called `output_geom` using the `ee.Geometry.Rectangle` function with coordinates [91.17, 22.35, 91.56, 22.172].", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Geometry.Rectangle"], "external_vars": ["ee"], "defined_vars": ["output_geom"], "parameters": ["[91.17, 22.35, 91.56, 22.172]"], "libraries": ["import geemap", "import ee"]}
{"code": "ndwi = sen.normalizedDifference(['B3','B8']).rename('ndwi')\n", "task": "Calculate the Normalized Difference Water Index (NDWI) using the provided Sentinel-2 image data (`sen`) and store the result in a new variable named `ndwi`. Use bands B3 (green) and B8 (NIR) for the calculation.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\ncor = [[48.69819149851601, 29.554928660523107], [49.91767392039101, 29.554928660523107], [49.91767392039101,\n                                                                                          30.671567766536796], [48.69819149851601, 30.671567766536796], [48.69819149851601, 29.554928660523107]]\nroi = ee.Geometry.Polygon(cor)\n# sentinel-2 images\nsen = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED').select(['B[2-4]', 'B8']).filterDate(\n    '2023', '2024').filterBounds(roi).filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10)).median().multiply(0.0001)\n", "functions": ["unknown_function.rename", "sen.normalizedDifference"], "external_vars": ["sen"], "defined_vars": ["ndwi"], "parameters": ["ndwi", "['B3', 'B8']"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the region of interest for Tasmania.\nswTas = ee.Geometry.Polygon(\n        [[[145.08104291178103, -41.94413902699283],\n          [145.08104291178103, -43.72840667789246],\n          [147.40465131021853, -43.72840667789246],\n          [147.40465131021853, -41.94413902699283]]])\n", "task": "Define a variable called `swTas` using the `ee.Geometry.Polygon` function from the `ee` module. The polygon should be defined using the following coordinates: [[[145.08104291178103, -41.94413902699283], [145.08104291178103, -43.72840667789246], [147.40465131021853, -43.72840667789246], [147.40465131021853, -41.94413902699283]]]", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee"], "defined_vars": ["swTas"], "parameters": ["[[[145.08104291178103, -41.94413902699283], [145.08104291178103, -43.72840667789246], [147.40465131021853, -43.72840667789246], [147.40465131021853, -41.94413902699283]]]"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the geomorphic zonation to the map\nMap.addLayer(geomorphic_zonation, {}, \"Geomorphic zonation map\")\n", "task": "Add the \"geomorphic_zonation\" layer to the \"Map\" object, with an empty style object and the label \"Geomorphic zonation map\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the dataset\ndataset = ee.Image('ACA/reef_habitat/v1_0')\n# Extract the geomorphic zonation from the dataset\ngeomorphic_zonation = dataset.select('geomorphic').selfMask()\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "geomorphic_zonation"], "defined_vars": [], "parameters": ["geomorphic_zonation", "Geomorphic zonation map", "{}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the Landsat 8 collection.\ncollection = ee.ImageCollection(\"LANDSAT/LC8_L1T_TOA\")\n", "task": "Using the Earth Engine library (ee), create an ImageCollection named \"collection\" from the Landsat 8 surface reflectance data.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["collection"], "parameters": ["LANDSAT/LC8_L1T_TOA"], "libraries": ["import geemap", "import ee"]}
{"code": "# Print the number of images in the collection.\nprint('Total number of images:', landsat8.size())\n", "task": "Print the total number of images in the `landsat8` dataset.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the Louisiana boundary.\nlouisiana = ee.FeatureCollection(\n    'TIGER/2018/States').filter(ee.Filter.equals('NAME', 'Louisiana'))\n# Define the time period for the analysis.\nstartDate = '2019-01-01'\nendDate = '2019-12-31'\n# Load and filter the Landsat 8 collection.\nlandsat8 = ee.ImageCollection(\n    'LANDSAT/LC08/C02/T1_TOA').filterBounds(louisiana).filterDate(startDate, endDate)\n", "functions": ["print", "landsat8.size"], "external_vars": ["print", "landsat8"], "defined_vars": [], "parameters": ["Total number of images:", "landsat8.size()"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the Dona Ana county geometry to the map.\nMap.addLayer(dona_ana.style(color='yellow'))\n", "task": "Add a layer to the map named \"dona_ana\" styled with a yellow color. Make sure the variables \"dona_ana\" and \"Map\" are defined before running this code.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Load the TIGER counties feature collection.\ncounties = ee.FeatureCollection('TIGER/2018/Counties')\n# Filter the counties by the NAME metadata property.\ndona_ana = counties.filterMetadata('NAME', 'equals', 'Doña Ana')\n", "functions": ["Map.addLayer", "dona_ana.style"], "external_vars": ["Map", "dona_ana"], "defined_vars": [], "parameters": ["dona_ana.style(color='yellow')"], "libraries": ["import ee", "import geemap"]}
{"code": "Map.addLayer(increase_trend,{},'increase_trend',False)\n", "task": "Add a layer to the map named \"increase_trend\" using the data from the variable `increase_trend`. Set the layer options to an empty dictionary and make it visible. You will need to define the following variables: `increase_trend`, `Map`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\nera5 = ee.ImageCollection('ECMWF/ERA5_LAND/MONTHLY_AGGR').select('snow.*')\nsnow_change = era5.select('snow_cover').reduce(\n    ee.Reducer.kendallsCorrelation()).select('snow_cover_tau')\nincrease_trend = snow_change.gt(0)\n", "functions": ["Map.addLayer"], "external_vars": ["increase_trend", "Map"], "defined_vars": [], "parameters": ["increase_trend", "increase_trend", false, "{}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the NDVI as a layer to the map with the custom palette.\nMap.addLayer(SentNDVI, {'palette': palette, 'min': 0, 'max': 0.8}, 'Sent2NDVIpalette')\n\n\n", "task": "Add the NDVI layer \"SentNDVI\" to the map \"Map\" using the color palette \"palette\". Set the minimum value to 0 and the maximum value to 0.8. Name the layer \"Sent2NDVIpalette\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the buffer geometry.\nbuffer = ee.Geometry.Polygon([[[-122.50940483747485, 37.644236681307106], [-122.39816826520922, 37.564814296553855], [-122.32675713239672, 37.56045993487149], [-122.0287529820061, 37.66054584536868],\n                             [-122.22238701520922, 37.91667147969052], [-122.34049004255297, 37.91233776572774], [-122.35422295270922, 37.84730142489402], [-122.55197685895922, 37.79740134848523]]])\n# Define the Sentinel-2 image collection.\nSent2 = ee.ImageCollection('COPERNICUS/S2').filterDate('2016-04-01',\n                                                       '2016-08-01').filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 5))\n# Calculate the NDVI from the median Sentinel-2 image.\nSentNDVI = Sent2.median().clip(buffer).normalizedDifference(['B8', 'B4'])\n# Define a color palette for the NDVI.\npalette = ['FFFFFF', 'CE7E45', 'DF923D', 'F1B555', 'FCD163', '99B718', '74A901', '66A000',\n           '529400', '3E8601', '207401', '056201', '004C00', '023B01', '012E01', '011D01', '011301']\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "SentNDVI", "palette"], "defined_vars": [], "parameters": ["SentNDVI", "Sent2NDVIpalette", "{'palette': palette, 'min': 0, 'max': 0.8}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the feature collection of vegetation areas\nvegetacao = ee.Feature(ee.Geometry.MultiPoint([[-40.7535281646974, -19.06557919278928],\n                                               [-40.81120638735365, -19.052761346585605],\n                                               [-41.56903326874317, -19.18587219942273],\n                                               [-40.182009644568666, -18.686205662192442],\n                                               [-40.14903753810489, -18.359841405924637]]))\n", "task": "Using the Earth Engine library (ee), create a feature named **vegetacao** representing a multipoint geometry with the following coordinates: [[-40.7535281646974, -19.06557919278928], [-40.81120638735365, -19.052761346585605], [-41.56903326874317, -19.18587219942273], [-40.182009644568666, -18.686205662192442], [-40.14903753810489, -18.359841405924637]]", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the geometry of interest\ngeometry = ee.Geometry.Point([-41.47320816931153, -19.17385831234354])\n", "functions": ["ee.Feature", "ee.Geometry.MultiPoint"], "external_vars": ["ee"], "defined_vars": ["vegetacao"], "parameters": ["ee.Geometry.MultiPoint([[-40.7535281646974, -19.06557919278928], [-40.81120638735365, -19.052761346585605], [-41.56903326874317, -19.18587219942273], [-40.182009644568666, -18.686205662192442], [-40.14903753810489, -18.359841405924637]])", "[[-40.7535281646974, -19.06557919278928], [-40.81120638735365, -19.052761346585605], [-41.56903326874317, -19.18587219942273], [-40.182009644568666, -18.686205662192442], [-40.14903753810489, -18.359841405924637]]"], "libraries": ["import geemap", "import ee"]}
{"code": "et_mean_summer = modis.select('ET').filter(ee.Filter.calendarRange(6, 8, 'month')).mean().multiply(0.1)\n", "task": "Using the provided \"modis\" and \"ee\" objects, calculate the mean summer ET (Evapotranspiration) value. Filter the data to include only months 6, 7, and 8, then calculate the mean and multiply by 0.1. Store the result in a variable named \"et_mean_summer\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\ntime_start = '2001'\ntime_end = '2024'\n# call modis et product\nmodis = ee.ImageCollection(\n    'MODIS/061/MOD16A2GF').select('ET', 'PET').filterDate(time_start, time_end)\n", "functions": ["unknown_function.multiply", "unknown_function.mean", "unknown_function.filter", "modis.select", "ee.Filter.calendarRange"], "external_vars": ["ee", "modis"], "defined_vars": ["et_mean_summer"], "parameters": [0.1, "ET", 6, 8, "month", "ee.Filter.calendarRange(6, 8, 'month')"], "libraries": ["import ee", "import geemap"]}
{"code": "Map.addLayer(roi)\n", "task": "Add the region of interest (`roi`) to the map (`Map`).  The `roi` variable should be a GeoJSON object or a layer object, and `Map` should be a Leaflet map instance.  Make sure to define the following variables: `roi`, `Map`  before running this code.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ntable = ee.FeatureCollection('FAO/GAUL/2015/level1')\ncor = [2.3495010435451746, 48.8768460308918]\ngeometry = ee.Geometry.Point(cor)\nroi = table.filterBounds(geometry)\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "roi"], "defined_vars": [], "parameters": ["roi"], "libraries": ["import geemap", "import ee"]}
{"code": "## Load countries data\ncountries = ee.FeatureCollection(\"USDOS/LSIB_SIMPLE/2017\")\nEthiopia = countries.filter(ee.Filter.eq(\"country_na\", \"Ethiopia\"))\n", "task": "Using the Earth Engine library (`ee`), load the `USDOS/LSIB_SIMPLE/2017` feature collection and store it in the variable `countries`. Then, filter the collection to select only features representing Ethiopia and store the result in the variable `Ethiopia`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.FeatureCollection", "countries.filter", "ee.Filter.eq"], "external_vars": ["ee"], "defined_vars": ["Ethiopia", "countries"], "parameters": ["USDOS/LSIB_SIMPLE/2017", "country_na", "Ethiopia", "ee.Filter.eq('country_na', 'Ethiopia')"], "libraries": ["import ee", "import geemap"]}
{"code": "# Filter the S2_LVL_1C collection by the ROI.\nspatialf = S2_LVL_1C.filterBounds(table)\n", "task": "Filter the Sentinel-2 Level 1C data (S2_LVL_1C) using the bounds defined in the `table` variable. Store the filtered data in a new variable called `spatialf`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nS2_LVL_1C = ee.ImageCollection('COPERNICUS/S2')\n# Define the table.\ntable = ee.FeatureCollection('users/3050512/Lindani')\n", "functions": ["S2_LVL_1C.filterBounds"], "external_vars": ["S2_LVL_1C", "table"], "defined_vars": ["spatialf"], "parameters": ["table"], "libraries": ["import geemap", "import ee"]}
{"code": "Map.addLayer(ndmi.toBands().clip(geometry), {},'ndmi',False)\n\n\n", "task": "Add the NDMI layer to the map. The NDMI layer is defined by the `ndmi` variable and should be clipped to the `geometry` before being added. The layer should be named \"ndmi\" and should not be the default basemap.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ncor1 = [[-113.80502319704019, 42.704955393175936], [-113.56057739625894, 42.704955393175936], [-113.56057739625894,\n                                                                                               42.862689736716995], [-113.80502319704019, 42.862689736716995], [-113.80502319704019, 42.704955393175936]]\ngeometry = ee.Geometry.Polygon(cor1)\ntime_start = '2023'\ntime_end = '2024'\nlandsat8 = ee.ImageCollection(\n    'LANDSAT/LC08/C02/T1_L2').filterDate(time_start, time_end).filterBounds(geometry)\nlandsat9 = ee.ImageCollection(\n    'LANDSAT/LC09/C02/T1_L2').filterDate(time_start, time_end).filterBounds(geometry)\nlandsat = landsat8.merge(landsat9).sort('system:time_start').filter(\n    ee.Filter.calendarRange(5, 9, 'month')).filter(ee.Filter.lt('CLOUD_COVER', 45))\n\n\ndef func_(img):\n    bands = img.select('SR_B.*')\n    gain = ee.Number(img.get('REFLECTANCE_MULT_BAND_1'))\n    offset = ee.Number(img.get('REFLECTANCE_ADD_BAND_1'))\n    ms = bands.multiply(gain).add(gain)\n    ndmi = ms.normalizedDifference(['SR_B5', 'SR_B6']).rename('NDMI')\n    mask = ndmi.gt(0)\n    return ndmi.updateMask(mask).rename('ndmi').copyProperties(img, img.propertyNames())\n\n\nndmi = landsat.map(func_)\n", "functions": ["Map.addLayer", "unknown_function.clip", "ndmi.toBands"], "external_vars": ["geometry", "ndmi", "Map"], "defined_vars": [], "parameters": ["ndmi", false, "geometry", "ndmi.toBands().clip(geometry)", "{}"], "libraries": ["import geemap", "import ee"]}
{"code": "landsat4 = ee.ImageCollection(\"LANDSAT/LT04/C02/T1_L2\").select('SR_B.*').filterDate('1982','1994').filterBounds(roi).filter(ee.Filter.lt('CLOUD_COVER',45)).filter(ee.Filter.eq('WRS_PATH', 165)).filter(ee.Filter.eq('WRS_ROW', 38)).map(ndvi_tm_etm)\n", "task": "Define a variable named `landsat4` using the `ee.ImageCollection` function to access Landsat 4 data from the collection \"LANDSAT/LT04/C02/T1_L2\". Select the bands starting with \"SR_B.\" and filter the collection by date (between 1982 and 1994), by bounding box (`roi`), by cloud cover (less than 45%), by path (165), and by row (38). Finally, map the `ndvi_tm_etm` function over the filtered image collection.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [[48.62559911358055, 31.65418476680761], [48.91124364483055, 31.65418476680761], [48.91124364483055,\n                                                                                        31.885355756064595], [48.62559911358055, 31.885355756064595], [48.62559911358055, 31.65418476680761]]\nroi = ee.Geometry.Polygon(cor)\n\n\ndef ndvi_tm_etm(img):\n    bands = img.multiply(2.75e-05).add(-0.2)\n    ndvi = bands.normalizedDifference(['SR_B4', 'SR_B3']).rename('ndvi')\n    return ndvi.copyProperties(img, img.propertyNames())\n", "functions": ["unknown_function.map", "unknown_function.filter", "unknown_function.filter", "unknown_function.filter", "unknown_function.filterBounds", "unknown_function.filterDate", "unknown_function.select", "ee.ImageCollection", "ee.Filter.lt", "ee.Filter.eq", "ee.Filter.eq"], "external_vars": ["ee", "ndvi_tm_etm", "roi"], "defined_vars": ["landsat4"], "parameters": ["ndvi_tm_etm", "roi", "1982", "1994", "SR_B.*", "LANDSAT/LT04/C02/T1_L2", "CLOUD_COVER", 45, "WRS_PATH", 165, "WRS_ROW", 38, "ee.Filter.eq('WRS_ROW', 38)", "ee.Filter.eq('WRS_PATH', 165)", "ee.Filter.lt('CLOUD_COVER', 45)"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the region of interest (ROI) as a MultiPolygon.\nchristians_creek = ee.Geometry.MultiPolygon(\n    [[[[-79.11880790234927, 38.02471734185144],\n       [-79.1161471510065, 38.02478495452317],\n       [-79.11164103986148, 38.02654286208903],\n       [-79.10644828320865, 38.02811480140187],\n       [-79.10391627789859, 38.029602196791835],\n       [-79.10565434934024, 38.03142759531444],\n       [-79.1070705557001, 38.03225577038458],\n       [-79.10925923825626, 38.03206985434716],\n       [-79.11335765363101, 38.03022756992648],\n       [-79.11981641293887, 38.0278105577155],\n       [-79.11897956372623, 38.02563010765577]]],\n     [[[-79.2207547033959, 38.10443714276572],\n       [-79.21993931185537, 38.098561007124324],\n       [-79.21556194674307, 38.101296508366964],\n       [-79.20908172976308, 38.10696981410714],\n       [-79.21079834353262, 38.110414106227786]]]]\n)\n", "task": "Define a variable named `christians_creek` that represents the Christians Creek watershed using the `ee.Geometry.MultiPolygon` function and the given coordinates. Make sure to use the `ee` library to access the geometry function.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Geometry.MultiPolygon"], "external_vars": ["ee"], "defined_vars": ["christians_creek"], "parameters": ["[[[[-79.11880790234927, 38.02471734185144], [-79.1161471510065, 38.02478495452317], [-79.11164103986148, 38.02654286208903], [-79.10644828320865, 38.02811480140187], [-79.10391627789859, 38.029602196791835], [-79.10565434934024, 38.03142759531444], [-79.1070705557001, 38.03225577038458], [-79.10925923825626, 38.03206985434716], [-79.11335765363101, 38.03022756992648], [-79.11981641293887, 38.0278105577155], [-79.11897956372623, 38.02563010765577]]], [[[-79.2207547033959, 38.10443714276572], [-79.21993931185537, 38.098561007124324], [-79.21556194674307, 38.101296508366964], [-79.20908172976308, 38.10696981410714], [-79.21079834353262, 38.110414106227786]]]]"], "libraries": ["import ee", "import geemap"]}
{"code": "# Load the Sentinel-2 SR collection.\ndataset = ee.ImageCollection('COPERNICUS/S2_SR')\n", "task": "Using the Earth Engine library (`ee`), load the Sentinel-2 Surface Reflectance (SR) image collection and assign it to the variable `dataset`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["dataset"], "parameters": ["COPERNICUS/S2_SR"], "libraries": ["import ee", "import geemap"]}
{"code": "Map.centerObject(roi)\n", "task": "Center the object defined by the region of interest (`roi`) on the map (`Map`). This assumes the `Map` object has a method `centerObject` that takes a region of interest as input.  You need to define the variables `Map` and `roi` before executing this code.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [[44.86557382828752, 37.08659871132482], [46.08505625016252, 37.08659871132482], [46.08505625016252,\n                                                                                        38.34669285754838], [44.86557382828752, 38.34669285754838], [44.86557382828752, 37.08659871132482]]\nroi = ee.Geometry.Polygon(cor)\n", "functions": ["Map.centerObject"], "external_vars": ["roi", "Map"], "defined_vars": [], "parameters": ["roi"], "libraries": ["import ee", "import geemap"]}
{"code": "# Calculate the Nagler snow mask\nnagler = prenagler.lt(0)\n\nprint('cociente img/ref', prenagler)\nprint('nieve con nagler', nagler)\n", "task": "Define a variable called **nagler** by checking if the value of **prenagler** is less than 0 using the `lt()` function. Then, use **print** to display the value of **prenagler** with the label \"cociente img/ref\" and the value of **nagler** with the label \"nieve con nagler\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the feature collection\ntable = ee.FeatureCollection('users/bmorenocarrion/Rio_Pulido')\n# Filter the Sentinel-1 image collection\nnieve = ee.ImageCollection('COPERNICUS/S1_GRD').filter(ee.Filter.eq('instrumentMode', 'IW')).filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')\n                                                                                                    ).filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING')).filterBounds(table).filterDate('2016-08-10', '2016-09-01').select('VV').mosaic().clip(table)\n# Load the non-snow image\nnonieve = ee.Image(\n    'COPERNICUS/S1_GRD/S1B_IW_GRDH_1SDV_20210208T232043_20210208T232108_025521_030A81_0EEE').select('VV').clip(table)\n# Calculate the pre-Nagler ratio image\nprenagler = nieve.divide(nonieve)\n", "functions": ["prenagler.lt", "print", "print"], "external_vars": ["print", "prenagler"], "defined_vars": ["nagler"], "parameters": [0, "cociente img/ref", "prenagler", "nieve con nagler", "nagler"], "libraries": ["import geemap", "import ee"]}
{"code": "# Function to process each yearly image by adding a 'year' band\ndef process_image(image):\n    year = image.get('year')\n    year_image = ee.Image.constant(year).toShort()\n    return ee.Image.cat(year_image, image).rename(['year', 'prcp']).set('year', year)\n", "task": "Using the Earth Engine library (ee), create a function named `process_image` that takes an image as input. Extract the \"year\" property from the image and store it in the `year` variable.  Use `ee.Image.constant(year).toShort()` to create a new image named `year_image` representing the year value. Concatenate `year_image` with the original `image` using `ee.Image.cat`, rename the resulting image bands to \"year\" and \"prcp\", and set the \"year\" property of the image to the extracted year value. Return the processed image.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["image.get", "unknown_function.toShort", "ee.Image.constant", "unknown_function.set", "unknown_function.rename", "ee.Image.cat"], "external_vars": ["ee"], "defined_vars": ["image", "year", "year_image"], "parameters": ["year", "year", "year", "year", "year_image", "image", "['year', 'prcp']"], "libraries": ["import geemap", "import ee"]}
{"code": "# Draw country boundaries\ncountries = ee.Image().byte() .paint({'featureCollection': roi, 'color': 1, 'width': 1})\n", "task": "Using the provided variables `roi` (a feature collection) and `ee` (the Earth Engine module), define a variable named `countries` by creating an empty image, converting it to byte type, and painting the `roi` onto it with a color value of 1 and a width of 1 pixel.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the region of interest (ROI)\nroi = ee.FeatureCollection(\n    'USDOS/LSIB_SIMPLE/2017').filterMetadata('wld_rgn', 'equals', 'South America')\n", "functions": ["unknown_function.paint", "unknown_function.byte", "ee.Image"], "external_vars": ["ee", "roi"], "defined_vars": ["countries"], "parameters": ["{'featureCollection': roi, 'color': 1, 'width': 1}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the 'slope' layer to the map\nMap.addLayer(slope, {\"min\": 0, \"max\": 90}, \"slope\")\n", "task": "Add the `slope` layer to the `Map` with a color ramp that ranges from 0 to 90, labeling the layer \"slope\". You will need to define `slope` before running this code.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the input datasets\nsrtm = ee.Image('USGS/SRTMGL1_003')\n# Calculate the slope of the terrain\nslope = ee.Terrain.slope(srtm)\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "slope"], "defined_vars": [], "parameters": ["slope", "slope", "{'min': 0, 'max': 90}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the CO data\nCO = ee.ImageCollection('COPERNICUS/S5P/OFFL/L3_CO') .select('CO_column_number_density') .filterDate(start_date, end_date) .filterBounds(roi) .map(lambda img: img.clip(roi))\n", "task": "Define a variable named `CO` representing an Earth Engine ImageCollection of Carbon Monoxide (CO) data from the Copernicus Sentinel-5P satellite. The collection should be filtered to the time period between `start_date` and `end_date`, spatially constrained to the region of interest (`roi`), and clipped to the `roi`. The collection should be selected for the \"CO_column_number_density\" band.  ", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the region of interest (ROI)\nroi = ee.FeatureCollection(\n    'USDOS/LSIB_SIMPLE/2017').filterMetadata('wld_rgn', 'equals', 'South America')\n# Define the start and end dates\nstart_date = '2019-09-01'\nend_date = '2019-09-15'\n", "functions": ["unknown_function.map", "unknown_function.filterBounds", "unknown_function.filterDate", "unknown_function.select", "ee.ImageCollection", "img.clip"], "external_vars": ["end_date", "ee", "start_date", "roi", "img"], "defined_vars": ["CO"], "parameters": ["roi", "start_date", "end_date", "CO_column_number_density", "COPERNICUS/S5P/OFFL/L3_CO", "roi", "lambda img: img.clip(roi)"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the NLCD image and select the landcover band\nnlcd = ee.Image(\"USGS/NLCD/NLCD2016\").select(\"landcover\")\nMap.addLayer(nlcd.clip(co), {}, \"NLCD\", 0)\n", "task": "Define a variable called `nlcd` by loading the NLCD 2016 landcover image from Google Earth Engine using the `ee.Image` function and selecting the \"landcover\" band. Then, clip the image to the region defined by the variable `co` and add it to the `Map` with the layer name \"NLCD\" and a transparency level of 0.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Load the states feature collection and filter to Colorado\nstates = ee.FeatureCollection('TIGER/2018/States')\ncolorado = states.filter(ee.Filter.eq('NAME', 'Colorado'))\n# Convert Colorado from a feature collection to a feature\nco = colorado.first()\n", "functions": ["unknown_function.select", "ee.Image", "Map.addLayer", "nlcd.clip"], "external_vars": ["ee", "Map", "co"], "defined_vars": ["nlcd"], "parameters": ["landcover", "USGS/NLCD/NLCD2016", "NLCD", 0, "co", "nlcd.clip(co)", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the Sentinel-2 image collection\nimage_collection = ee.ImageCollection(\"COPERNICUS/S2\")\n", "task": "Using the Earth Engine library (ee), load the Sentinel-2 image collection and assign it to the variable `image_collection`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["image_collection"], "parameters": ["COPERNICUS/S2"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the input image.And the region of interest (ROI).\nimage = ee.Image(\"USGS/SRTMGL1_003\")\ngeometry = ee.Geometry.Polygon([[[89.9391582957051, 24.47746916985463],\n                              [89.9391582957051, 23.18108594736546],\n                              [91.2630108347676, 23.18108594736546],\n                              [91.2630108347676, 24.47746916985463]]])\n", "task": "Using the Earth Engine library (ee), load the SRTMGL1_003 elevation dataset as an image and define a polygon geometry. Assign the image to the variable \"image\" and the geometry to the variable \"geometry\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Image", "ee.Geometry.Polygon"], "external_vars": ["ee"], "defined_vars": ["geometry", "image"], "parameters": ["USGS/SRTMGL1_003", "[[[89.9391582957051, 24.47746916985463], [89.9391582957051, 23.18108594736546], [91.2630108347676, 23.18108594736546], [91.2630108347676, 24.47746916985463]]]"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define study area\nrntbBuf = ee.FeatureCollection('users/luciovilla/MDD_Zona_de_Estudio_v1_Final')\narea = rntbBuf #aoiSmall to test small area\n", "task": "Using the Earth Engine library (ee), define a variable named `rntbBuf` as a FeatureCollection loaded from the asset \"users/luciovilla/MDD_Zona_de_Estudio_v1_Final\". Then, define a variable named `area` that is equal to `rntbBuf`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.FeatureCollection"], "external_vars": ["ee"], "defined_vars": ["rntbBuf", "area"], "parameters": ["users/luciovilla/MDD_Zona_de_Estudio_v1_Final"], "libraries": ["import ee", "import geemap"]}
{"code": "list_dates = ee.List.sequence(0, time_dif, 10).map(lambda interval:ee.Date.fromYMD(2017, 1, 1).advance(interval, 'days'))\n", "task": "Create a list of dates called `list_dates` starting from January 1, 2017, and advancing by 10 days for a total of `time_dif` days. Use the `ee.List.sequence` function to generate a sequence of intervals from 0 to `time_dif` with a step of 10, and then use the `ee.Date.fromYMD` and `ee.Date.advance` functions to create the dates. The `interval` variable represents each element in the sequence.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ntime_start = ee.Date('2017')\ntime_end = ee.Date('2024')\ntime_dif = time_end.difference(time_start, 'day')\n", "functions": ["unknown_function.map", "ee.List.sequence", "unknown_function.advance", "ee.Date.fromYMD"], "external_vars": ["ee", "interval", "time_dif"], "defined_vars": ["list_dates"], "parameters": [0, "time_dif", 10, "interval", "days", 2017, 1, 1, "lambda interval: ee.Date.fromYMD(2017, 1, 1).advance(interval, 'days')"], "libraries": ["import ee", "import geemap"]}
{"code": "# Load the DMSP-OLS nighttime lights collection.\ndmspols = ee.ImageCollection(\"NOAA/DMSP-OLS/NIGHTTIME_LIGHTS\")\n", "task": "Using the Earth Engine library (ee), define a variable named `dmspols` to represent the DMSP-OLS Nighttime Lights image collection.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["dmspols"], "parameters": ["NOAA/DMSP-OLS/NIGHTTIME_LIGHTS"], "libraries": ["import geemap", "import ee"]}
{"code": "geometry = ee.Geometry.Polygon(cor)\n", "task": "Define a variable named `geometry` representing a polygon with the coordinates specified by the variable `cor` using the Earth Engine library `ee`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\ncor = [[51.40150195835105, 35.680686269764024], [51.41738063571921, 35.67796719930233], [51.41841060398093, 35.68584527697069], [51.420813863258275,\n                                                                                                                                 35.68584527697069], [51.41944057224265, 35.70145969785625], [51.40536433933249, 35.70118089572008], [51.40150195835105, 35.680686269764024]]\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee", "cor"], "defined_vars": ["geometry"], "parameters": ["cor"], "libraries": ["import geemap", "import ee"]}
{"code": "# Calculate the NDVI (Normalized Difference Vegetation Index)\nNDVI = composite.select('B4').subtract(composite.select('B3')).divide(composite.select('B4').add(composite.select('B3')))\n", "task": "Using the provided composite image, calculate the Normalized Difference Vegetation Index (NDVI).", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Define the bounding geometry for the area of interest\nBound_geom = ee.Geometry.Polygon([[[-93.11310959151902, 18.112334929829487], [-93.11310959151902, 17.86416393364247],\n                                 [-92.74781418136277, 17.86416393364247], [-92.74781418136277, 18.112334929829487]]], None, False)\n# Load the Landsat collection\nl7collection = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR').filterBounds(\n    Bound_geom).filterMetadata('CLOUD_COVER', 'less_than', 4).filterDate('1989-01-01', '1991-12-31')\n# Create a single composite image\ncomposite = l7collection.median().clip(Bound_geom)\n", "functions": ["unknown_function.divide", "unknown_function.subtract", "composite.select", "composite.select", "unknown_function.add", "composite.select", "composite.select"], "external_vars": ["composite"], "defined_vars": ["NDVI"], "parameters": ["B4", "B3", "B4", "B3", "composite.select('B4').add(composite.select('B3'))", "composite.select('B3')", "composite.select('B3')"], "libraries": ["import ee", "import geemap"]}
{"code": "# Display the POIs on the map\nMap.addLayer(inner, {\"color\": \"#0000FF\"}, \"Inner\")\nMap.addLayer(offshore, {\"color\": \"#FF0000\"}, \"Offshore\")\nMap.addLayer(outer, {\"color\": \"#000000\"}, \"Open\")\n", "task": "Add three layers to the map: \"Inner\", \"Offshore\", and \"Open\". Use the `Map.addLayer` function.  The \"Inner\" layer should be colored blue (`#0000FF`) and use the variable `inner`. The \"Offshore\" layer should be colored red (`#FF0000`) and use the variable `offshore`. The \"Open\" layer should be colored black (`#000000`) and use the variable `outer`. **You will need to define the variables `inner`, `offshore`, and `outer` before running this code.**", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the points of interest (POIs)\ninner = ee.Geometry.Point([137.2141, 36.8886])\noffshore = ee.Geometry.Point([137.618, 37.259])\nouter = ee.Geometry.Point([135.597, 37.251])\n", "functions": ["Map.addLayer", "Map.addLayer", "Map.addLayer"], "external_vars": ["inner", "outer", "Map", "offshore"], "defined_vars": [], "parameters": ["inner", "Inner", "offshore", "Offshore", "outer", "Open", "{'color': '#0000FF'}", "{'color': '#FF0000'}", "{'color': '#000000'}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Center the map\nMap.setCenter(-9.1695, 38.6917, 12)\n", "task": "Center the map on the coordinates (-9.1695, 38.6917) and zoom to level 12.  Make sure to define the following variables: [Map]", "exec_path": "GEE", "context": "import geemap\nMap = geemap.Map()\n", "functions": ["Map.setCenter"], "external_vars": ["Map"], "defined_vars": [], "parameters": [38.6917, 12, "-9.1695"], "libraries": ["import geemap"]}
{"code": "# Compute the Normalized Difference Water Index (NDWI) for the before and after images\nAfter_flood = Time2_after.normalizedDifference(['B8', 'B11'])\nBefore_flood = Time1_before.normalizedDifference(['B8', 'B11'])\n\n\n", "task": "Calculate the Normalized Difference Vegetation Index (NDVI) for both the \"Time2_after\" and \"Time1_before\" images using the bands 'B8' and 'B11'. Define the resulting NDVI values as \"After_flood\" and \"Before_flood\", respectively.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Define the time period before the floods\nTime1_before = ee.ImageCollection('COPERNICUS/S2').filterDate(\n    '2019-09-01', '2019-09-10').filterMetadata('CLOUDY_PIXEL_PERCENTAGE', 'Less_Than', 40).median()\n# Define the time period after the floods\nTime2_after = ee.ImageCollection('COPERNICUS/S2').filterDate('2019-09-12',\n                                                             '2019-09-20').filterMetadata('CLOUDY_PIXEL_PERCENTAGE', 'Less_Than', 40).median()\n", "functions": ["Time2_after.normalizedDifference", "Time1_before.normalizedDifference"], "external_vars": ["Time2_after", "Time1_before"], "defined_vars": ["After_flood", "Before_flood"], "parameters": ["['B8', 'B11']", "['B8', 'B11']"], "libraries": ["import ee", "import geemap"]}
{"code": "# Composite median\nCompositeMedian = Filtered.median()\n", "task": "Calculate the median of the filtered data and assign it to the variable `CompositeMedian`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nSelangor = ee.FeatureCollection(\n    'FAO/GAUL/2015/level1').filter(ee.Filter.eq('ADM1_NAME', 'Selangor'))\n# Get Landsat8 collection and filter it as in previous lab\nFiltered = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterBounds(\n    Selangor).filterDate('2020-06-01', '2020-12-31').sort('CLOUD_COVER')\n", "functions": ["Filtered.median"], "external_vars": ["Filtered"], "defined_vars": ["CompositeMedian"], "parameters": [], "libraries": ["import geemap", "import ee"]}
{"code": "# Print the size of the filtered collection\nprint(Filtered_Date_Meta_Reg.size())\n", "task": "Print the size of the DataFrame named \"Filtered_Date_Meta_Reg\". Make sure you have defined the DataFrame \"Filtered_Date_Meta_Reg\" beforehand.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the Landsat 8 collection\nl8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_TOA')\n# Define the region of interest (ROI)\nRegion = ee.Geometry.Polygon([[9.90600172955105, 49.82184262134338], [9.844203633847926, 49.804119350056595], [9.80163161236355, 49.75942246156867], [9.860683126035426, 49.725699274626265], [9.9472004600198, 49.71149302501647], [\n                             10.02685133892605, 49.73191320193975], [10.04333083111355, 49.77272779371979], [10.0241047568948, 49.80464569232409], [10.00487868267605, 49.831227876354816], [9.945827169004176, 49.83831399256641]])\n# Filter the collection by the ROI\nFiltered_Collection = l8.filterBounds(Region)\n# Filter the collection by cloud cover\nFilter_Meta_Reg = Filtered_Collection.filterMetadata(\n    'CLOUD_COVER', 'less_than', 1)\n# Filter the collection by date range\nFiltered_Date_Meta_Reg = Filter_Meta_Reg.filterDate('2017-01-01', '2017-12-31')\n", "functions": ["print", "Filtered_Date_Meta_Reg.size"], "external_vars": ["Filtered_Date_Meta_Reg", "print"], "defined_vars": [], "parameters": ["Filtered_Date_Meta_Reg.size()"], "libraries": ["import geemap", "import ee"]}
{"code": "# Calculate the total precipitation\ntotal = filtered.reduce(ee.Reducer.sum())\n", "task": "Calculate the sum of all values in the `filtered` Earth Engine Image Collection using the `ee.Reducer.sum()` function and assign the result to a variable named `total`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the CHIRPS precipitation dataset\nchirps = ee.ImageCollection('UCSB-CHG/CHIRPS/PENTAD')\n# Specify the year for which you want to calculate the precipitation\nyear = 2023\nstart_date = ee.Date.fromYMD(year, 1, 1)\nend_date = start_date.advance(1, 'year')\n# Filter the CHIRPS collection by date\nfiltered = chirps.filter(ee.Filter.date(start_date, end_date))\n", "functions": ["filtered.reduce", "ee.Reducer.sum"], "external_vars": ["filtered", "ee"], "defined_vars": ["total"], "parameters": ["ee.Reducer.sum()"], "libraries": ["import geemap", "import ee"]}
{"code": "def func_(img):\n    ms = img.select('SR.*')\n    gain = ee.Number(img.get('REFLECTANCE_MULT_BAND_3'))\n    offset = ee.Number(img.get('REFLECTANCE_ADD_BAND_2'))\n    sr = ms.multiply(gain).add(offset)\n    ndvi = sr.normalizedDifference(['SR_B5','SR_B4']).rename('ndvi')\n    return ndvi.copyProperties(img, ['system:time_start', 'system:time_end','system:index'])\n\nlandsat8 = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_L2\").filterDate(time_start, time_end).filterBounds(geometry).map(func_)\n", "task": "Use the Earth Engine library (ee) to filter Landsat 8 imagery (LANDSAT/LC08/C02/T1_L2) based on the specified start and end dates (time_start, time_end) and geographic boundary (geometry). Apply the function func_ to each image in the collection to calculate the Normalized Difference Vegetation Index (NDVI), store the result in the variable ndvi, and create an ImageCollection called landsat8.  Use the following variables within your code:  **Variables to Define:**  ndvi, landsat8, img, ms, offset, gain, sr", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ncor = [[48.09532576624447, 31.98308763719514], [48.744892416635096, 31.98308763719514], [48.744892416635096,\n                                                                                         32.40378543571943], [48.09532576624447, 32.40378543571943], [48.09532576624447, 31.98308763719514]]\ngeometry = ee.Geometry.Polygon(cor)\ntime_start = '2023'\ntime_end = '2024'\n", "functions": ["img.select", "ee.Number", "img.get", "ee.Number", "img.get", "unknown_function.add", "ms.multiply", "unknown_function.rename", "sr.normalizedDifference", "ndvi.copyProperties", "unknown_function.map", "unknown_function.filterBounds", "unknown_function.filterDate", "ee.ImageCollection"], "external_vars": ["func_", "time_start", "ee", "geometry", "time_end"], "defined_vars": ["sr", "offset", "gain", "ndvi", "img", "ms", "landsat8"], "parameters": ["SR.*", "REFLECTANCE_MULT_BAND_3", "REFLECTANCE_ADD_BAND_2", "offset", "gain", "ndvi", "img", "func_", "geometry", "time_start", "time_end", "LANDSAT/LC08/C02/T1_L2", "img.get('REFLECTANCE_MULT_BAND_3')", "img.get('REFLECTANCE_ADD_BAND_2')", "['SR_B5', 'SR_B4']", "['system:time_start', 'system:time_end', 'system:index']"], "libraries": ["import geemap", "import ee"]}
{"code": "# Access the 30m Landsat datset for water loctions.\nwater = ee.ImageCollection(\"GLCF/GLS_WATER\").map(lambda img:img.expression(\"(BAND==2)\",{'BAND':img.select('water')}))\n", "task": "Using the Earth Engine library (ee), create an ImageCollection named \"water\" from the GLCF/GLS_WATER dataset. Then, apply a function to each image in the collection using the \"map\" method. This function will use the \"expression\" method to create a new image based on the condition \"(BAND==2)\". Define the variable \"BAND\" to refer to the \"water\" band from the current image (img).", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n", "functions": ["unknown_function.map", "ee.ImageCollection", "img.expression", "img.select"], "external_vars": ["ee", "img"], "defined_vars": ["water"], "parameters": ["GLCF/GLS_WATER", "(BAND==2)", "water", "lambda img: img.expression('(BAND==2)', {'BAND': img.select('water')})", "{'BAND': img.select('water')}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Check the number of watersheds after filtering by Zambia boundary\nprint('Count after filter: ', filtered.size().getInfo())\n", "task": "Print the count of elements in the filtered DataFrame, using the `print` function and the `.size().getInfo()` method on the `filtered` DataFrame.  You will need to define the `filtered` DataFrame variable before running this code.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load terristerial ecoregions\necoregion = ee.FeatureCollection('RESOLVE/ECOREGIONS/2017')\n# Get a feature collection\ncountries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017')\nZambia = countries.filter(ee.Filter.eq('country_na', 'Zambia'))\n# Filter the table\nfiltered = ecoregion.filterBounds(Zambia)\n", "functions": ["print", "unknown_function.getInfo", "filtered.size"], "external_vars": ["filtered", "print"], "defined_vars": [], "parameters": ["Count after filter: ", "filtered.size().getInfo()"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the Global Surface Water dataset.\nwater = ee.Image(\"JRC/GSW1_3/GlobalSurfaceWater\")\n", "task": "Using the Earth Engine library (ee), define a variable named \"water\" to represent the Global Surface Water dataset from JRC.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["water"], "parameters": ["JRC/GSW1_3/GlobalSurfaceWater"], "libraries": ["import geemap", "import ee"]}
{"code": "# Get the first image in the filtered collection\nimage = l8limite.first()\n", "task": "Assign the first element of the list `l8limite` to the variable `image`.  Make sure `image` is already defined.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Define the geometry\ngeometry = ee.Geometry.Point([-64.30008741975684, -31.472731901048824])\n# Load the Landsat 8 collection\nl8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')\n# Filter the collection by geometry and date\nl8limite = l8.filterBounds(geometry).filterDate('2020-10-01', '2021-01-31')\n", "functions": ["l8limite.first"], "external_vars": ["l8limite"], "defined_vars": ["image"], "parameters": [], "libraries": ["import ee", "import geemap"]}
{"code": "# Calculate the mean FRP.\nfrp_terra_aqua_mean = frp_terra_aqua.mean().multiply(0.1)\n", "task": "Calculate the mean of the `frp_terra_aqua` variable and multiply it by 0.1. Store the result in a new variable called `frp_terra_aqua_mean`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Set the parameters for the visualization.\nstart_date = '2019-09-01'\nend_date = '2019-09-30'\n# Load the FRP data from MODIS.\ndataset_terra = ee.ImageCollection(\n    'MODIS/061/MOD14A1').filterDate(start_date, end_date).select('MaxFRP')\ndataset_aqua = ee.ImageCollection(\n    'MODIS/061/MYD14A1').filterDate(start_date, end_date).select('MaxFRP')\nfrp_terra_aqua = dataset_terra.merge(dataset_aqua)\n", "functions": ["unknown_function.multiply", "frp_terra_aqua.mean"], "external_vars": ["frp_terra_aqua"], "defined_vars": ["frp_terra_aqua_mean"], "parameters": [0.1], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the study area to the map\nMap.addLayer(study_area)\nMap.centerObject(study_area)\n", "task": "Add the `study_area` layer to the `Map` and center the map on the `study_area`.  You will need to define the variables `study_area` and `Map` before running this code.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the area of interest (Bolivia)\nbolivia = ee.FeatureCollection(\n    'USDOS/LSIB_SIMPLE/2017').filter(ee.Filter.inList('country_na', ['Bolivia']))\nstudy_area = bolivia.geometry()\n", "functions": ["Map.addLayer", "Map.centerObject"], "external_vars": ["Map", "study_area"], "defined_vars": [], "parameters": ["study_area", "study_area"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add the tree loss layer to the map.\nMap.addLayer(forest, tree_loss_vis_params, \"tree loss year\")\n\n\n", "task": "Add the `forest` layer to the map using the `tree_loss_vis_params` visualization parameters and name the layer \"tree loss year\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the global forest change image.\nforest = ee.Image('UMD/hansen/global_forest_change_2021_v1_9')\n# Define the visualization parameters for the tree loss.\ntree_loss_vis_params = {'bands': ['lossyear'],\n                        'min': 0, 'max': 21, 'palette': ['yellow', 'red']}\n", "functions": ["Map.addLayer"], "external_vars": ["tree_loss_vis_params", "forest", "Map"], "defined_vars": [], "parameters": ["forest", "tree_loss_vis_params", "tree loss year"], "libraries": ["import geemap", "import ee"]}
{"code": "# Create a composite from means at different polarizations.And look angles.\ncomposite = ee.Image.cat([\n    vh_ascending.select('VH').mean(),\n    ee.ImageCollection(vh_ascending.select('VV').merge(vh_descending.select('VV'))).mean(),\n    vh_descending.select('VH').mean()\n]).focal_median()\n", "task": "Using the Earth Engine API (ee), create a composite image called `composite` by concatenating the mean of the VH band from `vh_ascending`, the mean of the VV band from both `vh_ascending` and `vh_descending` merged together, and the mean of the VH band from `vh_descending`. Then, apply a focal median filter to the composite image.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nsentinel1 = ee.ImageCollection('COPERNICUS/S1_GRD')\n# Filter by metadata properties.\nvh = sentinel1.filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')).filter(\n    ee.Filter.listContains('transmitterReceiverPolarisation', 'VH')).filter(ee.Filter.eq('instrumentMode', 'IW'))\n# Filter to get images from different look angles.\nvh_ascending = vh.filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING'))\nvh_descending = vh.filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'))\n", "functions": ["unknown_function.focal_median", "ee.Image.cat", "unknown_function.mean", "vh_ascending.select", "unknown_function.mean", "ee.ImageCollection", "unknown_function.merge", "vh_ascending.select", "vh_descending.select", "unknown_function.mean", "vh_descending.select"], "external_vars": ["ee", "vh_ascending", "vh_descending"], "defined_vars": ["composite"], "parameters": ["VH", "VV", "VV", "VH", "[vh_ascending.select('VH').mean(), ee.ImageCollection(vh_ascending.select('VV').merge(vh_descending.select('VV'))).mean(), vh_descending.select('VH').mean()]", "vh_ascending.select('VV').merge(vh_descending.select('VV'))", "vh_descending.select('VV')"], "libraries": ["import geemap", "import ee"]}
{"code": "# Get the scale (in meters) information for band 2 (Blue).\nb2_scale = image.select('B2').projection().nominalScale()\nprint('Band 2 (Blue) scale: ', b2_scale)  # Prints the scale as an ee.Number.\n", "task": "Using the provided `image` object, determine the nominal scale of band 2 (Blue) and print the result using the `print` function. Define a variable called `b2_scale` to store the scale.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load a Sentinel-2 image.\nimage = ee.Image('COPERNICUS/S2_SR/20210117T095341_20210117T100437_T32PLR')\n", "functions": ["unknown_function.nominalScale", "unknown_function.projection", "image.select", "print"], "external_vars": ["image", "print"], "defined_vars": ["b2_scale"], "parameters": ["B2", "Band 2 (Blue) scale: ", "b2_scale"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the input image.And region of interest (ROI).\nimage = ee.Image(\"JRC/GSW1_1/GlobalSurfaceWater\")\ngeometry = ee.Geometry.Polygon([[[13.454210486797251, 5.430948204680038],\n                                 [13.510697940886757, 5.398297900642877],\n                                 [13.489845022192412, 5.3857323103622425],\n                                 [13.483412678386571, 5.349240736011605],\n                                 [13.60870373105854, 5.093862537973553],\n                                 [13.965756319128786, 5.255248981791399],\n                                 [14.267877373598253, 5.684494009933694],\n                                 [14.050899446450785, 5.709090809883929],\n                                 [13.578491862117744, 5.7446178386247]]])\n", "task": "Using the Earth Engine library (ee), define an image variable called \"image\" to represent the Global Surface Water dataset and define a geometry variable called \"geometry\" representing a polygon with the given coordinates. ", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Image", "ee.Geometry.Polygon"], "external_vars": ["ee"], "defined_vars": ["geometry", "image"], "parameters": ["JRC/GSW1_1/GlobalSurfaceWater", "[[[13.454210486797251, 5.430948204680038], [13.510697940886757, 5.398297900642877], [13.489845022192412, 5.3857323103622425], [13.483412678386571, 5.349240736011605], [13.60870373105854, 5.093862537973553], [13.965756319128786, 5.255248981791399], [14.267877373598253, 5.684494009933694], [14.050899446450785, 5.709090809883929], [13.578491862117744, 5.7446178386247]]]"], "libraries": ["import geemap", "import ee"]}
{"code": "roi2 = ee.FeatureCollection([\n  ee.Feature(point1), ee.Feature(point2)\n  ])\n", "task": "Define a new FeatureCollection called `roi2` that includes two features, created from the points `point1` and `point2`, using the Earth Engine library (`ee`).", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nloc1 = [52.08596517173183, 26.6366657681643]\npoint1 = ee.Geometry.Point(loc1)\nloc2 = [59.316594338671855, 24.56401684163127]\npoint2 = ee.Geometry.Point(loc2)\n", "functions": ["ee.FeatureCollection", "ee.Feature", "ee.Feature"], "external_vars": ["ee", "point2", "point1"], "defined_vars": ["roi2"], "parameters": ["point1", "point2", "[ee.Feature(point1), ee.Feature(point2)]"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define a function to buffer the polygons\ndef buffer_poly(feature):\n  \"\"\"\n  Buffer a polygon by a given distance.\n\n  Args:\n    feature: The feature to buffer.\n    distance: The distance to buffer the feature by.\n\n  Returns:\n    The feature with the buffer added as a property.\n  \"\"\"\n  return feature.buffer(152.4) # Substitute in your value of Z here\n", "task": "Create a list called \"features\" that contains the following elements: [ ]. Then, create a variable called \"feature\" and assign it the first element in the \"features\" list.", "exec_path": "GEE", "context": "", "functions": ["feature.buffer"], "external_vars": [], "defined_vars": ["feature"], "parameters": [152.4], "libraries": []}
{"code": "# Display the results on the map\n# Add these images to the map (mask them with themselves)\nvis_params = {'palette': '#fff825'}\nMap.addLayer(loss_until_2005.mask(loss_until_2005), vis_params, 'loss_until_2005')\n\nvis_params = {'palette': '#ffaa42'}\nMap.addLayer(loss_2006_2010.mask(loss_2006_2010), vis_params, 'loss_2006_2010')\n\nvis_params = {'palette': '#e67525'}\nMap.addLayer(loss_2011_2015.mask(loss_2011_2015), vis_params, 'loss_2011_2015')\n\nvis_params = {'palette': '#cc0909'}\nMap.addLayer(loss_2016_2018.mask(loss_2016_2018), vis_params, 'loss_2016_2018') \n\n\n", "task": "Define a variable called `vis_params` and set it to a dictionary with the key `palette` and a value of `#fff825`. Then, using the `Map` object, add a layer with the masked version of `loss_until_2005` as the geometry, `vis_params` as the visualization parameters, and the name `loss_until_2005`. Repeat the layer addition process for `loss_2006_2010`, `loss_2011_2015`, and `loss_2016_2018`, updating the `palette` value in `vis_params` to `#ffaa42`, `#e67525`, and `#cc0909`, respectively.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Load the Hansen forest change image collection\nfc = ee.Image('UMD/hansen/global_forest_change_2018_v1_6')\nloss_year = fc.select('lossyear')\n# Identify the pixels that lost forest cover between specific years\nloss_until_2005 = loss_year.gt(0) and loss_year.lte(5)\nloss_2006_2010 = loss_year.gte(6) and loss_year.lte(10)\nloss_2011_2015 = loss_year.gte(11) and loss_year.lte(15)\nloss_2016_2018 = loss_year.gte(16) and loss_year.lte(18)\n", "functions": ["Map.addLayer", "loss_until_2005.mask", "Map.addLayer", "loss_2006_2010.mask", "Map.addLayer", "loss_2011_2015.mask", "Map.addLayer", "loss_2016_2018.mask"], "external_vars": ["Map", "loss_2006_2010", "loss_2016_2018", "loss_until_2005", "loss_2011_2015"], "defined_vars": ["vis_params"], "parameters": ["vis_params", "loss_until_2005", "loss_until_2005", "vis_params", "loss_2006_2010", "loss_2006_2010", "vis_params", "loss_2011_2015", "loss_2011_2015", "vis_params", "loss_2016_2018", "loss_2016_2018", "loss_until_2005.mask(loss_until_2005)", "loss_2006_2010.mask(loss_2006_2010)", "loss_2011_2015.mask(loss_2011_2015)", "loss_2016_2018.mask(loss_2016_2018)"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add the Garfield county layer to the map\nMap.addLayer(garfield, {}, \"Garfield county\", False)\n", "task": "Add the \"garfield\" layer to the \"Map\" object with no specific style, label it \"Garfield county\" and set it to not visible.  You will need to define the following variables: \"garfield\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the counties feature collection\ncounties = ee.FeatureCollection('TIGER/2018/Counties')\n# Define the geometry\ngeometry = ee.Geometry.Point([-99.25673894440935, 41.87015853597479])\n# Filter the counties collection to only include Garfield county\ngarfield = counties.filterBounds(geometry)\n", "functions": ["Map.addLayer"], "external_vars": ["garfield", "Map"], "defined_vars": [], "parameters": ["garfield", "Garfield county", false, "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "table = ee.FeatureCollection(\"FAO/GAUL/2015/level1\")\n", "task": "Using the Earth Engine library (ee), define a variable named \"table\" to represent the FeatureCollection \"FAO/GAUL/2015/level1\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.FeatureCollection"], "external_vars": ["ee"], "defined_vars": ["table"], "parameters": ["FAO/GAUL/2015/level1"], "libraries": ["import ee", "import geemap"]}
{"code": "# Load the SRTM image.\nsrtm = ee.Image(\"USGS/SRTMGL1_003\")\n", "task": "Using the Earth Engine library (`ee`), load the SRTMGL1_003 image collection and assign it to the variable `srtm`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["srtm"], "parameters": ["USGS/SRTMGL1_003"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the geometry of the area of interest.\ngeometry = ee.Geometry.Polygon([\n    [52.567900125815775, 36.62625224973441],\n    [52.567900125815775, 36.472352306689295],\n    [52.77732700569859, 36.472352306689295],\n    [52.77732700569859, 36.62625224973441]\n])\n", "task": "Using the ee library, define a variable called \"geometry\" that represents a polygon with the following coordinates: [[52.567900125815775, 36.62625224973441], [52.567900125815775, 36.472352306689295], [52.77732700569859, 36.472352306689295], [52.77732700569859, 36.62625224973441]]", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee"], "defined_vars": ["geometry"], "parameters": ["[[52.567900125815775, 36.62625224973441], [52.567900125815775, 36.472352306689295], [52.77732700569859, 36.472352306689295], [52.77732700569859, 36.62625224973441]]"], "libraries": ["import geemap", "import ee"]}
{"code": "geometry = ee.Geometry.Point(cor)\nroi = table.filterBounds(geometry).map(lambda feature: feature.simplify(1000))\n", "task": "Using the `ee` module, create a `geometry` object representing a point at the coordinates specified by `cor`. Then, using the `table` object, filter it to include only features that fall within the bounds of the `geometry`. Finally, simplify the geometries of each feature in the filtered table using the `simplify` function and store the result in a variable named `roi`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ntable = ee.FeatureCollection('WWF/HydroSHEDS/v1/Basins/hybas_5')\ncor = [45.97338733591252, 36.985496895804545]\n", "functions": ["ee.Geometry.Point", "unknown_function.map", "table.filterBounds", "feature.simplify"], "external_vars": ["ee", "feature", "cor", "table"], "defined_vars": ["geometry", "roi"], "parameters": ["cor", "geometry", 1000, "lambda feature: feature.simplify(1000)"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the geometry\ngeometry = ee.Geometry.Point([-64.30008741975684, -31.472731901048824])\n", "task": "Using the ee library, define a variable named `geometry` that represents a point with the coordinates [-64.30008741975684, -31.472731901048824].", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Geometry.Point"], "external_vars": ["ee"], "defined_vars": ["geometry"], "parameters": ["[-64.30008741975684, -31.472731901048824]"], "libraries": ["import ee", "import geemap"]}
{"code": "# Clip the SRTM image to the buffer.\nsrtm_30m_clipped = srtm_30m.clip(buffer)\nMap.addLayer(srtm_30m_clipped, {'min': 400, 'max': 2300}, \"SRTM\")\n", "task": "Clip the `srtm_30m` layer using the `buffer` and define a new layer called `srtm_30m_clipped`. Then, add this clipped layer to the `Map` with a minimum value of 400 and a maximum value of 2300 and label it \"SRTM\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the region of interest as a point near Lake Lucerne.\nlake_lucern = ee.Geometry.Point([8.399769975569825, 47.02733063921712])\n# Import the SRTM 30m resolution image.\nsrtm_30m = ee.Image('USGS/SRTMGL1_003')\n# Buffer the point around Lake Lucerne by 30 km.\nbuffer = lake_lucern.buffer(30000)\n", "functions": ["srtm_30m.clip", "Map.addLayer"], "external_vars": ["Map", "buffer", "srtm_30m"], "defined_vars": ["srtm_30m_clipped"], "parameters": ["buffer", "srtm_30m_clipped", "SRTM", "{'min': 400, 'max': 2300}"], "libraries": ["import ee", "import geemap"]}
{"code": "sen_mask = sen.updateMask(thr)\n", "task": "Define a variable `sen_mask` by calling the `updateMask` method on the `sen` object, passing the `thr` variable as an argument.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\ncor = [[48.69819149851601, 29.554928660523107], [49.91767392039101, 29.554928660523107], [49.91767392039101,\n                                                                                          30.671567766536796], [48.69819149851601, 30.671567766536796], [48.69819149851601, 29.554928660523107]]\nroi = ee.Geometry.Polygon(cor)\n# sentinel-2 images\nsen = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED').select(['B[2-4]', 'B8']).filterDate(\n    '2023', '2024').filterBounds(roi).filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10)).median().multiply(0.0001)\nndwi = sen.normalizedDifference(['B3', 'B8']).rename('ndwi')\nthr = ndwi.gt(0.1)\n", "functions": ["sen.updateMask"], "external_vars": ["thr", "sen"], "defined_vars": ["sen_mask"], "parameters": ["thr"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the geometry of the region of interest\ngeometry = ee.Geometry.Polygon([\n  [74.10619394531248, 31.6128822084251],\n  [74.10619394531248, 31.32943195156033],\n  [74.50170175781248, 31.32943195156033],\n  [74.50170175781248, 31.6128822084251]\n])\n", "task": "Define a variable named `geometry` using `ee.Geometry.Polygon` to create a polygon with the provided coordinates. The coordinates are [[74.10619394531248, 31.6128822084251], [74.10619394531248, 31.32943195156033], [74.50170175781248, 31.32943195156033], [74.50170175781248, 31.6128822084251]]", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee"], "defined_vars": ["geometry"], "parameters": ["[[74.10619394531248, 31.6128822084251], [74.10619394531248, 31.32943195156033], [74.50170175781248, 31.32943195156033], [74.50170175781248, 31.6128822084251]]"], "libraries": ["import geemap", "import ee"]}
{"code": "landsat_stat = landsat.reduce(ee.Reducer.percentile([25,50,75]))\n", "task": "Using the Earth Engine library (ee) and the Landsat image (landsat), calculate the 25th, 50th, and 75th percentiles of the image. Store the result in a new variable called `landsat_stat`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [45.68929902130395, 37.11033465203267]\ngeometry = ee.Geometry.Point(cor)\ntable = ee.FeatureCollection('WWF/HydroSHEDS/v1/Basins/hybas_5')\nroi = table.filterBounds(geometry).map(lambda feature: feature.simplify(3000))\ntime_start = '2020'\ntime_end = '2021'\n# predictor abs\n\n\ndef func_(img):\n    gain = ee.Number(img.get('REFLECTANCE_MULT_BAND_1'))\n    offset = ee.Number(img.get('REFLECTANCE_ADD_BAND_1'))\n    sr = img.multiply(gain).add(offset)\n    ndvi = sr.normalizedDifference(['SR_B5', 'SR_B4']).rename('ndvi')\n    ndwi = sr.normalizedDifference(['SR_B3', 'SR_B5']).rename('ndwi')\n    swir = sr.select('SR_B[6-7]')\n    return ee.Image.cat([ndvi, ndwi, swir])\n\n\nlandsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').select('SR_B.*').filterDate(\n    time_start, time_end).filterBounds(roi).filter(ee.Filter.lt('CLOUD_COVER', 10)).map(func_)\n", "functions": ["landsat.reduce", "ee.Reducer.percentile"], "external_vars": ["landsat", "ee"], "defined_vars": ["landsat_stat"], "parameters": ["ee.Reducer.percentile([25, 50, 75])", "[25, 50, 75]"], "libraries": ["import ee", "import geemap"]}
{"code": "#Load the Global Administrative Unit Layers (GAUL) dataset level 2.\ngaul = ee.FeatureCollection('FAO/GAUL/2015/level2')\n", "task": "Using the Earth Engine library, defined as **ee**, load the FAO GAUL level 2 feature collection and assign it to the variable **gaul**.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.FeatureCollection"], "external_vars": ["ee"], "defined_vars": ["gaul"], "parameters": ["FAO/GAUL/2015/level2"], "libraries": ["import ee", "import geemap"]}
{"code": "# Test the addNDVI function on a single image.\nndvi = add_ndvi(image).select('NDVI')\n", "task": "Use the `add_ndvi` function with the `image` as input to calculate the Normalized Difference Vegetation Index (NDVI).  Save the resulting NDVI band as a variable called `ndvi`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# ee.Geometry.Point() function as demonstrated here.\npoint = ee.Geometry.Point([-41.4329728109325, -12.57788396003372])\n# Import the Landsat 8 TOA image collection.\nl8 = ee.ImageCollection('LANDSAT/LC08/C02/T1')\n# Get the least cloudy image in 2015\nimage = l8.filterBounds(point).filterDate(\n    '2015-01-01', '2015-12-31').sort('CLOUD_COVER').first()\n# Function example\n\n\ndef add_ndvi(image):\n    ndvi = image.normalizedDifference(['B5', 'B4']).rename('NDVI')\n    return image.addBands(ndvi)\n", "functions": ["unknown_function.select", "add_ndvi"], "external_vars": ["image", "add_ndvi"], "defined_vars": ["ndvi"], "parameters": ["NDVI", "image"], "libraries": ["import ee", "import geemap"]}
{"code": "# Create a point geometry.\npoint = ee.Geometry.Point(114.20, 22.2643)\n", "task": "Using the Earth Engine library (`ee`), define a point geometry variable named `point` with coordinates (114.2, 22.2643).", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Geometry.Point"], "external_vars": ["ee"], "defined_vars": ["point"], "parameters": [114.2, 22.2643], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the region of interest (ROI)\nregion = ee.Geometry.Polygon(\n    [[[-2.2306549784793788, 15.086386354319199],\n      [-2.2306549784793788, 14.86251338003007],\n      [-1.937114023889535, 14.86251338003007],\n      [-1.937114023889535, 15.086386354319199]]], None, False)\n", "task": "Using the ee library, define a variable named \"region\" as a polygon geometry with the following coordinates: [[-2.2306549784793788, 15.086386354319199], [-2.2306549784793788, 14.86251338003007], [-1.937114023889535, 14.86251338003007], [-1.937114023889535, 15.086386354319199]].", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee"], "defined_vars": ["region"], "parameters": [null, false, "[[[-2.2306549784793788, 15.086386354319199], [-2.2306549784793788, 14.86251338003007], [-1.937114023889535, 14.86251338003007], [-1.937114023889535, 15.086386354319199]]]"], "libraries": ["import geemap", "import ee"]}
{"code": "# Make a feature without geometry and set the properties to the dictionary of means.\nfeature = ee.Feature(None, means)\n", "task": "Define a variable named `feature` as an Earth Engine Feature with no geometry and a dictionary of properties named `means`. Make sure to use the variables `ee` and `means` in your code.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Define the region of interest.\nregion = ee.Geometry.Polygon([[[80.00572880873028, 13.274754435874124], [80.00544985899273, 13.274749214792516], [\n                             80.00545187859075, 13.274484752924272], [80.00573149888055, 13.274486710832019]]])\n# Load a Landsat TOA image.\nimage = ee.Image('LANDSAT/LC8_L1T_TOA/LC81420512013105LGN01')\n# Get a dictionary of means in the region.\nmeans = image.reduceRegion(reducer=ee.Reducer.first(),\n                           geometry=region, scale=30)\n", "functions": ["ee.Feature"], "external_vars": ["ee", "means"], "defined_vars": ["feature"], "parameters": [null, "means"], "libraries": ["import ee", "import geemap"]}
{"code": "def func_(img):\n    ndvi = img.select('NDVI').multiply(0.0001)\n    qa = img.select('QA')\n    cloud = bitwiseExtract(qa, 1)\n    shadow = bitwiseExtract(qa, 2)\n    cloud_shadow_pixels = cloud.eq(1) or (shadow.eq(1))\n    cloud_shadow_mask = ndvi.updateMask(cloud_shadow_pixels)\n    return cloud_shadow_mask.copyProperties(img, img.propertyNames())\n\nndvi_mask = noaa_ndvi.map(func_)\n\nMap.addLayer(noaa_ndvi.filterDate('1985-05-01','1985-06-01').toBands(), {},'ndvi_original',False)\nMap.addLayer(ndvi_mask.filterDate('1985-05-01','1985-06-01').toBands(), {},'ndvi_masked',False)\n", "task": "Define a function called `func_` that takes an image `img` as input and returns a cloud-shadow masked NDVI image. The function should perform the following operations:\\n\\n1. Extract the NDVI band from the image and multiply it by 0.0001 to convert it to a decimal value.\\n2. Extract the QA band from the image.\\n3. Use the `bitwiseExtract` function to extract the cloud bit (bit 1) and the shadow bit (bit 2) from the QA band.\\n4. Create a boolean mask that identifies cloud or shadow pixels by checking if the cloud or shadow bits are equal to 1.\\n5. Apply the mask to the NDVI image using the `updateMask` function.\\n6. Copy the properties of the original image to the masked image using the `copyProperties` function.\\n\\nAfter defining the `func_` function, use it to map the `noaa_ndvi` image and create a new image called `ndvi_mask` containing the masked NDVI values. Finally, use the `Map.addLayer` function to add both the original and masked NDVI images to the map, filtering the data to the period between May 1st and June 1st, 1985. Make sure to define the following variables: `ndvi`, `ndvi_mask`, `cloud_shadow_mask`, `img`, `qa`, `cloud`, `cloud_shadow_pixels`, `shadow`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\nnoaa_ndvi = ee.ImageCollection(\n    'NOAA/CDR/AVHRR/NDVI/V5').select(['NDVI', 'QA']).filterDate('1985', '1987')\n\n\ndef bitwiseExtract(input, fromBit, toBit=None):\n    if toBit == None:\n        toBit = fromBit\n    maskSize = ee.Number(1).add(toBit).subtract(fromBit)\n    mask = ee.Number(1).leftShift(maskSize).subtract(1)\n    return input.rightShift(fromBit).bitwiseAnd(mask)\n", "functions": ["unknown_function.multiply", "img.select", "img.select", "bitwiseExtract", "bitwiseExtract", "cloud.eq", "shadow.eq", "ndvi.updateMask", "cloud_shadow_mask.copyProperties", "img.propertyNames", "noaa_ndvi.map", "Map.addLayer", "unknown_function.toBands", "noaa_ndvi.filterDate", "Map.addLayer", "unknown_function.toBands", "ndvi_mask.filterDate"], "external_vars": ["Map", "noaa_ndvi", "bitwiseExtract", "func_"], "defined_vars": ["qa", "cloud_shadow_pixels", "ndvi", "shadow", "cloud_shadow_mask", "ndvi_mask", "cloud", "img"], "parameters": [0.0001, "NDVI", "QA", "qa", 1, "qa", 2, 1, 1, "cloud_shadow_pixels", "img", "func_", "ndvi_original", false, "1985-05-01", "1985-06-01", "ndvi_masked", false, "1985-05-01", "1985-06-01", "img.propertyNames()", "noaa_ndvi.filterDate('1985-05-01', '1985-06-01').toBands()", "{}", "ndvi_mask.filterDate('1985-05-01', '1985-06-01').toBands()", "{}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the ERA5 dataset and filter it by time and region of interest.\nERA5 = ee.ImageCollection('ECMWF/ERA5_LAND/MONTHLY_AGGR') .filter(ee.Filter.calendarRange(2020, 2023, 'year')) .filter(ee.Filter.calendarRange(1, 12, 'month')) .map(lambda image: image.clip(peninsula))\n", "task": "Define a variable called `ERA5` that represents an Earth Engine ImageCollection containing monthly aggregated ERA5 land data from 2020 to 2023 for the entire year, clipped to the region defined by the `peninsula` geometry. Use the `ee` library for Earth Engine operations.  The `image` variable represents a single image within the ImageCollection, and should be clipped to the `peninsula` geometry using the `clip` function.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the region of interest (ROI) as a polygon.\npeninsula = ee.Geometry.Polygon([[[-59.95761783573391, -63.47027086385727], [-60.00156314823391, -63.72430838809856], [-59.90268619510891, -63.850478274051596], [-58.10092838260891, -64.54856148515674], [-57.39780338260891, -64.62870606429087], [-56.87045963260891, -64.58159077408938], [-56.49692447635891, -64.34954328808792], [-56.49692447635891, -64.12031784565966], [-57.04624088260891, -63.966442709295826], [-56.71665103885891, -63.68050259008884],\n                                [-55.61801822635891, -63.621989359411735], [-55.22251041385891, -63.46536326642057], [-54.60727603885891, -63.53399306066353], [-54.32163150760891, -63.32760830259313], [-54.73911197635891, -63.27330915962219], [-54.58530338260891, -63.169362717394144], [-55.49716861698391, -62.88032566483948], [-56.84848697635891, -62.85026153286475], [-57.13413150760891, -63.074993547686454], [-58.25473697635891, -63.278249674148896], [-58.91391666385891, -63.18423509431014]]])\n", "functions": ["unknown_function.map", "unknown_function.filter", "unknown_function.filter", "ee.ImageCollection", "ee.Filter.calendarRange", "ee.Filter.calendarRange", "image.clip"], "external_vars": ["ee", "image", "peninsula"], "defined_vars": ["ERA5"], "parameters": ["ECMWF/ERA5_LAND/MONTHLY_AGGR", 2020, 2023, "year", 1, 12, "month", "peninsula", "lambda image: image.clip(peninsula)", "ee.Filter.calendarRange(1, 12, 'month')", "ee.Filter.calendarRange(2020, 2023, 'year')"], "libraries": ["import ee", "import geemap"]}
{"code": "thr2 = modis2023.gt(0.1)\nmask2023 = thr2.updateMask(thr2)\n", "task": "Create a boolean mask `mask2023` from the `modis2023` array, where values greater than 0.1 are True, and then define a variable `thr2` that is the result of this comparison.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n\n\ndef func_(img):\n    band = img.multiply(0.0001)\n    ndwi = band.normalizedDifference(\n        ['sur_refl_b01', 'sur_refl_b02']).rename('ndwi')\n    return ndwi\n\n\nmodis2023 = ee.ImageCollection(\n    'MODIS/061/MOD09Q1').select('sur.*').filterDate('2023', '2024').map(func_).median()\n", "functions": ["modis2023.gt", "thr2.updateMask"], "external_vars": ["modis2023"], "defined_vars": ["mask2023", "thr2"], "parameters": [0.1, "thr2"], "libraries": ["import ee", "import geemap"]}
{"code": "# Center the map on the local area.\nMap.setCenter(-106.84, 32.25, 11)\n", "task": "Using the Map object, set the center of the map to the coordinates (-106.84, 32.25) and zoom to level 11.", "exec_path": "GEE", "context": "import geemap\nMap = geemap.Map()\n", "functions": ["Map.setCenter"], "external_vars": ["Map"], "defined_vars": [], "parameters": [32.25, 11, "-106.84"], "libraries": ["import geemap"]}
{"code": "ph = soil(\"OpenLandMap/SOL/SOL_PH-H2O_USDA-4C1A2A_M/v02\", 'b0', 'ph')\nclay = soil(\"OpenLandMap/SOL/SOL_CLAY-WFRACTION_USDA-3A1A1A_M/v02\", 'b0', 'clay')\n", "task": "Using the `soil` function, define variables `ph` and `clay` based on the provided soil data.  Note that the `soil` function requires three arguments: the dataset name, the band name, and the variable name.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ntable = ee.FeatureCollection('WWF/HydroSHEDS/v1/Basins/hybas_5')\ncor = [11.279492187499986, 51.39420666042534]\npoint = ee.Geometry.Point(cor)\nroi = table.filterBounds(point)\n\n\ndef soil(id, band, name):\n    image = ee.Image(id).select(band)\n    Map.addLayer(image.clip(roi), {}, name, False)\n    stat = image.reduceRegion(reducer=ee.Reducer.mean().combine(\n        reducer2=ee.Reducer.minMax(), sharedInputs=True), geometry=roi, scale=250)\n    print('statistical information for ' + name, stat)\n    return image\n", "functions": ["soil", "soil"], "external_vars": ["soil"], "defined_vars": ["ph", "clay"], "parameters": ["OpenLandMap/SOL/SOL_PH-H2O_USDA-4C1A2A_M/v02", "b0", "ph", "OpenLandMap/SOL/SOL_CLAY-WFRACTION_USDA-3A1A1A_M/v02", "b0", "clay"], "libraries": ["import geemap", "import ee"]}
{"code": "# Display the pansharpened image\nvis_params = {\n    'min': 0.0,\n    'max': 0.3,\n    'gamma': 1.0,\n    'bands': ['red', 'green', 'blue']\n}\nMap.addLayer(sharpened_image, vis_params, 'Pansharpened Landsat Image')\n", "task": "Add a layer to the map called \"Pansharpened Landsat Image\" using the `sharpened_image` variable and the `vis_params` dictionary, which should be defined with the following values: `min`: 0.0, `max`: 0.3, `gamma`: 1.0, and `bands`: [\"red\", \"green\", \"blue\"].", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the Landsat collection\nLandsat_collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA').filterDate(\n    '2019-04-01', '2019-12-30').filterMetadata('CLOUD_COVER', 'Less_Than', 20)\n# Reduce the collection to get the mean image\nmean_image = Landsat_collection.reduce(ee.Reducer.mean())\n# Define the RGB bands\nrgb_bands = ['B4_mean', 'B3_mean', 'B2_mean']\n# Convert the RGB image to HSV space\nhsv_image = mean_image.select(rgb_bands).rgbToHsv()\n# Define the panchromatic band\npanchromatic_band = mean_image.select('B8_mean')\n# Pansharpen the image by combining the HSV and panchromatic bands\nsharpened_image = ee.Image.cat([hsv_image.select(\n    'hue'), hsv_image.select('saturation'), panchromatic_band]).hsvToRgb()\n", "functions": ["Map.addLayer"], "external_vars": ["sharpened_image", "Map"], "defined_vars": ["vis_params"], "parameters": ["sharpened_image", "vis_params", "Pansharpened Landsat Image"], "libraries": ["import geemap", "import ee"]}
{"code": "co = ee.ImageCollection(\"COPERNICUS/S5P/NRTI/L3_CO\").select(['CO_column_number_density'],['CO']).filterDate(time_start, time_end).filterBounds(roi)\n", "task": "Using the Earth Engine library (ee), load the Copernicus Sentinel-5P carbon monoxide (CO) data collection. Filter the data to include only observations within the specified time range (time_start, time_end) and within the specified region of interest (roi). Rename the \"CO_column_number_density\" band to \"CO\". Define a variable named \"co\" to store the resulting filtered and renamed image collection. ", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [[51.09050885517992, 35.57496936569026], [51.58214703877367, 35.57496936569026], [51.58214703877367,\n                                                                                        35.85149920592443], [51.09050885517992, 35.85149920592443], [51.09050885517992, 35.57496936569026]]\ngeometry = ee.Geometry.Polygon(cor)\ntable = ee.FeatureCollection('FAO/GAUL/2015/level1')\nroi = table.filterBounds(geometry).map(lambda feature: feature.simplify(500))\ntime_start = '2019'\ntime_end = '2024'\n", "functions": ["unknown_function.filterBounds", "unknown_function.filterDate", "unknown_function.select", "ee.ImageCollection"], "external_vars": ["ee", "roi", "time_start", "time_end"], "defined_vars": ["co"], "parameters": ["roi", "time_start", "time_end", "COPERNICUS/S5P/NRTI/L3_CO", "['CO_column_number_density']", "['CO']"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define a function to extract bits from a number\ndef bitwise_extract(input, from_bit, to_bit):\n    mask_size = 1 + to_bit - from_bit\n    mask = (1 << mask_size) - 1\n    return input.rightShift(from_bit).bitwise_and(mask)\n", "task": "Extract a sequence of bits from a given input value, starting at bit position `from_bit` and ending at `to_bit`.  Assume `from_bit` and `to_bit` are integers representing bit positions within the input, and `input` is an integer.  First, calculate `mask_size` which represents the number of bits to extract.  Then, create a bit mask `mask` that has `mask_size` bits set to 1.  Finally, right shift the input value by `from_bit` positions, then perform a bitwise AND operation with the mask to extract the desired bit sequence.  Return the extracted bit sequence as an integer. ", "exec_path": "GEE", "context": "", "functions": ["unknown_function.bitwise_and", "input.rightShift"], "external_vars": [], "defined_vars": ["to_bit", "input", "mask", "mask_size", "from_bit"], "parameters": ["mask", "from_bit"], "libraries": []}
{"code": "#v ci: vegetation condition index\nndvi_min = ndvi.min().multiply(0.0001)\nndvi_max = ndvi.max().multiply(0.0001)\n", "task": "Calculate the minimum and maximum values of the `ndvi` variable, scaling them by 0.0001 and storing the results in variables named `ndvi_min` and `ndvi_max` respectively.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\ntime_start = '2001'\ntime_end = '2024'\nndvi = ee.ImageCollection(\n    'MODIS/061/MOD13A2').select('NDVI').filterDate(time_start, time_end)\n", "functions": ["unknown_function.multiply", "ndvi.min", "unknown_function.multiply", "ndvi.max"], "external_vars": ["ndvi"], "defined_vars": ["ndvi_min", "ndvi_max"], "parameters": [0.0001, 0.0001], "libraries": ["import ee", "import geemap"]}
{"code": "# Add NDVI to each image in the collection.\ndef add_ndvi(image):\n  ndvi = image.normalizedDifference(['B5', 'B4'])\n  return image.addBands(ndvi)\nwith_ndvi = l8.map(add_ndvi)\n", "task": "Define a function called `add_ndvi` that takes an image as input and calculates the Normalized Difference Vegetation Index (NDVI) using bands `B5` and `B4`. Add the NDVI band to the original image and return the updated image. Apply the `add_ndvi` function to the image collection `l8` using the `map` function and store the result in a variable called `with_ndvi`. This will create a new image collection with the NDVI band added to each image. You will need to define the variables `ndvi` and `image` within the `add_ndvi` function.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the LANDSAT 8 collection and the image of interest.\nl8 = ee.ImageCollection('LANDSAT/LC8_L1T_TOA')\nimage = ee.Image('LANDSAT/LC8_L1T_TOA/LC80440342013106LGN01')\n", "functions": ["image.normalizedDifference", "image.addBands", "l8.map"], "external_vars": ["add_ndvi", "l8"], "defined_vars": ["image", "ndvi", "with_ndvi"], "parameters": ["ndvi", "add_ndvi", "['B5', 'B4']"], "libraries": ["import ee", "import geemap"]}
{"code": "# Display the slope layer on the map\nMap.addLayer(slope, {'min': 0, 'max': 60}, 'slope')\n", "task": "Add a layer to the map called \"slope\" using the `slope` variable. Set the minimum value to 0 and the maximum value to 60. You will need to define the following variables: `slope`, `Map`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the SRTM elevation dataset\nsrtm = ee.Image('USGS/SRTMGL1_003')\n# Compute the slope of the terrain\nslope = ee.Terrain.slope(srtm)\n", "functions": ["Map.addLayer"], "external_vars": ["slope", "Map"], "defined_vars": [], "parameters": ["slope", "slope", "{'min': 0, 'max': 60}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Load the TIGER counties feature collection.\ncounties = ee.FeatureCollection(\"TIGER/2018/Counties\")\n", "task": "Using the Earth Engine library (ee), load the counties feature collection from the TIGER/2018 dataset and assign it to the variable `counties`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.FeatureCollection"], "external_vars": ["ee"], "defined_vars": ["counties"], "parameters": ["TIGER/2018/Counties"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the Sentinel-2 image collection.\ns2 = ee.ImageCollection(\"COPERNICUS/S2_SR\")\n", "task": "Using the Earth Engine library (ee), define a variable named \"s2\" to represent an ImageCollection containing Sentinel-2 Surface Reflectance data.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["s2"], "parameters": ["COPERNICUS/S2_SR"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the SRTM image.\nsrtm = ee.Image(\"USGS/SRTMGL1_003\")\n", "task": "Using the Earth Engine library (ee), load the SRTMGL1_003 dataset and assign it to the variable \"srtm\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["srtm"], "parameters": ["USGS/SRTMGL1_003"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the Sentinel-2 Harmonized Image Collection\ns2 = ee.ImageCollection(\"COPERNICUS/S2_HARMONIZED\")\n", "task": "Define a variable named `s2` and assign it to an Earth Engine ImageCollection representing Sentinel-2 data from the `COPERNICUS/S2_HARMONIZED` dataset. Use the `ee` object to access the ImageCollection.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["s2"], "parameters": ["COPERNICUS/S2_HARMONIZED"], "libraries": ["import ee", "import geemap"]}
{"code": "# Center the map on the specified point and set the zoom scale.\nMap.centerObject(Center, 10)\n\n\n", "task": "Center the object represented by the variable `Center` on the `Map`, using a radius of 10. You will need to define variables called `Map` and `Center` before executing this instruction.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the geometry of the polygon.\ngeometry = ee.Geometry.Polygon([[[80.10183335525426, 13.230672625887738], [80.05656717206216, 13.137205937618688], [80.18635883400759, 13.029369836387078], [\n                               80.27293939621313, 13.070697852771913], [80.23910191360892, 13.225071980237688], [80.14695379641421, 13.251198504411965]]])\n# Define the center point for the map.\nCenter = ee.Geometry.Point(80.1686, 13.1624)\n", "functions": ["Map.centerObject"], "external_vars": ["Map", "Center"], "defined_vars": [], "parameters": ["Center", 10], "libraries": ["import ee", "import geemap"]}
{"code": "# Define a function to filter burn dates with uncertainty less than 25 days\ndef conf_filter_MOD(image):\n    \"\"\"\n    Filters burn dates with uncertainty less than 25 days.\n\n    Args:\n        image (ee.Image): The burn date image.\n\n    Returns:\n        ee.Image: The filtered burn date image.\n    \"\"\"\n\n    return image.updateMask(image.select('Uncertainty').lte(25))\n", "task": "Convert the image stored in the variable `image` to grayscale.", "exec_path": "GEE", "context": "", "functions": ["image.updateMask", "unknown_function.lte", "image.select"], "external_vars": [], "defined_vars": ["image"], "parameters": [25, "Uncertainty", "image.select('Uncertainty').lte(25)"], "libraries": []}
{"code": "# Define a function to add NDVI to an image.\ndef add_ndvi(image):\n    ndvi = image.normalizedDifference(['B5', 'B4']).rename('NDVI')\n    return image.addBands(ndvi)\n", "task": "Define a function called `add_ndvi` that takes an image as input, calculates the Normalized Difference Vegetation Index (NDVI) using bands B5 and B4, renames the NDVI band to \"NDVI\", and returns the original image with the NDVI band added. Make sure the function uses the following variables: `image`, `ndvi`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the point of interest.\npoint = ee.Geometry.Point([-4.2771148681640625, 55.859225187001805])\n# Load the Landsat 8 collection.\nl8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_TOA')\n# Filter the collection by the point of interest and date range.\nimage = ee.Image(l8.filterBounds(point).filterDate(\n    '2015-01-01', '2015-12-31').sort('CLOUD_COVER').first())\n", "functions": ["unknown_function.rename", "image.normalizedDifference", "image.addBands"], "external_vars": [], "defined_vars": ["ndvi", "image"], "parameters": ["NDVI", "ndvi", "['B5', 'B4']"], "libraries": ["import geemap", "import ee"]}
{"code": "# Adicionar a coleção de imagens ao mapa.\nMap.addLayer(colecao, paramVis, 'Coleção de imagens 2021 Parque do Xingu (432)')\n\n\n", "task": "Add the layer \"Coleção de imagens 2021 Parque do Xingu (432)\" to the map using the provided `colecao` and `paramVis` variables. Make sure that `Map`, `colecao`, and `paramVis` are defined.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Definir variável Parque do Xingu com o dataset de áreas protegidas do UNEP.\nprqXingu = ee.FeatureCollection(\n    'WCMC/WDPA/current/polygons').filter(ee.Filter.eq('NAME', 'Parque do Xingu'))\n# Filtrar a coleção Landsat 9 Level 2, Collection 2, Tier 1 para o ano de 2021 e Parque Nacional do Xingu.\ncolecao = ee.ImageCollection(\n    'LANDSAT/LC09/C02/T1_L2').filterDate('2021-01-01', '2022-01-01').filterBounds(prqXingu)\n# Definir parâmetros de visualização.\nparamVis = {'bands': ['SR_B4', 'SR_B3', 'SR_B2'], min: 500, max: 32000}\n", "functions": ["Map.addLayer"], "external_vars": ["paramVis", "colecao", "Map"], "defined_vars": [], "parameters": ["colecao", "paramVis", "Coleção de imagens 2021 Parque do Xingu (432)"], "libraries": ["import ee", "import geemap"]}
{"code": "urban1975 = ghsl.filter(ee.Filter.eq('system:index', '1975')).toBands()\n", "task": "Using the Earth Engine library (ee) and the GADM dataset (ghsl), filter the GADM dataset to only include features with a \"system:index\" property equal to \"1975\". Convert the filtered features to a band collection and assign the result to the variable \"urban1975\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\ncor = [[50.87050198728251, 35.44558510822678], [51.70546292478251, 35.44558510822678], [51.70546292478251,\n                                                                                        35.98746896328614], [50.87050198728251, 35.98746896328614], [50.87050198728251, 35.44558510822678]]\nroi = ee.Geometry.MultiPolygon(cor)\n# call the gshl product\nghsl = ee.ImageCollection(\n    'JRC/GHSL/P2023A/GHS_BUILT_S').select(['built_surface']).filterBounds(roi)\n", "functions": ["unknown_function.toBands", "ghsl.filter", "ee.Filter.eq"], "external_vars": ["ee", "ghsl"], "defined_vars": ["urban1975"], "parameters": ["system:index", "1975", "ee.Filter.eq('system:index', '1975')"], "libraries": ["import geemap", "import ee"]}
{"code": "sen1 = ee.ImageCollection(\"COPERNICUS/S1_GRD\").select('VV').filterDate('2014','2015').filterBounds(roi).filter(ee.Filter.calendarRange(10, 10, 'month')).filter(ee.Filter.calendarRange(4, 4, 'day_of_month')).filter(ee.Filter.listContains('transmitterReceiverPolarisation','VV')).filter(ee.Filter.eq('instrumentMode','IW')).mosaic()\n", "task": "Using the Earth Engine library (ee), create an image collection called \"sen1\" from the \"COPERNICUS/S1_GRD\" dataset. Select the \"VV\" band and filter the collection to include images taken between 2014 and 2015, within the specified region of interest (roi), in October, on the 4th day of the month, with the \"VV\" polarization, and using the \"IW\" instrument mode. Finally, create a mosaic of the filtered images.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\ncor = [[32.33741352024498, 31.356500050396157], [32.59559223118248, 31.356500050396157], [32.59559223118248,\n                                                                                          31.58490130730319], [32.33741352024498, 31.58490130730319], [32.33741352024498, 31.356500050396157]]\nroi = ee.Geometry.Polygon(cor)\n", "functions": ["unknown_function.mosaic", "unknown_function.filter", "unknown_function.filter", "unknown_function.filter", "unknown_function.filter", "unknown_function.filterBounds", "unknown_function.filterDate", "unknown_function.select", "ee.ImageCollection", "ee.Filter.calendarRange", "ee.Filter.calendarRange", "ee.Filter.listContains", "ee.Filter.eq"], "external_vars": ["ee", "roi"], "defined_vars": ["sen1"], "parameters": ["roi", "2014", "2015", "VV", "COPERNICUS/S1_GRD", 10, 10, "month", 4, 4, "day_of_month", "transmitterReceiverPolarisation", "VV", "instrumentMode", "IW", "ee.Filter.eq('instrumentMode', 'IW')", "ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')", "ee.Filter.calendarRange(4, 4, 'day_of_month')", "ee.Filter.calendarRange(10, 10, 'month')"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define a visualization parameters for the elevation layer.\nelevationVis = {\n    'min': 0,\n    'max': 5000,\n    'palette': ['0000ff', '00ffff', 'ffff00', 'ff0000', 'ffffff']\n}\nMap.setCenter(138.73, 35.36, 11)\nMap.addLayer(elevation, elevationVis, 'Elevation', 0)\n", "task": "Define a variable named `elevationVis` with the following properties: `min`: 0, `max`: 5000, `palette`: `['0000ff', '00ffff', 'ffff00', 'ff0000', 'ffffff']`. Then, use the `Map` object to center the map at longitude 138.73 and latitude 35.36, with a zoom level of 11. Finally, add the `elevation` layer to the map using `elevationVis` as the visualization parameters, label it \"Elevation\", and set the layer index to 0.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the ALOS AW3D30 dataset.\ndataset = ee.ImageCollection('JAXA/ALOS/AW3D30/V3_2')\nelevation = dataset.select('DSM')\n", "functions": ["Map.setCenter", "Map.addLayer"], "external_vars": ["elevation", "Map"], "defined_vars": ["elevationVis"], "parameters": [138.73, 35.36, 11, "elevation", "elevationVis", "Elevation", 0], "libraries": ["import geemap", "import ee"]}
{"code": "# Apply the addNDVI function on the collection\nwithNDVI = naipFourBands.map(addNDVI)\n", "task": "Using the `addNDVI` function, calculate the NDVI for each pixel in the `naipFourBands` image. Store the result in a new variable called `withNDVI`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Step 02: Import addison_county\nnaip = ee.ImageCollection('USDA/NAIP/DOQQ')\ngeometry = ee.FeatureCollection('users/geogenvs150/VERMONT/addison_county')\n# Step 03: Filter NAIP by rectangle and sort by date of acquisition\nnaipMidd = naip.filterBounds(geometry)\n# add year property to each image\n\n\ndef addYear(image):\n    imageYear = image.date().get('year')\n    bandNames = image.bandNames().length()\n    return image.set({'year': imageYear, 'bands': bandNames})\n\n\nnaipMiddWithYears = naipMidd.map(addYear)\n# filter images with more than three bands and then print out list\nnaipFourBands = naipMiddWithYears.filter(ee.Filter.gt('bands', 3))\n# Function for NDVI\n\n\ndef addNDVI(image):\n    ndvi = image.normalizedDifference(['N', 'R']).rename('NDVI')\n    return image.addBands(ndvi)\n", "functions": ["naipFourBands.map"], "external_vars": ["naipFourBands", "addNDVI"], "defined_vars": ["withNDVI"], "parameters": ["addNDVI"], "libraries": ["import geemap", "import ee"]}
{"code": "Map.addLayer(ndvi_smoothed.select('NDVI_median').filterDate('1985-05-01','1985-06-01').toBands(), {},'ndvi_smoothed',False)\n\n\n", "task": "Add a layer to the map named \"ndvi_smoothed\" with the median NDVI values from the `ndvi_smoothed` image collection for the month of May 1985. Ensure the layer is not interactive. **Define the following variables:** `Map` (the map object), `ndvi_smoothed` (the image collection).", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\nnoaa_ndvi = ee.ImageCollection(\n    'NOAA/CDR/AVHRR/NDVI/V5').select(['NDVI', 'QA']).filterDate('1985', '1987')\n\n\ndef bitwiseExtract(input, fromBit, toBit=None):\n    if toBit == None:\n        toBit = fromBit\n    maskSize = ee.Number(1).add(toBit).subtract(fromBit)\n    mask = ee.Number(1).leftShift(maskSize).subtract(1)\n    return input.rightShift(fromBit).bitwiseAnd(mask)\n\n\ndef func_(img):\n    ndvi = img.select('NDVI').multiply(0.0001)\n    qa = img.select('QA')\n    cloud = bitwiseExtract(qa, 1)\n    shadow = bitwiseExtract(qa, 2)\n    cloud_shadow_pixels = cloud.eq(1) or shadow.eq(1)\n    cloud_shadow_mask = ndvi.updateMask(cloud_shadow_pixels)\n    return cloud_shadow_mask.copyProperties(img, img.propertyNames())\n\n\nndvi_mask = noaa_ndvi.map(func_)\ndays = 30\nmillis = ee.Number(days).multiply(1000 * 24 * 3600)\nfilter = ee.Filter.maxDifference(\n    difference=millis, leftField='system:time_start', rightField='system:time_start')\njoin = ee.Join.saveAll(matchesKey='images')\njoined_collection = ee.ImageCollection(\n    join.apply(ndvi_mask, ndvi_mask, filter))\n\n\ndef func_(img):\n    images = ee.ImageCollection.fromImages(\n        img.get('images')).reduce(ee.Reducer.median())\n    return img.addBands(images).copyProperties(img, ['system:time_start', 'system:time_end'])\n\n\nndvi_smoothed = joined_collection.map(func_)\n", "functions": ["Map.addLayer", "unknown_function.toBands", "unknown_function.filterDate", "ndvi_smoothed.select"], "external_vars": ["Map", "ndvi_smoothed"], "defined_vars": [], "parameters": ["ndvi_smoothed", false, "1985-05-01", "1985-06-01", "NDVI_median", "ndvi_smoothed.select('NDVI_median').filterDate('1985-05-01', '1985-06-01').toBands()", "{}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Mask the SRTM image to only show areas below the height threshold.\nsrtm_masked = srtm.updateMask(srtm.lt(height))\n", "task": "Create a new GeoTIFF called `srtm_masked` that represents the SRTM elevation data masked to only include values less than the given `height`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Define the SRTM image.\nsrtm = ee.Image('USGS/SRTMGL1_003')\n# Set the height threshold.\nheight = 1000\n", "functions": ["srtm.updateMask", "srtm.lt"], "external_vars": ["height", "srtm"], "defined_vars": ["srtm_masked"], "parameters": ["height", "srtm.lt(height)"], "libraries": ["import ee", "import geemap"]}
{"code": "# Load a collection of Landsat 8 raw images.\nl8raw = ee.ImageCollection(\"LANDSAT/LC08/C02/T1\")\n", "task": "Using the Earth Engine library (ee), load the Landsat 8 Collection 2 Tier 1 image collection and store it in a variable called \"l8raw\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["l8raw"], "parameters": ["LANDSAT/LC08/C02/T1"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add the SRTM elevation dataset.And the slope to the map.\nMap.addLayer(srtm, {'min': 0, 'max': 3000}, 'DEM')\nMap.addLayer(slope, {'min': 0, 'max': 60}, 'slope')\n", "task": "Add the \"srtm\" and \"slope\" layers to the \"Map\" object with specific color ranges. \"srtm\" should have a minimum value of 0 and a maximum value of 3000, and be labeled \"DEM\". \"slope\" should have a minimum value of 0 and a maximum value of 60, and be labeled \"slope\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the SRTM elevation dataset.\nsrtm = ee.Image('USGS/SRTMGL1_003')\n# Calculate the slope of the SRTM elevation dataset.\nslope = ee.Terrain.slope(srtm)\n", "functions": ["Map.addLayer", "Map.addLayer"], "external_vars": ["srtm", "Map", "slope"], "defined_vars": [], "parameters": ["srtm", "DEM", "slope", "slope", "{'min': 0, 'max': 3000}", "{'min': 0, 'max': 60}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Sum the values of forest loss pixels in the Congo Republic.\nstats = lossImage.reduceRegion(\n  reducer=ee.Reducer.sum(),\n  geometry=congo,\n  scale=30,\n  maxPixels=1e9\n)\nprint('pixels representing loss:', stats.get('loss'))\n", "task": "Calculate the sum of pixels representing loss within the Congo region using the `lossImage` and store the result in a variable called `stats`. Then, print the number of pixels representing loss.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the data and select the bands of interest.\ngfc2014 = ee.Image('UMD/hansen/global_forest_change_2015')\nlossImage = gfc2014.select(['loss'])\n# Load country features from Large Scale International Boundary (LSIB) dataset.\ncountries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017')\n# Subset the Congo Republic feature from countries.\ncongo = countries.filter(ee.Filter.eq('country_na', 'Rep of the Congo'))\n", "functions": ["lossImage.reduceRegion", "ee.Reducer.sum", "print", "stats.get"], "external_vars": ["congo", "ee", "print", "lossImage"], "defined_vars": ["stats"], "parameters": ["pixels representing loss:", "loss", "stats.get('loss')"], "libraries": ["import geemap", "import ee"]}
{"code": "# Select the mean 2m air temperature band\ntemp = era5.select(['mean_2m_air_temperature'])\n", "task": "Using the ERA5 dataset, select the \"mean_2m_air_temperature\" variable and assign it to a new variable named \"temp\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the ERA5 monthly image collection\nera5 = ee.ImageCollection('ECMWF/ERA5/MONTHLY')\n", "functions": ["era5.select"], "external_vars": ["era5"], "defined_vars": ["temp"], "parameters": ["['mean_2m_air_temperature']"], "libraries": ["import geemap", "import ee"]}
{"code": "# Filter the collection by date.And cloud cover\nfiltered = L8.filterDate(start_date, end_date).filterMetadata('CLOUD_COVER', 'less_than', max_cloud_cover)\n", "task": "Filter the Landsat 8 collection (L8) for images between the start and end dates, and with cloud cover less than the maximum specified. Define the filtered collection as \"filtered\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the LANDSAT 8 collection\nL8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_TOA')\n# Define the filter parameters\nstart_date = '2017-01-01'\nend_date = '2017-12-31'\nmax_cloud_cover = 30\n", "functions": ["unknown_function.filterMetadata", "L8.filterDate"], "external_vars": ["end_date", "max_cloud_cover", "L8", "start_date"], "defined_vars": ["filtered"], "parameters": ["CLOUD_COVER", "less_than", "max_cloud_cover", "start_date", "end_date"], "libraries": ["import geemap", "import ee"]}
{"code": "Coleccio_imatges = ee.ImageCollection(\"NOAA/DMSP-OLS/NIGHTTIME_LIGHTS\")\n# Imatges de llums nocturnes del DMSP OLS Defense Meteorological Program (DMSP) Operational Line-Scan System (OLS)\nllums_nocturnes = ee.Image(Coleccio_imatges)\nprint(llums_nocturnes)\n", "task": "Using the Earth Engine library (`ee`), load the nighttime lights data from the NOAA/DMSP-OLS collection and store it in a variable named `Coleccio_imatges`. Then, select a single image from this collection and store it in a variable called `llums_nocturnes`. Finally, print the selected image using the `print` function.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection", "ee.Image", "print"], "external_vars": ["print", "ee"], "defined_vars": ["llums_nocturnes", "Coleccio_imatges"], "parameters": ["NOAA/DMSP-OLS/NIGHTTIME_LIGHTS", "Coleccio_imatges", "llums_nocturnes"], "libraries": ["import geemap", "import ee"]}
{"code": "MVI_clipped = MVI.clip(ROI)\n", "task": "Define a new variable `MVI_clipped` by clipping the `MVI` variable using the region of interest `ROI`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# add the entire World shapefile\nworldBorders = ee.FeatureCollection('FAO/GAUL/2015/level2')\nPhilFilter = ee.Filter.eq('ADM2_NAME', 'Surigao Del Sur')\n# Filter the global data to get only Surigao Del Sur.\nSDelSur = worldBorders.filter(PhilFilter)\nROI = SDelSur\n# Level 1C data and can be applied to either L1C or L2A collections.\ncsPlus = ee.ImageCollection('GOOGLE/CLOUD_SCORE_PLUS/V1/S2_HARMONIZED')\nS2 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')\nQA_BAND = 'cs_cdf'\n# Higher values will remove thin clouds, haze & cirrus shadows.\nCLEAR_THRESHOLD = 0.7\n# Make a clear median composite.\ncomposite = S2.filterBounds(ROI).filterDate('2019-01-01', '2020-12-31').linkCollection(\n    csPlus, [QA_BAND]).map(lambda img: img.updateMask(img.select(QA_BAND).gte(CLEAR_THRESHOLD))).median()\n# Select the necessary bands\ngreen = composite.select('B3')\nNIR = composite.select('B8')\nSWIR1 = composite.select('B11')\nMVI = composite.expression('(NIR-green)/(SWIR1-green)',\n                           {'green': green, 'NIR': NIR, 'SWIR1': SWIR1})\n", "functions": ["MVI.clip"], "external_vars": ["MVI", "ROI"], "defined_vars": ["MVI_clipped"], "parameters": ["ROI"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the MODIS EVI dataset\nMODIS = ee.ImageCollection('MODIS/006/MOD13Q1')\nMODIS = MODIS.filterDate('2018-03-01', '2018-08-10')\n", "task": "Using the ee library, define a variable named MODIS and assign it an ImageCollection from the MODIS/006/MOD13Q1 dataset. Then, filter the collection to only include images between March 1st, 2018 and August 10th, 2018.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection", "MODIS.filterDate"], "external_vars": ["ee"], "defined_vars": ["MODIS"], "parameters": ["MODIS/006/MOD13Q1", "2018-03-01", "2018-08-10"], "libraries": ["import geemap", "import ee"]}
{"code": "forest_thr = canopy.gt(0)\nforest = canopy.updateMask(forest_thr)\n", "task": "Create a boolean mask named \"forest_thr\" by checking if the values in the \"canopy\" array are greater than 0. Then, use this mask to update the \"canopy\" array, creating a new array named \"forest\" that only contains values where the mask is True.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\ncanopy = ee.ImageCollection(\n    'projects/meta-forest-monitoring-okw37/assets/CanopyHeight').mosaic()\n", "functions": ["canopy.gt", "canopy.updateMask"], "external_vars": ["canopy"], "defined_vars": ["forest", "forest_thr"], "parameters": [0, "forest_thr"], "libraries": ["import geemap", "import ee"]}
{"code": "# Display the median composite.\nMap.addLayer(median, visParams, 'median')\n", "task": "Add the median layer to the map, using the given visParams and label it as \"median\". Make sure to define the variables \"median\", \"Map\", and \"visParams\" before executing this instruction.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the Landsat 8 TOA collection.\nl8 = ee.ImageCollection('LANDSAT/LC08/C02/T1')\n# Filter the collection by date.\nl8_2016 = l8.filterDate('2016-01-01', '2016-12-31')\n# Compute the median composite.\nmedian = l8_2016.median()\n# Define visualization parameters.\nvisParams = {'bands': ['B4', 'B3', 'B2'], 'max': 0.3}\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "visParams", "median"], "defined_vars": [], "parameters": ["median", "visParams", "median"], "libraries": ["import geemap", "import ee"]}
{"code": "# Apply the cloud masking function over one year of data\ns2filtered = s2.filterDate('2017-01-01', '2017-12-31') .filterMetadata('CLOUDY_PIXEL_PERCENTAGE', 'less_than', 10) .map(maskS2clouds) .select('B.*')\n", "task": "Using the external variables `s2` and `maskS2clouds`, filter the Sentinel-2 dataset `s2` for the year 2017, select images with a cloudy pixel percentage less than 10%, apply the `maskS2clouds` function to each image, and select only bands starting with \"B\". Define the resulting filtered dataset as `s2filtered`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Load the Sentinel-2 TOA reflectance data\ns2 = ee.ImageCollection('COPERNICUS/S2')\n# Define a function to mask clouds using the Sentinel-2 QA band\n\n\ndef maskS2clouds(image):\n    \"\"\"\n    Function to mask clouds using the Sentinel-2 QA band.\n\n    Args:\n        image (ee.Image): Sentinel-2 image\n\n    Returns:\n        ee.Image: Sentinel-2 image with clouds masked\n    \"\"\"\n    qa = image.select('QA60')\n    cloud_bit_mask = ee.Number(2).pow(10).int()\n    cirrus_bit_mask = ee.Number(2).pow(11).int()\n    mask = qa.bitwiseAnd(cloud_bit_mask).eq(\n        0) and qa.bitwiseAnd(cirrus_bit_mask).eq(0)\n    return image.updateMask(mask).divide(10000)\n", "functions": ["unknown_function.select", "unknown_function.map", "unknown_function.filterMetadata", "s2.filterDate"], "external_vars": ["s2", "maskS2clouds"], "defined_vars": ["s2filtered"], "parameters": ["B.*", "maskS2clouds", "CLOUDY_PIXEL_PERCENTAGE", "less_than", 10, "2017-01-01", "2017-12-31"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add the image collection to the map.\nMap.addLayer(image_collection, {}, 'image_collection')\n\n\n", "task": "Add the `image_collection` to the `Map` with the layer name \"image_collection\". **Required Variables:** `image_collection`, `Map`", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the geometry of the study area.\ngeometry = ee.Geometry.Polygon([[-0.831530669699112, 42.64129586043597], [-0.831530669699112, 37.32568333218967], [\n                               7.166516205300888, 37.32568333218967], [7.166516205300888, 42.64129586043597]])\n# Define the start and end dates of the time series.\nstart_date = ee.Date('2017-01-01')\nend_date = ee.Date('2020-12-31')\n# Get the MODIS Aqua Standard Mapped Image data for the study area and time period.\nimage_collection = ee.ImageCollection('NASA/OCEANDATA/MODIS-Aqua/L3SMI').filterDate(\n    start_date, end_date).filterBounds(geometry).select('chlor_a')\n", "functions": ["Map.addLayer"], "external_vars": ["image_collection", "Map"], "defined_vars": [], "parameters": ["image_collection", "image_collection", "{}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Display an image of the study area for vegetation analysis.\nMap.addLayer(studyArea_clipped, {'bands': ['B11', 'B8', 'B4'], 'min': 0, 'max': 4000}, 'Vegetation Analysis', False)\n", "task": "Add a layer to the map called \"Vegetation Analysis\" using the `studyArea_clipped` image. Display bands B11, B8, and B4 with a minimum value of 0 and a maximum value of 4000. Make sure to define the variables `studyArea_clipped` and `Map` before running this code.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the Sunraysia region of interest.\nSunraysia = ee.Geometry.Polygon([[140.24252010057364, -33.878291364895354], [140.24252010057364, -34.70087292355624], [\n                                142.49471736619864, -34.70087292355624], [142.49471736619864, -33.878291364895354]])\n# Load the Sentinel-2 Level 2A image collection.\ns2l2a = ee.ImageCollection('COPERNICUS/S2_SR')\n# Filter the image collection by date and cloud cover.\nstudyArea = s2l2a.filterBounds(Sunraysia).filterDate(\n    '2020-01-01', '2021-11-30').filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10)).mean()\n# Clip the study area to the Sunraysia region.\nstudyArea_clipped = studyArea.clip(Sunraysia)\n", "functions": ["Map.addLayer"], "external_vars": ["studyArea_clipped", "Map"], "defined_vars": [], "parameters": ["studyArea_clipped", "Vegetation Analysis", false, "{'bands': ['B11', 'B8', 'B4'], 'min': 0, 'max': 4000}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the hillshade layer to the map.\nvisParams = {'min': 0, 'max': 255}\nMap.addLayer(hillshade, visParams, 'Hillshade', False)\n", "task": "Define a variable called `visParams` with a minimum value of 0 and a maximum value of 255. Then, add the layer `hillshade` to the `Map` object using the defined `visParams`, label it as \"Hillshade\", and set it to be initially hidden.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the SRTM DEM image.\nsrtm = ee.Image('CGIAR/SRTM90_V4')\n# Calculate the hillshade from the SRTM DEM.\nhillshade = ee.Terrain.hillshade(srtm, 270, 45)\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "hillshade"], "defined_vars": ["visParams"], "parameters": ["hillshade", "visParams", "Hillshade", false], "libraries": ["import geemap", "import ee"]}
{"code": "# Get the projection information for Band 1.\nband_1_projection = image.select('B1').projection()\nprint('Band 1 projection:', band_1_projection)\n", "task": "Using the provided `image` object, select band `B1` and calculate its projection. Store the result in a new variable named `band_1_projection`. Then, use the `print` function to display the calculated projection.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the LANDSAT 8 image to analyze.\nimage = ee.Image('LANDSAT/LC08/C02/T1/LC08_044034_20140318')\n", "functions": ["unknown_function.projection", "image.select", "print"], "external_vars": ["image", "print"], "defined_vars": ["band_1_projection"], "parameters": ["B1", "Band 1 projection:", "band_1_projection"], "libraries": ["import geemap", "import ee"]}
{"code": "#1. Look for areas with high NDWI values in specific years which might indicate flooding events.\n#2. Examine the inundation frequency map to identify areas that are frequently submerged.\n#3. Correlate the findings with historical flood or rainfall data for a more comprehensive interpretation.\n# More advance cloud masking function\n# Define the cloud mask function using the QA_PIXEL band.\ndef cloudfunction(image):\n    #Select the QA_PIXEL band.\n    QA = image.select('QA_PIXEL')\n    #Define the cloud mask bit using the 'Cloud' attribute.\n    cloudMaskBit = 1 << 3\n    #Create a mask that identifies pixels not flagged as clouds.\n    mask = QA.bitwiseAnd(cloudMaskBit).eq(0)\n    #Return the image with cloudy pixels masked.\n    return image.updateMask(mask)\n", "task": "Create a function called `cloudfunction` that takes an image as input.  Within the function, select the `QA_PIXEL` band from the image and store it in the variable `QA`.  Then, define a variable `cloudMaskBit` with the value 1 shifted left by 3 bits.  Next, create a mask by performing a bitwise AND operation between `QA` and `cloudMaskBit`, and then checking if the result is equal to 0.  Store this mask in the variable `mask`.  Finally, update the input image with the created mask and return the updated image.  Ensure that the following variables are defined before calling this function: `QA`, `cloudMaskBit`, `mask`, `image`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Make a function to mask the clouds (adjust the threshold if necessary)\ncloudThresh = 20\n", "functions": ["image.select", "unknown_function.eq", "QA.bitwiseAnd", "image.updateMask"], "external_vars": [], "defined_vars": ["mask", "QA", "image", "cloudMaskBit"], "parameters": ["QA_PIXEL", 0, "cloudMaskBit", "mask"], "libraries": ["import geemap", "import ee"]}
{"code": "Map.addLayer(change.gt(7).clip(roi),{},'flood_thr', False) \n", "task": "Add a layer to the Map named \"flood_thr\" representing areas where the \"change\" variable is greater than 7, clipped to the \"roi\" region.  The layer should be added without any styling.  The following variables need to be defined: [\"change\", \"roi\", \"Map\"].", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ncor = [[54.07394733345745, 36.81321992370517], [54.79904498970745, 36.81321992370517], [54.79904498970745,\n                                                                                        37.45259869689526], [54.07394733345745, 37.45259869689526], [54.07394733345745, 36.81321992370517]]\nroi = ee.Geometry.Polygon(cor)\nyear_start = '2019'\nyear_end = '2020'\nafter = ee.ImageCollection('COPERNICUS/S1_GRD').filterBounds(roi).filterDate(year_start, year_end).filter(ee.Filter.calendarRange(3, 3, 'month')).filter(ee.Filter.listContains(\n    'transmitterReceiverPolarisation', 'VV')).filter(ee.Filter.eq('instrumentMode', 'IW')).select('VV').map(lambda img: img.focalMedian(100, 'square', 'meters').copyProperties(img, img.propertyNames())).min()\nbefore = ee.ImageCollection('COPERNICUS/S1_GRD').filterBounds(roi).filterDate(year_start, year_end).filter(ee.Filter.calendarRange(2, 2, 'month')).filter(ee.Filter.listContains(\n    'transmitterReceiverPolarisation', 'VV')).filter(ee.Filter.eq('instrumentMode', 'IW')).select('VV').map(lambda img: img.focalMedian(100, 'square', 'meters').copyProperties(img, img.propertyNames())).min()\nchange = before.subtract(after).rename('flood')\n", "functions": ["Map.addLayer", "unknown_function.clip", "change.gt"], "external_vars": ["Map", "roi", "change"], "defined_vars": [], "parameters": ["flood_thr", false, "roi", 7, "change.gt(7).clip(roi)", "{}"], "libraries": ["import geemap", "import ee"]}
{"code": "# trend analysis\naot_trend = aot.reduce(ee.Reducer.kendallsCorrelation())\n", "task": "Calculate the Kendall\\'s correlation trend of the AOT data using the `ee.Reducer.kendallsCorrelation()` method. Store the resulting trend data in a variable named `aot_trend`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\naot = ee.ImageCollection('NASA/GSFC/MERRA/aer/2').select('DUSCATAU').filterDate(\n    '2020', '2021').filter(ee.Filter.calendarRange(12, 12, 'hour'))\n", "functions": ["aot.reduce", "ee.Reducer.kendallsCorrelation"], "external_vars": ["ee", "aot"], "defined_vars": ["aot_trend"], "parameters": ["ee.Reducer.kendallsCorrelation()"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the geometry of a point using its coordinates.\ngeometry = ee.Geometry.Point([103.08836120221319, 5.408336927461861])\n", "task": "Using the Earth Engine library (ee), define a variable named \"geometry\" that represents a point with the coordinates [103.08836120221319, 5.408336927461861].", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Geometry.Point"], "external_vars": ["ee"], "defined_vars": ["geometry"], "parameters": ["[103.08836120221319, 5.408336927461861]"], "libraries": ["import geemap", "import ee"]}
{"code": "# Visualize FireCCI51 for the year 2019\ndataset = ee.ImageCollection('ESA/CCI/FireCCI/5_1').filterDate('2019-01-01', '2019-12-31')\nburnedArea = dataset.select('BurnDate')\n", "task": "Using the Earth Engine library (ee), load the ESA/CCI/FireCCI/5_1 image collection and filter it to only include data from 2019. Define a variable named `dataset` to store the filtered image collection. From this collection, select the `BurnDate` band and store it in a variable named `burnedArea`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["unknown_function.filterDate", "ee.ImageCollection", "dataset.select"], "external_vars": ["ee"], "defined_vars": ["dataset", "burnedArea"], "parameters": ["2019-01-01", "2019-12-31", "ESA/CCI/FireCCI/5_1", "BurnDate"], "libraries": ["import geemap", "import ee"]}
{"code": "# Get the VV.And VH bands from the SAR image.\nVV = SARImage.select(\"VV\")\nVH = SARImage.select(\"VH\")\n", "task": "Using the provided SARImage, select the 'VV' and 'VH' bands and assign them to the variables 'VV' and 'VH', respectively.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Sentinel-1 SAR image collection.\nSentinel1 = ee.ImageCollection('COPERNICUS/S1_GRD')\n# Define the geometry of the area of interest.\ngeometry = ee.Geometry.Polygon([[112.97681537871199, 23.388089271095946], [112.97681537871199, 22.7766325957908], [\n                               113.62500873808699, 22.7766325957908], [113.62500873808699, 23.388089271095946]], None, False)\n# Filter the Sentinel-1 SAR image collection by date and geometry.\nSARImage = Sentinel1.filterDate(\n    '2019-01-01', '2019-02-01').filterBounds(geometry)\n", "functions": ["SARImage.select", "SARImage.select"], "external_vars": ["SARImage"], "defined_vars": ["VH", "VV"], "parameters": ["VV", "VH"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the region of interest\nAmazon = ee.FeatureCollection('users/wangyxtina/3rdScaleUp/AmazoniaLim_Raisg')\nMap.addLayer(Amazon, {}, 'Amazon boundary')\nMap.centerObject(Amazon, 4)\n", "task": "Using the provided variables `ee` and `Map`, define a variable named `Amazon` as an Earth Engine FeatureCollection using the path \"users/wangyxtina/3rdScaleUp/AmazoniaLim_Raisg\". Then add this FeatureCollection to the Map with the label \"Amazon boundary\" and center the map on the object with a zoom level of 4.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n", "functions": ["ee.FeatureCollection", "Map.addLayer", "Map.centerObject"], "external_vars": ["ee", "Map"], "defined_vars": ["Amazon"], "parameters": ["users/wangyxtina/3rdScaleUp/AmazoniaLim_Raisg", "Amazon", "Amazon boundary", "Amazon", 4, "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add the EVI layer to the map.\nMap.addLayer(evi, {'min': -1, 'max': 1, 'palette': palette}, 'EVI')\n", "task": "Add a layer to the map called \"EVI\" using the \"evi\" data, with a color palette defined by \"palette\", and a minimum value of -1 and a maximum value of 1.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the Landsat 8 collection.\nlandsat8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_SR')\n# Define the region of interest.\ngeometry = ee.Geometry.Point([119.41792340169773, -5.133052890077648])\n# Filter the collection by date and region.\nimage = ee.Image(landsat8.filterDate(\n    '2019-01-01', '2019-12-31').filterBounds(geometry).sort('CLOUD_COVER').first())\n# Define the visualization parameters.\npalette = ['red', 'green']\n# 3. Calculate EVI using the expression function.\nevi = image.expression('2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))',\n                       {'NIR': image.select('B5'), 'RED': image.select('B4'), 'BLUE': image.select('B2')})\n", "functions": ["Map.addLayer"], "external_vars": ["evi", "Map", "palette"], "defined_vars": [], "parameters": ["evi", "EVI", "{'min': -1, 'max': 1, 'palette': palette}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the buffer, bounds, and bounding box to the map\nMap.addLayer(buffer, {}, 'buffer')\nMap.addLayer(bounds, {}, 'bounds')\nMap.addLayer(bbox, {}, 'bounding box')\n\n\n", "task": "Add three layers to the map: `buffer`, `bounds`, and `bounding box`. Use the provided variables `Map`, `buffer`, `bounds`, and `bbox`. Make sure to define the following variables: []", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the input geometries\ngeometry = ee.Geometry.Point([-2.481398773193373, 6.822477794917577])\n# Create a buffer around the first geometry\nbuffer = geometry.buffer(10000)\n# Get the bounds of the buffer\nbounds = buffer.bounds()\n# Define a bounding box\nbbox = ee.Geometry.BBox(-1, 5, 1, 7)\n", "functions": ["Map.addLayer", "Map.addLayer", "Map.addLayer"], "external_vars": ["bbox", "Map", "buffer", "bounds"], "defined_vars": [], "parameters": ["buffer", "buffer", "bounds", "bounds", "bbox", "bounding box", "{}", "{}", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "ndvi_collection = landsat8.merge(landsat9).merge(sen2).sort('system:time_start')\n", "task": "Merge the Landsat 8, Landsat 9, and Sentinel 2 collections (represented by the variables `landsat8`, `landsat9`, and `sen2`, respectively). Sort the merged collection by the ascending order of the `system:time_start` property. Define the resulting merged collection as `ndvi_collection`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ncor = [[48.09532576624447, 31.98308763719514], [48.744892416635096, 31.98308763719514], [48.744892416635096,\n                                                                                         32.40378543571943], [48.09532576624447, 32.40378543571943], [48.09532576624447, 31.98308763719514]]\ngeometry = ee.Geometry.Polygon(cor)\ntime_start = '2023'\ntime_end = '2024'\n\n\ndef func_(img):\n    ms = img.select('SR.*')\n    gain = ee.Number(img.get('REFLECTANCE_MULT_BAND_3'))\n    offset = ee.Number(img.get('REFLECTANCE_ADD_BAND_2'))\n    sr = ms.multiply(gain).add(offset)\n    ndvi = sr.normalizedDifference(['SR_B5', 'SR_B4']).rename('ndvi')\n    return ndvi.copyProperties(img, ['system:time_start', 'system:time_end', 'system:index'])\n\n\nlandsat8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterDate(\n    time_start, time_end).filterBounds(geometry).map(func_)\nlandsat9 = ee.ImageCollection('LANDSAT/LC09/C02/T1_L2').filterDate(\n    time_start, time_end).filterBounds(geometry).map(func_)\n\n\ndef func2_(img):\n    ms = img.select('B.*').multiply(0.0001)\n    ndvi = ms.normalizedDifference(['B8', 'B4']).rename('ndvi')\n    return ndvi.copyProperties(img, ['system:time_start', 'system:time_end', 'system:index'])\n\n\nsen2 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED').filterDate(\n    time_start, time_end).filterBounds(geometry).map(func2_)\n", "functions": ["unknown_function.sort", "unknown_function.merge", "landsat8.merge"], "external_vars": ["landsat9", "landsat8", "sen2"], "defined_vars": ["ndvi_collection"], "parameters": ["system:time_start", "sen2", "landsat9"], "libraries": ["import geemap", "import ee"]}
{"code": "# Use imageCollection.iterate() to make a collection of cumulative anomaly over time.\n# The initial value for iterate() is a list of anomaly images already processed.\n# The first anomaly image in the list is just 0, with the time0 timestamp.\nfirst = ee.List([ee.Image(0).set('system:time_start', time0).select([0], ['EVI'])])\n", "task": "Using the Earth Engine library (ee) and the time variable \"time0\", create an Earth Engine list named \"first\" containing a single image with the value 0 and a time property set to \"time0\". The image should have a single band named \"EVI\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\ncollection = ee.ImageCollection('MODIS/006/MYD13A1').select('EVI')\n# Define reference conditions from the first 10 years of data.\nreference = collection.filterDate(\n    '2001-01-01', '2010-12-31').sort('system:time_start', False)\n# Get the timestamp from the most recent image in the reference collection.\ntime0 = reference.first().get('system:time_start')\n", "functions": ["ee.List", "unknown_function.select", "unknown_function.set", "ee.Image"], "external_vars": ["ee", "time0"], "defined_vars": ["first"], "parameters": ["system:time_start", "time0", 0, "[ee.Image(0).set('system:time_start', time0).select([0], ['EVI'])]", "[0]", "['EVI']"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the input image collection (HYCOM Sea Surface Temperature.And Salinity)\nimage_collection = ee.ImageCollection(\"HYCOM/GLBu0_08/sea_temp_salinity\")\n", "task": "Using the Earth Engine library (`ee`), load the HYCOM sea surface temperature and salinity data into a variable called `image_collection`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["image_collection"], "parameters": ["HYCOM/GLBu0_08/sea_temp_salinity"], "libraries": ["import geemap", "import ee"]}
{"code": "# Visualize the filtered composite.\nMap.addLayer(composite_filtered, visParams, 'L8 Composite - Cloud-Filtered')  # True color median of cloud-filtered images\n", "task": "Add the cloud-filtered Landsat 8 composite image (`composite_filtered`) to the map (`Map`) using the provided visualization parameters (`visParams`).  Label the layer as \"L8 Composite - Cloud-Filtered\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the Louisiana boundary.\nlouisiana = ee.FeatureCollection(\n    'TIGER/2018/States').filter(ee.Filter.equals('NAME', 'Louisiana'))\n# Define the time period for the analysis.\nstartDate = '2019-01-01'\nendDate = '2019-12-31'\n# Load and filter the Landsat 8 collection.\nlandsat8 = ee.ImageCollection(\n    'LANDSAT/LC08/C02/T1_TOA').filterBounds(louisiana).filterDate(startDate, endDate)\n# Visualize the composite.\nvisParams = {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 0.35}\n# Filter the Landsat 8 collection by cloud cover.\nlandsat8_filtered = landsat8.filterBounds(louisiana).filterDate(\n    startDate, endDate).filter(ee.Filter.lt('CLOUD_COVER', 40))\n# Create a median composite of the filtered images.\ncomposite_filtered = landsat8_filtered.median().clip(louisiana)\n", "functions": ["Map.addLayer"], "external_vars": ["composite_filtered", "visParams", "Map"], "defined_vars": [], "parameters": ["composite_filtered", "visParams", "L8 Composite - Cloud-Filtered"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the point of interest.\npoint = ee.Geometry.Point([-41.45931791095892, -12.590869262752728])\n", "task": "Using the ee library, define a variable named \"point\" as an ee.Geometry.Point object with the coordinates [-41.45931791095892, -12.590869262752728].", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Geometry.Point"], "external_vars": ["ee"], "defined_vars": ["point"], "parameters": ["[-41.45931791095892, -12.590869262752728]"], "libraries": ["import geemap", "import ee"]}
{"code": "Map.addLayer(flooded.clip(geometry),{'palette':['blue']},'flooded',False)\n", "task": "Add a layer to the map called \"flooded\" that displays the clipped flooded area using the \"blue\" color palette. Make sure to define the variables: `Map`, `flooded`, and `geometry` before running the code.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ncor = [[106.44430037530792, -6.361265166952202], [107.31496687921417, -6.361265166952202], [107.31496687921417, -\n                                                                                            5.962581789961148], [106.44430037530792, -5.962581789961148], [106.44430037530792, -6.361265166952202]]\ngeometry = ee.Geometry.Polygon(cor)\nsar_before = ee.ImageCollection('COPERNICUS/S1_GRD').filterDate('2019-12-20', '2019-12-29').filterBounds(geometry).filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')).filter(\n    ee.Filter.eq('instrumentMode', 'IW')).filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING')).select('VV').map(lambda img: img.focalMean(60, 'square', 'meters').copyProperties(img, img.propertyNames()))\nsar_after = ee.ImageCollection('COPERNICUS/S1_GRD').filterDate('2019-12-30', '2020-01-03').filterBounds(geometry).filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')).filter(\n    ee.Filter.eq('instrumentMode', 'IW')).filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING')).select('VV').map(lambda img: img.focalMean(60, 'square', 'meters').copyProperties(img, img.propertyNames()))\nchange = sar_before.min().subtract(sar_after.min())\nwater_mask = ee.ImageCollection('GOOGLE/DYNAMICWORLD/V1').select(\n    'label').filterDate('2018', '2021').filterBounds(geometry).mode().eq(0)\nthr = change.gt(5).updateMask(water_mask)\nflooded = thr.updateMask(thr)\n", "functions": ["Map.addLayer", "flooded.clip"], "external_vars": ["flooded", "geometry", "Map"], "defined_vars": [], "parameters": ["flooded", false, "geometry", "flooded.clip(geometry)", "{'palette': ['blue']}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the Malaysia administrative boundaries\nAdm_Malaysia = ee.FeatureCollection(\"users/rudiyanto/Workshop_INOS/gadm41_MYS_2\")\nprint('Adm_Malaysia:', Adm_Malaysia)\nMap.centerObject(Adm_Malaysia, 6)\nMap.addLayer(Adm_Malaysia, {'color': 'FF0000'}, 'colored')\n", "task": "Using the Earth Engine library (`ee`), load the feature collection \"gadm41_MYS_2\" from the user \"rudiyanto\" and store it in a variable named `Adm_Malaysia`. Then, use the `print` function to display the `Adm_Malaysia` object. Finally, center the map on the `Adm_Malaysia` feature collection with a zoom level of 6 using the `Map.centerObject` function. Add the `Adm_Malaysia` feature collection to the map with a red color using the `Map.addLayer` function.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n", "functions": ["ee.FeatureCollection", "print", "Map.centerObject", "Map.addLayer"], "external_vars": ["ee", "print", "Map"], "defined_vars": ["Adm_Malaysia"], "parameters": ["users/rudiyanto/Workshop_INOS/gadm41_MYS_2", "Adm_Malaysia:", "Adm_Malaysia", "Adm_Malaysia", 6, "Adm_Malaysia", "colored", "{'color': 'FF0000'}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Center the map on the region of interest.\nMap.centerObject(geometry, 10)\n", "task": "Center the object defined by `geometry` on the map `Map` with a zoom level of 10.  You need to define the `geometry` and `Map` variables before running this code.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ngeometry = ee.Geometry.Polygon([[-105.19449049821685, 40.58336005607356], [-105.19449049821685, 40.51683831571297],\n                               [-105.10316664567779, 40.51683831571297], [-105.10316664567779, 40.58336005607356]])\n", "functions": ["Map.centerObject"], "external_vars": ["geometry", "Map"], "defined_vars": [], "parameters": ["geometry", 10], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the geometry of the area of interest\ngeometry = ee.Geometry.Polygon([[[-90.15234375, 30.26147225282594],\n                                 [-90.15234375, 29.52614052092204],\n                                 [-89.049072265625, 29.52614052092204],\n                                 [-89.049072265625, 30.26147225282594]]])\n", "task": "Using the ee library, define a variable called `geometry` and assign it a polygon with the following coordinates: [[-90.15234375, 30.26147225282594], [-90.15234375, 29.52614052092204], [-89.049072265625, 29.52614052092204], [-89.049072265625, 30.26147225282594]]", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee"], "defined_vars": ["geometry"], "parameters": ["[[[-90.15234375, 30.26147225282594], [-90.15234375, 29.52614052092204], [-89.049072265625, 29.52614052092204], [-89.049072265625, 30.26147225282594]]]"], "libraries": ["import geemap", "import ee"]}
{"code": "# Calculate the difference between the ALOS PALSAR DEM.And the SRTM DEM.\nhighConfer = alos.select(\"AVE_DSM\").clip(geometry).subtract(srtm.clip(geometry))\n", "task": "Calculate the difference between the ALOS Digital Surface Model (DSM) and the SRTM elevation data within the specified geometry and store the result in the variable \"highConfer\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the geometry of the area of interest.\ngeometry = ee.Geometry.Polygon([[112.97681537871199, 23.388089271095946], [112.97681537871199, 22.7766325957908], [\n                               113.62500873808699, 22.7766325957908], [113.62500873808699, 23.388089271095946]], None, False)\n# ALOS PALSAR DEM.\nalos = ee.Image('JAXA/ALOS/AW3D30/V2_2')\n# SRTM DEM.\nsrtm = ee.Image('USGS/SRTMGL1_003')\n", "functions": ["unknown_function.subtract", "unknown_function.clip", "alos.select", "srtm.clip"], "external_vars": ["alos", "srtm", "geometry"], "defined_vars": ["highConfer"], "parameters": ["geometry", "AVE_DSM", "geometry", "srtm.clip(geometry)"], "libraries": ["import geemap", "import ee"]}
{"code": "# Finding statistics of terrain features over a single area of interest\n# 1. Find the maximum elevation.And print it to the console.\nmax_dem = dem_aoi.reduceRegion(\n    reducer=ee.Reducer.max(),\n    geometry=AOI,\n    scale=30,\n    maxPixels=1e10,\n    tileScale=4\n).rename(['elevation'], ['max_elevation'])  # This changes the property name from 'elevation' to 'max_elevation'\n", "task": "Calculate the maximum elevation value within the area of interest (AOI) using the `dem_aoi` Earth Engine image. Store the result in a variable named `max_dem`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the area of interest (AOI) as a polygon.\nAOI = ee.Geometry.Polygon([[-12.892675706280194, 12.07433420000324], [-12.892675706280194, 11.528565794218073],\n                          [-11.799536057842694, 11.528565794218073], [-11.799536057842694, 12.07433420000324]])\n# Clip the Shuttle Radar Topography Mission (SRTM) 30 DEM to the AOI.\ndem_aoi = ee.Image('USGS/SRTMGL1_003').clip(AOI)\n", "functions": ["unknown_function.rename", "dem_aoi.reduceRegion", "ee.Reducer.max"], "external_vars": ["ee", "dem_aoi", "AOI"], "defined_vars": ["max_dem"], "parameters": ["['elevation']", "['max_elevation']"], "libraries": ["import geemap", "import ee"]}
{"code": "point = ee.Geometry.Point(cor)\n", "task": "Create a point geometry named `point` using the `ee.Geometry.Point` function with the coordinates specified in the variable `cor`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\ncor = [24.92986164991798, 60.20951014430325]\n", "functions": ["ee.Geometry.Point"], "external_vars": ["ee", "cor"], "defined_vars": ["point"], "parameters": ["cor"], "libraries": ["import geemap", "import ee"]}
{"code": "# Adjust the min/max for your region This is the number of buildings per sq. km.\nvisParams = {\n  min: 500,\n  max: 2500,\n  'palette': palette\n}\nMap.addLayer(buildingDensity.clip(geometry), visParams, 'Building Density', False)\n", "task": "Define a variable called `visParams` with the following values: `min` set to 500, `max` set to 2500, and `palette` set to the value of the `palette` variable. Then use the `Map` object to add a layer called \"Building Density\" using the `buildingDensity` layer clipped to the `geometry` with the defined `visParams` and set the visibility to `False`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Select your region of interest You can also just draw a polygon using the drawing tools instead and comment out the code for region selection below\nadmin2 = ee.FeatureCollection('FAO/GAUL_SIMPLIFIED_500m/2015/level2')\nADM0_NAME = 'India'\nADM1_NAME = 'Karnataka'\nADM2_NAME = 'Bangalore Urban'\nselected = admin2.filter(ee.Filter.eq('ADM0_NAME', ADM0_NAME)).filter(\n    ee.Filter.eq('ADM1_NAME', ADM1_NAME)).filter(ee.Filter.eq('ADM2_NAME', ADM2_NAME))\ngeometry = selected.geometry()\n# We are using the collection for India\nbuildingsCol = ee.FeatureCollection(\n    'projects/sat-io/open-datasets/MSBuildings/India')\n# Clipping the buildings feature collection to the region of interest\nbuildings = buildingsCol.filter(ee.Filter.bounds(geometry))\n# Creating 1000m grid within the geometry\ngridSizeMeters = 1000\n# Generate a rectangular grid\ngrid = geometry.coveringGrid('EPSG:3857', gridSizeMeters)\nintersectFilter = ee.Filter.intersects(\n    leftField='.geo', rightField='.geo', maxError=10)\nsaveAllJoin = ee.Join.saveAll(matchesKey='buildings')\njoined = saveAllJoin.apply(grid, buildings, intersectFilter)\n# Calculate total number of buildings within each feature.\n\n\ndef func_(f):\n    buildingsWithin = ee.List(f.get('buildings'))\n    totalBuildings = ee.FeatureCollection(buildingsWithin).size()\n    return f.set('total_buildings', totalBuildings)\n\n\nbuildingCounts = joined.map(func_)\nbuildingDensity = ee.Image().int().paint(\n    featureCollection=buildingCounts, color='total_buildings')\npalette = ['#313695', '#4575b4', '#74add1', '#abd9e9', '#e0f3f8',\n           '#fee090', '#fdae61', '#f46d43', '#d73027', '#a50026']\n", "functions": ["Map.addLayer", "buildingDensity.clip"], "external_vars": ["max", "geometry", "palette", "buildingDensity", "min", "Map"], "defined_vars": ["visParams"], "parameters": ["visParams", "Building Density", false, "geometry", "buildingDensity.clip(geometry)"], "libraries": ["import geemap", "import ee"]}
{"code": "monthly = temporal_collection(chirps, time_start, 240, 1, 'month')\n", "task": "Using the `temporal_collection` function, define a variable called `monthly` that aggregates the `chirps` data into monthly intervals. Start the aggregation from `time_start`, with each interval lasting 240 units, and use a step size of 1. ", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ntime_start = '2000'\ntime_end = '2020'\nchirps = ee.ImageCollection(\n    'UCSB-CHG/CHIRPS/DAILY').filterDate(time_start, time_end)\n\n\ndef temporal_collection(collection, start, count, interval, unit):\n    seq = ee.List.sequence(0, ee.Number(count).subtract(1))\n    origin_date = ee.Date(start)\n\n    def func_(i):\n        start_date = origin_date.advance(ee.Number(interval).multiply(i), unit)\n        end_date = origin_date.advance(\n            ee.Number(interval).multiply(ee.Number(i).add(1)), unit)\n        return collection.filterDate(start_date, end_date).sum().set('system:time_start', start_date.millis()).set('system:time_end', end_date.millis())\n    return ee.ImageCollection(seq.map(func_))\n", "functions": ["temporal_collection"], "external_vars": ["temporal_collection", "time_start", "chirps"], "defined_vars": ["monthly"], "parameters": ["chirps", "time_start", 240, 1, "month"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the image you want to work with.\nthearrayimage = ee.Image([3, 4, 1, 55, 2]).toArray()\nprint(thearrayimage)\n", "task": "Define a variable named `thearrayimage` using the `ee.Image` function with the list `[3, 4, 1, 55, 2]` as input. Then, convert it to an array using the `toArray()` method. Finally, print the value of `thearrayimage` using the `print` function.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["unknown_function.toArray", "ee.Image", "print"], "external_vars": ["print", "ee"], "defined_vars": ["thearrayimage"], "parameters": ["thearrayimage", "[3, 4, 1, 55, 2]"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load a Landsat TOA image.\nimage = ee.Image('LANDSAT/LC8_L1T_TOA/LC81420512013105LGN01')\n", "task": "Using the Earth Engine library (ee), define a variable named \"image\" that represents a Landsat 8 image with the ID \"LANDSAT/LC8_L1T_TOA/LC81420512013105LGN01\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["image"], "parameters": ["LANDSAT/LC8_L1T_TOA/LC81420512013105LGN01"], "libraries": ["import ee", "import geemap"]}
{"code": "Map.addLayer(class3.clip(roi),{min: 0, max : 3, 'palette':['black','red','orange','green']},'class3',False)\n\n\n", "task": "Add a layer to the map named \"class3\" using the clipped class3 data within the region of interest (roi). Set the visualization range from min to max and use the specified palette. Define the following variables before running the code: `roi`, `Map`, `min`, `max`, and `class3`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\nbasin = ee.FeatureCollection('WWF/HydroSHEDS/v1/Basins/hybas_6')\ncor = [28.577460872036138, 64.5593101743747]\npoint = ee.Geometry.Point(cor)\nroi = basin.filterBounds(point)\ncanopy = ee.ImageCollection(\n    'projects/meta-forest-monitoring-okw37/assets/CanopyHeight').mosaic()\nforest_thr = canopy.gt(0)\nforest = canopy.updateMask(forest_thr)\ncons = ee.Image.constant(0)\nclass1 = cons.where(forest.lt(5), 1)\nclass2 = class1.where(forest.gte(5) and forest.lt(10), 2)\nclass3 = class2.where(forest.gte(10), 3)\n", "functions": ["Map.addLayer", "class3.clip"], "external_vars": ["max", "roi", "class3", "Map", "min"], "defined_vars": [], "parameters": ["class3", false, "roi", "class3.clip(roi)", "{min: 0, max: 3, 'palette': ['black', 'red', 'orange', 'green']}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Import the Landsat 8 image collection\nl8 = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_L2\")\nprint(l8.size())\n", "task": "Using the Earth Engine library (ee), load the Landsat 8 Collection 2 Tier 1 Level 2 data into a variable named \"l8\". Then, print the size of the loaded ImageCollection using the \"print\" function.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection", "print", "l8.size"], "external_vars": ["ee", "print"], "defined_vars": ["l8"], "parameters": ["LANDSAT/LC08/C02/T1_L2", "l8.size()"], "libraries": ["import geemap", "import ee"]}
{"code": "# Access the 30m Landsat datset for water loctions.\nwater = ee.ImageCollection(\"GLCF/GLS_WATER\").map(lambda img:img.expression(\"(BAND==2)\",{'BAND':img.select('water')}))\nprint(water,'This is water from LandSat')\n", "task": "Using the Earth Engine library (ee), load the GLCF/GLS_WATER image collection and apply a lambda function to each image within the collection.  The lambda function should use the `expression` method to create a new image where pixels are assigned a value of 1 if the value of the `water` band is equal to 2, and 0 otherwise. Define a variable named `water` to store the resulting image collection. Finally, print the value of `water` along with the string \"This is water from LandSat\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n", "functions": ["unknown_function.map", "ee.ImageCollection", "img.expression", "img.select", "print"], "external_vars": ["ee", "img", "print"], "defined_vars": ["water"], "parameters": ["GLCF/GLS_WATER", "(BAND==2)", "water", "water", "This is water from LandSat", "lambda img: img.expression('(BAND==2)', {'BAND': img.select('water')})", "{'BAND': img.select('water')}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Load the SSCGS-ADM3 dataset from Earth Engine's asset repository.\nSSCGS_ADM3 = ee.FeatureCollection('projects/earthengine-legacy/assets/projects/sat-io/open-datasets/geoboundaries/SSCGS-ADM3')\n", "task": "Using the Earth Engine library,  define a variable called `SSCGS_ADM3` to store a FeatureCollection representing the SSCGS-ADM3 dataset. This dataset is located at `projects/earthengine-legacy/assets/projects/sat-io/open-datasets/geoboundaries/SSCGS-ADM3`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.FeatureCollection"], "external_vars": ["ee"], "defined_vars": ["SSCGS_ADM3"], "parameters": ["projects/earthengine-legacy/assets/projects/sat-io/open-datasets/geoboundaries/SSCGS-ADM3"], "libraries": ["import geemap", "import ee"]}
{"code": "# Create a rectangle geometry using the coordinates.\nrectangle = ee.Geometry.Rectangle([-105, 33, -104, 34])\n", "task": "Using the Earth Engine library (ee), define a variable named \"rectangle\" representing a rectangular geometry with coordinates [-105, 33, -104, 34].", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Geometry.Rectangle"], "external_vars": ["ee"], "defined_vars": ["rectangle"], "parameters": ["[-105, 33, -104, 34]"], "libraries": ["import ee", "import geemap"]}
{"code": "# Select Puerto Cabezas District\nregion = adm2.filter(ee.Filter.eq('ADM2_CODE', 22395))\n", "task": "Using the Earth Engine library (`ee`) and the `adm2` feature collection, filter the `adm2` feature collection to only include features where the `ADM2_CODE` attribute is equal to 22395. Store the resulting filtered feature collection in a variable named `region`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load Admin-2 district data\nadm2 = ee.FeatureCollection('FAO/GAUL/2015/level2')\n", "functions": ["adm2.filter", "ee.Filter.eq"], "external_vars": ["ee", "adm2"], "defined_vars": ["region"], "parameters": ["ADM2_CODE", 22395, "ee.Filter.eq('ADM2_CODE', 22395)"], "libraries": ["import geemap", "import ee"]}
{"code": "# Center the map on Abuja.\nMap.centerObject(abuja, 13)\n\n\n", "task": "Center the object \"abuja\" on the map using the Map.centerObject method.  Set the zoom level to 13.  You will need to define the \"Map\" and \"abuja\" variables before running this code.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define a point geometry for Abuja.\nabuja = ee.Geometry.Point([7.488904263534426, 9.069181557302237])\n", "functions": ["Map.centerObject"], "external_vars": ["abuja", "Map"], "defined_vars": [], "parameters": ["abuja", 13], "libraries": ["import geemap", "import ee"]}
{"code": "# Reduce the collection to a set of unique year representatives to serve as the primary collection in a join with the complete collection.\ndistinctYear = ee.ImageCollection(\"ECMWF/ERA5/MONTHLY\").distinct('year')\n", "task": "Using the Earth Engine library (ee), create a variable called `distinctYear` that represents an ImageCollection containing all unique years from the `ECMWF/ERA5/MONTHLY` dataset.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["unknown_function.distinct", "ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["distinctYear"], "parameters": ["year", "ECMWF/ERA5/MONTHLY"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the MODIS image collection.And filter it by date.And bands\nmm = ee.ImageCollection('MODIS/061/MOD13Q1') .filterDate('2018-01-01', '2019-01-01') .select(['sur_refl_b01', 'sur_refl_b02'])\n", "task": "Using the Earth Engine library (ee), load the MODIS 13Q1 image collection for the year 2018 and select the bands \"sur_refl_b01\" and \"sur_refl_b02\". Store the resulting image collection in a variable called \"mm\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["unknown_function.select", "unknown_function.filterDate", "ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["mm"], "parameters": ["2018-01-01", "2019-01-01", "MODIS/061/MOD13Q1", "['sur_refl_b01', 'sur_refl_b02']"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the point of interest.\npoint = ee.Geometry.Point([-4.2771148681640625, 55.859225187001805])\n", "task": "Using the ee library, define a variable called `point` as an Earth Engine Point geometry object using the coordinates [-4.2771148681640625, 55.859225187001805].", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Geometry.Point"], "external_vars": ["ee"], "defined_vars": ["point"], "parameters": ["[-4.2771148681640625, 55.859225187001805]"], "libraries": ["import geemap", "import ee"]}
{"code": "# Display the results.\nMap.setCenter(-122.374, 37.8239, 12)  # San Francisco Bay\nviz_params = {'bands': ['B5', 'B4', 'B3'], 'min': 0, 'max': 0.4}\nMap.addLayer(recent_value_composite, viz_params, 'recent value composite')\nMap.addLayer(greenest_pixel_composite, viz_params, 'greenest pixel composite')\n\n\n", "task": "Center the map on the coordinates (-122.374, 37.8239) with a zoom level of 12. Define a variable called `viz_params` with the following values: `{\"bands\": [\"B5\", \"B4\", \"B3\"], \"min\": 0, \"max\": 0.4}`. Add the `recent_value_composite` and `greenest_pixel_composite` layers to the map using the `viz_params` and label them \"recent value composite\" and \"greenest pixel composite\" respectively.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n\n\ndef mask_clouds(image):\n    \"\"\"Masks clouds in Landsat 8 imagery.\n\n    Args:\n        image: ee.Image, Landsat 8 imagery.\n\n    Returns:\n        ee.Image, Landsat 8 imagery with clouds masked.\n    \"\"\"\n    scored = ee.Algorithms.Landsat.simpleCloudScore(image)\n    return image.updateMask(scored.select(['cloud']).lt(20))\n# This function masks clouds and adds quality bands to Landsat 8 images.\n\n\ndef add_quality_bands(image):\n    \"\"\"Masks clouds and adds quality bands to Landsat 8 images.\n\n    Args:\n        image: ee.Image, Landsat 8 imagery.\n\n    Returns:\n        ee.Image, Landsat 8 imagery with clouds masked and quality bands added.\n    \"\"\"\n    return mask_clouds(image).addBands(image.normalizedDifference(['B5', 'B4'])).addBands(image.metadata('system:time_start'))\n\n\n# Map the cloud masking and quality band function over the collection.\ncollection = ee.ImageCollection(\n    'LANDSAT/LC08/C01/T1_TOA').filterDate('2014-06-01', '2014-12-31').map(add_quality_bands)\n# Create a cloud-free, most recent value composite.\nrecent_value_composite = collection.qualityMosaic('system:time_start')\n# Create a greenest pixel composite.\ngreenest_pixel_composite = collection.qualityMosaic('nd')\n", "functions": ["Map.setCenter", "Map.addLayer", "Map.addLayer"], "external_vars": ["greenest_pixel_composite", "Map", "recent_value_composite"], "defined_vars": ["viz_params"], "parameters": [37.8239, 12, "recent_value_composite", "viz_params", "recent value composite", "greenest_pixel_composite", "viz_params", "greenest pixel composite", "-122.374"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the clipped image to the map\nMap.addLayer(dem_clip, dem_viz, 'SRTM Image Clipped')\n", "task": "Add the clipped digital elevation model (DEM) to the map using the `Map.addLayer` function. The clipped DEM is represented by the variable `dem_clip`, and the visualization parameters are defined in `dem_viz`. Set the layer name to \"SRTM Image Clipped\".  **[Make sure the variables `Map`, `dem_clip`, and `dem_viz` are defined before executing this instruction.]**", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ndem = ee.Image('CGIAR/SRTM90_V4')\n# Set the min/max values for the image to 0-4000\ndem_viz = {'min': 0, 'max': 4000}\n# Define the geometry for the region of interest\nroi = ee.Geometry.Polygon([[102, 3], [102, 2.5], [102.5, 2.5], [102.5, 3]])\n# Clip the image using the region of interest\ndem_clip = dem.clip(roi)\n", "functions": ["Map.addLayer"], "external_vars": ["dem_clip", "dem_viz", "Map"], "defined_vars": [], "parameters": ["dem_clip", "dem_viz", "SRTM Image Clipped"], "libraries": ["import ee", "import geemap"]}
{"code": "mask = thr.updateMask(thr)\n", "task": "Define a variable named `mask` and assign it the result of calling the `updateMask` method of the `thr` object, passing `thr` as an argument.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\ntime_start = '2010'\ntime_end = '2015'\nmodis = ee.ImageCollection(\n    'MODIS/061/MOD10A1').select('NDSI_Snow_Cover').filterDate(time_start, time_end)\nlc = ee.ImageCollection('MODIS/061/MCD12Q1').select('LC_Type1').mode()\nwb = lc.eq(17)\nndsi_max = modis.max().updateMask(wb)\nthr = ndsi_max.gt(50)\n", "functions": ["thr.updateMask"], "external_vars": ["thr"], "defined_vars": ["mask"], "parameters": ["thr"], "libraries": ["import geemap", "import ee"]}
{"code": "# Center the map on the specified coordinates.\nMap.setCenter(36, 10, 6)\n", "task": "Set the center of the map to the coordinates (36, 10) and zoom level 6. You will need to define the following variables: [Map].", "exec_path": "GEE", "context": "import geemap\nMap = geemap.Map()\n", "functions": ["Map.setCenter"], "external_vars": ["Map"], "defined_vars": [], "parameters": [36, 10, 6], "libraries": ["import geemap"]}
{"code": "# Load the area of interest (AOI) feature collection\naoi = ee.FeatureCollection(\"projects/my-project-1556257022373/assets/TOLT7-1\")\n", "task": "Using the Earth Engine library (ee), define a variable called \"aoi\" that represents a FeatureCollection located in your project, specifically the asset \"TOLT7-1\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.FeatureCollection"], "external_vars": ["ee"], "defined_vars": ["aoi"], "parameters": ["projects/my-project-1556257022373/assets/TOLT7-1"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the Urban Expansion Mask layer to the map.\nMap.addLayer(urban_i.updateMask(urban_i))\n", "task": "Add a layer to the map, using the updated mask of the urban imagery layer (`urban_i`). Note that this assumes `Map` and `urban_i` have been previously defined.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the Global Annual Impervious Surface Area (GAIA) image.\ngaia = ee.Image('Tsinghua/FROM-GLC/GAIA/v10')\n# Compute the urban expansion mask by comparing GAIA images from 1990 and 2019.\nurban_i = gaia.gte(2019 - 1990)\n", "functions": ["Map.addLayer", "urban_i.updateMask"], "external_vars": ["Map", "urban_i"], "defined_vars": [], "parameters": ["urban_i", "urban_i.updateMask(urban_i)"], "libraries": ["import geemap", "import ee"]}
{"code": "# Scenario One - Sand.And Urban switching orders\ncairo_v1 = cairo2020.remap([0, 1, 2, 3], [0, 1, 3, 2])\nMap.addLayer(cairo_v1, {'min': 0, 'max': 3, 'palette': palette_map}, 'Cairo V1')\n", "task": "Using the `cairo2020` object, remap the values [0, 1, 2, 3] to [0, 1, 3, 2] and store the result in a variable called `cairo_v1`. Then, add this remapped layer to the `Map` object with a minimum value of 0, a maximum value of 3, using the `palette_map` for the color scheme, and name it \"Cairo V1\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the land cover map from assets\ncairo2020 = ee.Image('users/celiohelder/TutorialAssets/Cairo2020')\n# Color palette for the original map\npalette_map = ['#0040ff', '#00ab0c', '#fbf2ad', '#878587']\n", "functions": ["cairo2020.remap", "Map.addLayer"], "external_vars": ["palette_map", "cairo2020", "Map"], "defined_vars": ["cairo_v1"], "parameters": ["cairo_v1", "Cairo V1", "[0, 1, 2, 3]", "[0, 1, 3, 2]", "{'min': 0, 'max': 3, 'palette': palette_map}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the SRTM elevation dataset.\nsrtm = ee.Image(\"USGS/SRTMGL1_003\")\n", "task": "Using the Earth Engine library (`ee`), load the SRTMGL1_003 image collection and assign it to the variable `srtm`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["srtm"], "parameters": ["USGS/SRTMGL1_003"], "libraries": ["import geemap", "import ee"]}
{"code": "helsinki2013 = night_light('2013','2014', 'Paris')\n", "task": "Define a variable called `helsinki2013` and assign it the result of calling the function `night_light` with arguments `'2013'`, `'2014'`, and `'Paris'`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ntable = ee.FeatureCollection('FAO/GAUL/2015/level1')\ncor = [2.3495010435451746, 48.8768460308918]\ngeometry = ee.Geometry.Point(cor)\nroi = table.filterBounds(geometry)\n\n\ndef night_light(time_start, time_end, loc_name):\n    viirs = ee.ImageCollection('NOAA/VIIRS/DNB/MONTHLY_V1/VCMCFG').select(\n        'avg_rad').filterDate(time_start, time_end).mean()\n    stats = viirs.reduceRegion(reducer=ee.Reducer.mean().combine(\n        reducer2=ee.Reducer.minMax(), sharedInputs=True), geometry=roi, scale=500)\n    print('night light stat for ' + time_start, stats)\n    Map.addLayer(viirs.clip(roi), {}, loc_name + time_start, False)\n    return viirs\n", "functions": ["night_light"], "external_vars": ["night_light"], "defined_vars": ["helsinki2013"], "parameters": ["2013", "2014", "Paris"], "libraries": ["import geemap", "import ee"]}
{"code": "def func2_(img):\n    sigma = ee.Image(10).pow(img.divide(10)).rename('sigma')\n    speckel = sigma.focalMean(30, 'square', 'meters')\n    return speckel.copyProperties(img, img.propertyNames())\n", "task": "Using the Earth Engine library (ee), define a function called `func2_` that takes an image (`img`) as input. Within the function, calculate a `sigma` image by raising 10 to the power of `img` divided by 10 and renaming it as `sigma`. Then, use the `focalMean` method on `sigma` with a radius of 30 meters, a kernel shape of \"square\", and units of \"meters\" to calculate a `speckel` image. Finally, return `speckel` with the properties of the input image (`img`) copied over.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["unknown_function.rename", "unknown_function.pow", "ee.Image", "img.divide", "sigma.focalMean", "speckel.copyProperties", "img.propertyNames"], "external_vars": ["ee"], "defined_vars": ["sigma", "img", "speckel"], "parameters": ["sigma", 10, 10, 30, "square", "meters", "img", "img.divide(10)", "img.propertyNames()"], "libraries": ["import ee", "import geemap"]}
{"code": "# Load the Sentinel-1 SAR image collection.\nsar_image_collection = ee.ImageCollection(\"COPERNICUS/S1_GRD\")\n", "task": "Using the Earth Engine library (ee), load the Sentinel-1 Ground Range (GRD) image collection and store it in the variable `sar_image_collection`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["sar_image_collection"], "parameters": ["COPERNICUS/S1_GRD"], "libraries": ["import ee", "import geemap"]}
{"code": "# Define the CarbonDensity image collection.\nCarbonDensity = ee.ImageCollection(\"WCMC/biomass_carbon_density/v1_0\")\n", "task": "Using the Earth Engine library (ee), load the \"WCMC/biomass_carbon_density/v1_0\" image collection and assign it to the variable `CarbonDensity`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["CarbonDensity"], "parameters": ["WCMC/biomass_carbon_density/v1_0"], "libraries": ["import ee", "import geemap"]}
{"code": "def func_(img):\n    band = img.multiply(0.0001)\n    ndwi = band.normalizedDifference(['sur_refl_b01','sur_refl_b02']).rename('ndwi')\n    return ndwi\n\nmodis2023 = ee.ImageCollection(\"MODIS/061/MOD09Q1\").select('sur.*').filterDate('2023','2024').map(func_).median()\n", "task": "Define a function named `func_` that takes an Earth Engine image object (`img`) as input. Inside the function, multiply the input image by 0.0001 and assign the result to a variable named `band`. Then, calculate the Normalized Difference Water Index (NDWI) using bands `sur_refl_b01` and `sur_refl_b02` from the `band` variable. Rename the NDWI band to `ndwi` and return the resulting image. Finally, using the `ee` library, load the MODIS/061/MOD09Q1 image collection, select bands starting with `sur`, filter the collection for images between 2023 and 2024, apply the `func_` function to each image, and calculate the median of the resulting NDWI images. Store this median NDWI image in a variable named `modis2023`. Make sure to define the variables `ndwi` and `band` within the function and `modis2023` outside of the function.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n", "functions": ["img.multiply", "unknown_function.rename", "band.normalizedDifference", "unknown_function.median", "unknown_function.map", "unknown_function.filterDate", "unknown_function.select", "ee.ImageCollection"], "external_vars": ["ee", "func_"], "defined_vars": ["ndwi", "img", "band", "modis2023"], "parameters": [0.0001, "ndwi", "func_", "2023", "2024", "sur.*", "MODIS/061/MOD09Q1", "['sur_refl_b01', 'sur_refl_b02']"], "libraries": ["import ee", "import geemap"]}
{"code": "## Load the Sentinel-1 ImageCollection.\nsentinel1 = ee.ImageCollection('COPERNICUS/S1_GRD')\n", "task": "Using the Earth Engine library (ee), define a variable named \"sentinel1\" and assign it to the Sentinel-1 Ground Range collection.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["sentinel1"], "parameters": ["COPERNICUS/S1_GRD"], "libraries": ["import geemap", "import ee"]}
{"code": "# Select the benthic habitat band.And mask it.\nbenthic_habitat = dataset.select('benthic').selfMask()\n# Add the benthic habitat layer to the map.\nMap.addLayer(benthic_habitat, {}, \"Benthic habitat map\")\n", "task": "Using the provided dataset, select the \"benthic\" band and apply a self-mask to it.  Store the result in a variable called `benthic_habitat`. Then, add this `benthic_habitat` to the `Map` as a new layer named \"Benthic habitat map\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the ACA/reef_habitat/v1_0 dataset.\ndataset = ee.Image('ACA/reef_habitat/v1_0')\n", "functions": ["unknown_function.selfMask", "dataset.select", "Map.addLayer"], "external_vars": ["dataset", "Map"], "defined_vars": ["benthic_habitat"], "parameters": ["benthic", "benthic_habitat", "Benthic habitat map", "{}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Clip the filtered NAIP image to the Allegheny County boundary.\nclipped_naip = filtered_naip.clip(alle_co)\n", "task": "Clip the `filtered_naip` array using the values in `alle_co`. Store the resulting clipped array in a new variable called `clipped_naip`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Set the year of interest.\nyear = 2017\n# Load the raw NAIP image collection.\nraw_naip = ee.ImageCollection('USDA/NAIP/DOQQ')\n# Filter the NAIP collection by year and select only the RGB bands.\nfiltered_naip = raw_naip.select(['R', 'G', 'B']).filterDate(\n    str(year) + '-01-01', str(year) + '-12-31').mosaic()\n# Load the Allegheny County boundary feature collection.\nalle_co = ee.FeatureCollection('users/englishr18/AlleghenyCounty_Boundary2016')\n", "functions": ["filtered_naip.clip"], "external_vars": ["alle_co", "filtered_naip"], "defined_vars": ["clipped_naip"], "parameters": ["alle_co"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the geometry of the oil spill area\noil = ee.Geometry.Polygon([[[57.71639387540342, -20.380972663998552],\n                           [57.71639387540342, -20.42055266581538],\n                           [57.7538160555792, -20.42055266581538],\n                           [57.7538160555792, -20.380972663998552]]])\n", "task": "Using the ee library, define a variable called `oil` as a polygon geometry with the following coordinates: [[[57.71639387540342, -20.380972663998552], [57.71639387540342, -20.42055266581538], [57.7538160555792, -20.42055266581538], [57.7538160555792, -20.380972663998552]]]", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the geometry of the area of interest\ngeometry = ee.Geometry.Polygon([[[-90.15234375, 30.26147225282594], [-90.15234375, 29.52614052092204],\n                               [-89.049072265625, 29.52614052092204], [-89.049072265625, 30.26147225282594]]])\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee"], "defined_vars": ["oil"], "parameters": ["[[[57.71639387540342, -20.380972663998552], [57.71639387540342, -20.42055266581538], [57.7538160555792, -20.42055266581538], [57.7538160555792, -20.380972663998552]]]"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the maxindex.And max images to the map for visualization.\nMap.addLayer(maxindex)\nMap.addLayer(max)\n\n\n", "task": "Add the layer at index `maxindex` to the `Map`. Then add the layer `max` to the `Map`.  Make sure `maxindex`, `max`, and `Map` are defined.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the image you want to work with.\nthearrayimage = ee.Image([3, 4, 1, 55, 2]).toArray()\n# Get the length of the array along the first dimension.\nlength = thearrayimage.arrayLength(0)\n# Create an index array with values from 0 to length-1.\nindices = ee.Image(ee.Array(ee.List.sequence(0, length))\n                   ).arraySlice(0, 0, length)\n# Sort the the array along the first dimension and get the index of the maximum value.\nmaxindex = indices.arraySort(thearrayimage).arraySlice(0, -1)\n# Sort the array along the first dimension and get the maximum value.\nmax = thearrayimage.arraySort().arraySlice(0, -1)\n", "functions": ["Map.addLayer", "Map.addLayer"], "external_vars": ["max", "Map", "maxindex"], "defined_vars": [], "parameters": ["maxindex", "max"], "libraries": ["import geemap", "import ee"]}
{"code": "# Extract multiple features from the feature collection\nroi = adm2.filterBounds(geometry)\n", "task": "Define a variable named `roi` by filtering the `adm2` object using the bounds specified in the `geometry` variable.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the geometry of interest (a multi-point geometry)\ngeometry = ee.Geometry.MultiPoint([[86.37282419555602, 23.305273163571], [87.04848337524352, 23.209384103179094], [\n                                  87.89443064086852, 23.34562685067499], [87.26089649984799, 22.443664263792446]])\n# Import the FAO GAUL Second Level Feature Collection\nadm2 = ee.FeatureCollection('FAO/GAUL_SIMPLIFIED_500m/2015/level2')\n", "functions": ["adm2.filterBounds"], "external_vars": ["geometry", "adm2"], "defined_vars": ["roi"], "parameters": ["geometry"], "libraries": ["import geemap", "import ee"]}
{"code": "# Apply the cloud masking function to the image collection\nmasked_img_coll = filtered_img_coll.map(mask_clouds)\n", "task": "Define a new variable named `masked_img_coll` by applying the `mask_clouds` function to each element in the `filtered_img_coll` collection using the `map` function.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the geometry of the area of interest\ngeometry = ee.Geometry.Polygon([[[33.76879166787937, 33.634182772277875], [33.76879166787937, 29.211041490949313], [\n                               36.28466080850437, 29.211041490949313], [36.28466080850437, 33.634182772277875]]])\n# Load the Sentinel-2 SR Harmonized image collection\ns2_img_coll = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')\n# Filter the image collection by the geometry and date range\nfiltered_img_coll = s2_img_coll.filterBounds(geometry).filterDate(\n    '2021-01-01', '2023-01-15').sort('system:time_start', True)\n# Define a function to mask clouds\n\n\ndef mask_clouds(img):\n    return img.updateMask(img.select('MSK_CLDPRB').lt(50))\n", "functions": ["filtered_img_coll.map"], "external_vars": ["filtered_img_coll", "mask_clouds"], "defined_vars": ["masked_img_coll"], "parameters": ["mask_clouds"], "libraries": ["import ee", "import geemap"]}
{"code": "# Print the size of the image collection\nprint(l8.size())\n", "task": "Print the size of the list `l8`. You will need to define the list `l8` first.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Import the Landsat 8 image collection\nl8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n", "functions": ["print", "l8.size"], "external_vars": ["l8", "print"], "defined_vars": [], "parameters": ["l8.size()"], "libraries": ["import geemap", "import ee"]}
{"code": "# center the map at the lat / lon of the site, set zoom to 12\nMap.setCenter(-119.25, 37.06, 11)\n", "task": "Set the center of the map to the coordinates (-119.25, 37.06) and zoom level to 11. You must first define a map object named \"Map\" and initialize it with the necessary library before running this instruction.", "exec_path": "GEE", "context": "import geemap\nMap = geemap.Map()\n", "functions": ["Map.setCenter"], "external_vars": ["Map"], "defined_vars": [], "parameters": [37.06, 11, "-119.25"], "libraries": ["import geemap"]}
{"code": "# Display the AOI on the map.\nMap.setCenter(geometry, 7)\n\n\n", "task": "Center the map on the given geometry, with a zoom level of 7. You will need to define the variables: `geometry`, `Map`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the geometry (Area of Interest, AOI).\ngeometry = ee.Geometry.Polygon([[114.33326848780293, -30.516664727629696], [114.33326848780293, -33.13001898040632], [\n                               117.54127630030288, -33.13001898040632], [117.54127630030288, -30.516664727629696]])\n", "functions": ["Map.setCenter"], "external_vars": ["geometry", "Map"], "defined_vars": [], "parameters": ["geometry", 7], "libraries": ["import geemap", "import ee"]}
{"code": "lake_elevation_2023 = ee.Number(dem.reduceRegion(\n  reducer=ee.Reducer.percentile([55]), geometry=vector2023, scale=250\n  ).values().get(0))\n\n\n", "task": "Calculate the 55th percentile elevation of the Digital Elevation Model (DEM) within the area defined by the `vector2023` geometry and store it in the variable `lake_elevation_2023`. Use a scale of 250 meters for the calculation.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [[44.86557382828752, 37.08659871132482], [46.08505625016252, 37.08659871132482], [46.08505625016252,\n                                                                                        38.34669285754838], [44.86557382828752, 38.34669285754838], [44.86557382828752, 37.08659871132482]]\nroi = ee.Geometry.Polygon(cor)\n\n\ndef func_(img):\n    band = img.multiply(0.0001)\n    ndwi = band.normalizedDifference(\n        ['sur_refl_b01', 'sur_refl_b02']).rename('ndwi')\n    return ndwi\n\n\ndem = ee.ImageCollection('JAXA/ALOS/AW3D30/V3_2').mean().select('DSM')\nmodis2023 = ee.ImageCollection(\n    'MODIS/061/MOD09Q1').select('sur.*').filterDate('2023', '2024').map(func_).median()\nthr2 = modis2023.gt(0.1)\nmask2023 = thr2.updateMask(thr2)\nvector2023 = mask2023.reduceToVectors(geometry=roi, scale=250)\n", "functions": ["ee.Number", "unknown_function.get", "unknown_function.values", "dem.reduceRegion", "ee.Reducer.percentile"], "external_vars": ["ee", "dem", "vector2023"], "defined_vars": ["lake_elevation_2023"], "parameters": [0, "dem.reduceRegion(reducer=ee.Reducer.percentile([55]), geometry=vector2023, scale=250).values().get(0)", "[55]"], "libraries": ["import ee", "import geemap"]}
{"code": "# Create a mosaic of the collection, using NDVI as the quality metric.\ngreenest = with_ndvi.qualityMosaic('nd')\n", "task": "Using the variable `with_ndvi`, create a new variable called `greenest` by applying the `qualityMosaic` method with argument `'nd'`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Define the LANDSAT 8 collection and the image of interest.\nl8 = ee.ImageCollection('LANDSAT/LC8_L1T_TOA')\nimage = ee.Image('LANDSAT/LC8_L1T_TOA/LC80440342013106LGN01')\n# Add NDVI to each image in the collection.\n\n\ndef add_ndvi(image):\n    ndvi = image.normalizedDifference(['B5', 'B4'])\n    return image.addBands(ndvi)\n\n\nwith_ndvi = l8.map(add_ndvi)\n", "functions": ["with_ndvi.qualityMosaic"], "external_vars": ["with_ndvi"], "defined_vars": ["greenest"], "parameters": ["nd"], "libraries": ["import ee", "import geemap"]}
{"code": "# Get the first image from the filtered collection.\nimage = ee.Image(filtered.first())\n", "task": "Define a variable named `image` as an Earth Engine image object. This image should be the first image in the Earth Engine image collection `filtered`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the region of interest.\nroi = ee.Geometry.Point([-122.10067749023438, 37.43615762405059])\n# Load the Landsat 8 collection.\ncollection = ee.ImageCollection('LANDSAT/LC8_L1T_TOA')\n# Filter the collection by date and region.\nfiltered = collection.filterDate('2015-09-01', '2015-10-30').filterBounds(roi)\n", "functions": ["ee.Image", "filtered.first"], "external_vars": ["filtered", "ee"], "defined_vars": ["image"], "parameters": ["filtered.first()"], "libraries": ["import geemap", "import ee"]}
{"code": "# Filter the Sentinel-2 collection by the ROI.And time period\nsentinel2 = ee.ImageCollection(\"COPERNICUS/S2\").filterBounds(ROI).filterDate(startD, endD)\nprint(sentinel2)\n", "task": "Define a variable named \"sentinel2\" and assign it to an Earth Engine ImageCollection. The collection should be \"COPERNICUS/S2\", filtered by the ROI boundary and the dates defined by \"startD\" and \"endD\". Then, print the \"sentinel2\" collection using the \"print\" function.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Set the region of interest (ROI) as a FeatureCollection\nROI = ee.FeatureCollection('users/ce15btech11022/Final_Cities/Ahmedabad')\n# Define the start and end dates for the time period of interest\nstartD = ee.Date('2014-01-01')\nendD = ee.Date('2019-12-31')\n", "functions": ["unknown_function.filterDate", "unknown_function.filterBounds", "ee.ImageCollection", "print"], "external_vars": ["startD", "ROI", "print", "ee", "endD"], "defined_vars": ["sentinel2"], "parameters": ["startD", "endD", "ROI", "COPERNICUS/S2", "sentinel2"], "libraries": ["import geemap", "import ee"]}
{"code": "# Adjust the min and max for the clipped image and add it to the map again\ndem_clip_viz = {'min': 0, 'max': 2000}\nMap.addLayer(dem_clip, dem_clip_viz, 'SRTM Image Clipped with Adjusted Visualization')\n", "task": "Define a visualization object called `dem_clip_viz` with a minimum value of 0 and a maximum value of 2000. Then, add the `dem_clip` layer to the `Map` with the specified visualization and label \"SRTM Image Clipped with Adjusted Visualization\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ndem = ee.Image('CGIAR/SRTM90_V4')\n# Define the geometry for the region of interest\nroi = ee.Geometry.Polygon([[102, 3], [102, 2.5], [102.5, 2.5], [102.5, 3]])\n# Clip the image using the region of interest\ndem_clip = dem.clip(roi)\n", "functions": ["Map.addLayer"], "external_vars": ["dem_clip", "Map"], "defined_vars": ["dem_clip_viz"], "parameters": ["dem_clip", "dem_clip_viz", "SRTM Image Clipped with Adjusted Visualization"], "libraries": ["import ee", "import geemap"]}
{"code": "# Load the NLCD RCMAP for the specified year\nnlcd_RCMAP = ee.ImageCollection(\"USGS/NLCD_RELEASES/2019_REL/RCMAP/V4/COVER\")\nnlcd_RCMAP_year = nlcd_RCMAP.filter(ee.Filter.stringContains(\"system:index\", name)).mosaic()\n", "task": "Using the ee library, load the USGS NLCD 2019 RCMAP data as an ImageCollection and store it in the variable `nlcd_RCMAP`. Then, filter the ImageCollection to only include the image with the name specified by the `name` variable, mosaic the filtered images, and store the result in the variable `nlcd_RCMAP_year`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Load the image collections\nimageCollection = ee.ImageCollection(\n    'projects/ee-annualsecond-landcover/assets/change_classification_all_82_87')\n# Set the year to 1987\nname = '1987'\n", "functions": ["ee.ImageCollection", "unknown_function.mosaic", "nlcd_RCMAP.filter", "ee.Filter.stringContains"], "external_vars": ["ee", "name"], "defined_vars": ["nlcd_RCMAP_year", "nlcd_RCMAP"], "parameters": ["USGS/NLCD_RELEASES/2019_REL/RCMAP/V4/COVER", "system:index", "name", "ee.Filter.stringContains('system:index', name)"], "libraries": ["import ee", "import geemap"]}
{"code": "# Calculate total sum of affected population Add pop number as a new property to ROI\nregion = region.set(affectedPopPuerto.select(['population']).reduceRegion(\n        reducer='sum',\n        scale=100,\n        geometry=region.geometry(),\n        maxPixels=1e23,\n    ))\nprint(region, 'sumFlooded_pop estimates')\n", "task": "Using the provided variable \"affectedPopPuerto\" which contains population data, calculate the sum of the population within the region defined by the variable \"region\". Use the \"reduceRegion\" method with a scale of 100 and a sum reducer. Then, print the region and the calculated population sum with the text \"sumFlooded_pop estimates\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load Admin-2 district data\nadm2 = ee.FeatureCollection('FAO/GAUL/2015/level2')\n# Select Puerto Cabezas District\nregion = adm2.filter(ee.Filter.eq('ADM2_CODE', 22395))\n# Select highest values (dry) Sentinel-1 data\ndry = ee.ImageCollection('COPERNICUS/S1_GRD').filterDate('2020-10-15', '2020-11-15').filter(ee.Filter.listContains(\n    'transmitterReceiverPolarisation', 'VV')).filterBounds(region).select('VV').reduce(ee.Reducer.percentile([97.5]))\n# Select lowest values (wet) Sentinel-1 data\nwet = ee.ImageCollection('COPERNICUS/S1_GRD').filterDate('2020-10-15', '2020-11-15').filter(ee.Filter.listContains(\n    'transmitterReceiverPolarisation', 'VV')).filterBounds(region).select('VV').reduce(ee.Reducer.percentile([2.5]))\n# Differences in backscatter between images\ndifference = wet.subtract(dry)\n# Threshold to determine whether there is flood or not\nthreshold = -15\n# Select pixels that meet threshold\ncategorical_floods = difference.lt(threshold)\n# Update mask with flooded pixels\nflooded = categorical_floods.updateMask(difference.lt(threshold))\n# Load population dataset Attention to 3-letter country code\nworldpop = ee.ImageCollection('WorldPop/GP/100m/pop_age_sex_cons_unadj').filterMetadata(\n    'country', 'equals', 'NIC').mean().select(['population'])\n# Apply flooded mask to population dataset\npop_affected = worldpop.updateMask(flooded)\n# Use ROI to clip\naffectedPopPuerto = pop_affected.clip(region)\n", "functions": ["region.set", "unknown_function.reduceRegion", "affectedPopPuerto.select", "region.geometry", "print"], "external_vars": ["affectedPopPuerto", "print"], "defined_vars": ["region"], "parameters": ["region", "sumFlooded_pop estimates", "affectedPopPuerto.select(['population']).reduceRegion(reducer='sum', scale=100, geometry=region.geometry(), maxPixels=1e+23)", "['population']"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define a function to mask clouds based on the pixel_qa band.\ndef mask_l8sr(image):\n    # Get the pixel QA band.\n    qa = image.select('pixel_qa')\n\n    # Set cloud shadow.And cloud bit masks.\n    cloud_shadow_bit_mask = (1 << 3)\n    cloud_bit_mask = (1 << 5)\n\n    # Mask out pixels with cloud shadows or clouds.\n    mask = qa.bitwiseAnd(cloud_shadow_bit_mask).eq(0) .And(qa.bitwiseAnd(cloud_bit_mask).eq(0))\n\n    return image.updateMask(mask)\n", "task": "This function masks out cloud and cloud shadow pixels from an image. It uses the `pixel_qa` band to identify these pixels. You must define the following variables: `cloud_bit_mask`, `cloud_shadow_bit_mask`, `mask`, `qa`, and `image`.", "exec_path": "GEE", "context": "", "functions": ["image.select", "unknown_function.And", "unknown_function.eq", "qa.bitwiseAnd", "unknown_function.eq", "qa.bitwiseAnd", "image.updateMask"], "external_vars": [], "defined_vars": ["image", "qa", "cloud_shadow_bit_mask", "mask", "cloud_bit_mask"], "parameters": ["pixel_qa", 0, "cloud_shadow_bit_mask", 0, "cloud_bit_mask", "mask", "qa.bitwiseAnd(cloud_bit_mask).eq(0)"], "libraries": []}
{"code": "# Get the global country boundaries data provided by GEE.And filter it to Indonesia.\ncountry = ee.FeatureCollection(\"FAO/GAUL/2015/level0\")\nfilter = ee.Filter.inList('ADM0_NAME', ['Indonesia'])\nfiltered_country = country.filter(filter)\n", "task": "Using the Earth Engine library (ee), define a variable named \"country\" that represents the FeatureCollection for the \"FAO/GAUL/2015/level0\" dataset. Then, create a filter named \"filter\" to select features with the \"ADM0_NAME\" attribute equal to \"Indonesia\". Finally, define a variable named \"filtered_country\" by filtering the \"country\" FeatureCollection using the \"filter\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.FeatureCollection", "ee.Filter.inList", "country.filter"], "external_vars": ["ee"], "defined_vars": ["country", "filter", "filtered_country"], "parameters": ["FAO/GAUL/2015/level0", "ADM0_NAME", "filter", "['Indonesia']"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the SRTM image.\nsrtm = ee.Image(\"USGS/SRTMGL1_003\")\n", "task": "Using the Earth Engine library, import the SRTM elevation data and assign it to a variable named `srtm`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["srtm"], "parameters": ["USGS/SRTMGL1_003"], "libraries": ["import ee", "import geemap"]}
{"code": "# Update the composite mask with the water mask.\nmasked_composite = median.updateMask(mask)\n", "task": "Define a variable named `masked_composite` and assign it the result of applying the `updateMask` method to the `median` object using the `mask` as an argument.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Load the Landsat 8 TOA collection.\nl8 = ee.ImageCollection('LANDSAT/LC08/C02/T1')\n# Filter the collection by date.\nl8_2016 = l8.filterDate('2016-01-01', '2016-12-31')\n# Compute the median composite.\nmedian = l8_2016.median()\n# Load the Hansen et al. forest change dataset.\nhansen_image = ee.Image('UMD/hansen/global_forest_change_2015')\n# Select the datamask band.\ndatamask = hansen_image.select('datamask')\n# Create a binary mask (land == 1, water == 2, na == 0).\nmask = datamask.eq(1)\n", "functions": ["median.updateMask"], "external_vars": ["mask", "median"], "defined_vars": ["masked_composite"], "parameters": ["mask"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the Landsat 8 collection.And the region of interest.\nl8 = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_L2\")\nreservoir = ee.FeatureCollection(\"users/pdas47/RAT-Training-2022/Sirindhorn\")\n", "task": "Using the Earth Engine library (ee), define two variables: \"l8\" to represent the Landsat 8 Collection 2 Tier 1 Level 2 image collection, and \"reservoir\" to represent a feature collection named \"Sirindhorn\" located within the user \"pdas47\" folder.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection", "ee.FeatureCollection"], "external_vars": ["ee"], "defined_vars": ["reservoir", "l8"], "parameters": ["LANDSAT/LC08/C02/T1_L2", "users/pdas47/RAT-Training-2022/Sirindhorn"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define the start.And end dates for the time period of interest\nstartD = ee.Date('2014-01-01')\nendD = ee.Date('2019-12-31')\n", "task": "Define two variables, `startD` and `endD`, using the `ee.Date()` function to represent the start date of 2014-01-01 and the end date of 2019-12-31 respectively.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Date", "ee.Date"], "external_vars": ["ee"], "defined_vars": ["startD", "endD"], "parameters": ["2014-01-01", "2019-12-31"], "libraries": ["import geemap", "import ee"]}
{"code": "geometry = ee.Geometry.Point(cor)\ntable = ee.FeatureCollection(\"WWF/HydroSHEDS/v1/Basins/hybas_5\")\nroi = table.filterBounds(geometry).map(lambda feature:feature.simplify(3000))\nMap.centerObject(roi)\nMap.addLayer(roi)\n", "task": "Use the Earth Engine library (`ee`) to define a point geometry using the coordinate `cor`. Then, load the HydroSHEDS basins feature collection (`table`) and filter it to include only features that intersect the defined geometry. Next, simplify the geometries in the filtered feature collection using the `simplify` method with a maximum distance of 3000 meters and assign the resulting feature collection to `roi`. Finally, center the map on `roi` and add it to the map using the `Map` object. Make sure to define the variables `roi`, `table`, and `geometry` before running this code.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [45.68929902130395, 37.11033465203267]\n", "functions": ["ee.Geometry.Point", "ee.FeatureCollection", "unknown_function.map", "table.filterBounds", "feature.simplify", "Map.centerObject", "Map.addLayer"], "external_vars": ["ee", "feature", "Map", "cor"], "defined_vars": ["geometry", "roi", "table"], "parameters": ["cor", "WWF/HydroSHEDS/v1/Basins/hybas_5", "geometry", 3000, "roi", "roi", "lambda feature: feature.simplify(3000)"], "libraries": ["import ee", "import geemap"]}
{"code": "# Create a point geometry using the coordinates.\npoint = ee.Geometry.Point([-106, 33])\n", "task": "Using the Earth Engine library (ee), define a variable called `point` that represents a point geometry located at longitude -106 and latitude 33.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Geometry.Point"], "external_vars": ["ee"], "defined_vars": ["point"], "parameters": ["[-106, 33]"], "libraries": ["import ee", "import geemap"]}
{"code": "# Filter the dataset by the AOI\ns1 = dataset.filterBounds(AOI)\n", "task": "Filter the dataset based on the area of interest (AOI) and assign the resulting filtered dataset to the variable s1.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Specify the Sentinel-2 SR dataset\ndataset = ee.ImageCollection('COPERNICUS/S2_SR')\n# Define the geometry (Area of Interest)\ncoordinates = [[70.58174517005682, 21.913531643276908], [70.58163318783045, 21.913926678518507], [70.58154467493296, 21.913990443946926], [70.58152589946985, 21.914201958334374], [70.58133646845818, 21.91434286406814], [\n    70.58040037751198, 21.91404176731981], [70.5802297219634, 21.91382278746666], [70.58051940053701, 21.913245164278514], [70.58068636804819, 21.913180776411302], [70.58174517005682, 21.913531643276908]]\nAOI = ee.Geometry.Polygon(coordinates)\n", "functions": ["dataset.filterBounds"], "external_vars": ["AOI", "dataset"], "defined_vars": ["s1"], "parameters": ["AOI"], "libraries": ["import geemap", "import ee"]}
{"code": "# Define a function that takes a number and adds 1 to it\ndef my_function(number):\n    \"\"\"Add 1 to the input number.\n\n    Args:\n        number: The number to add 1 to.\n\n    Returns:\n        The input number plus 1.\n    \"\"\"\n    return number + 1\n\nprint(my_function(1))\n", "task": "Print the result of calling the function `my_function` with the argument `1`. Make sure that the function `my_function` and the `print` function are defined. You will also need to define a variable named `number`.", "exec_path": "GEE", "context": "", "functions": ["print", "my_function"], "external_vars": ["my_function", "print"], "defined_vars": ["number"], "parameters": [1, "my_function(1)"], "libraries": []}
{"code": "# Center the map on the region of interest\nMap.setCenter(71.5426, 34.0142, 9)\n", "task": "Using the provided `Map` object, set the map center to the coordinates (71.5426, 34.0142) and zoom level to 9. You will need to define the following variables: `Map`.", "exec_path": "GEE", "context": "import geemap\nMap = geemap.Map()\n", "functions": ["Map.setCenter"], "external_vars": ["Map"], "defined_vars": [], "parameters": [71.5426, 34.0142, 9], "libraries": ["import geemap"]}
{"code": "Map.centerObject(roi)\nMap.addLayer(roi)\n", "task": "Center the map on the region of interest (`roi`) and add the `roi` as a layer to the map (`Map`).  Make sure to define the variables `roi` and `Map` before running this code.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ncor = [52.29632817890257, 33.99522092192627]\npoint = ee.Geometry.Point(cor)\ntable = ee.FeatureCollection('FAO/GAUL/2015/level0')\nroi = table.filterBounds(point)\n", "functions": ["Map.centerObject", "Map.addLayer"], "external_vars": ["roi", "Map"], "defined_vars": [], "parameters": ["roi", "roi"], "libraries": ["import geemap", "import ee"]}
{"code": "# Apply morphological operations to the median composite image.\nim_s2_morph = im_s2.reduceNeighborhood(reducer=thisReducer, kernel=thisKernel)\n", "task": "Define a new variable named `im_s2_morph` by applying the `reduceNeighborhood` method to the image `im_s2`. Use the `thisReducer` function as the reducer and `thisKernel` as the kernel.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the Sentinel-2 SR image collection.\nic_s2 = ee.ImageCollection('COPERNICUS/S2_SR')\n# Define the point of interest (Perth, Australia).\npt_perth = ee.Geometry.Point([115.8, -31.9])\n# Filter the image collection by date and location, and select the B8 band.\nim_s2 = ic_s2.filterDate(\n    '2019-01-01', '2019-01-31').filterBounds(pt_perth).select('B8').median()\n# Define the kernel for morphological operations.\nthisKernel = ee.Kernel.square(radius=9, units='pixels')\n# Define the reducer for morphological operations.\nthisReducer = ee.Reducer.median()\n", "functions": ["im_s2.reduceNeighborhood"], "external_vars": ["thisKernel", "thisReducer", "im_s2"], "defined_vars": ["im_s2_morph"], "parameters": [], "libraries": ["import geemap", "import ee"]}
{"code": "# Function example\ndef add_ndvi(image):\n    ndvi = image.normalizedDifference(['B5', 'B4']).rename('NDVI')\n    return image.addBands(ndvi)\n", "task": "Given an image object [], add a band named \"NDVI\" to the image, calculated as the normalized difference between bands \"B5\" and \"B4\". Use the variables \"ndvi\" and \"image\".", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# ee.Geometry.Point() function as demonstrated here.\npoint = ee.Geometry.Point([-41.4329728109325, -12.57788396003372])\n# Import the Landsat 8 TOA image collection.\nl8 = ee.ImageCollection('LANDSAT/LC08/C02/T1')\n# Get the least cloudy image in 2015\nimage = l8.filterBounds(point).filterDate(\n    '2015-01-01', '2015-12-31').sort('CLOUD_COVER').first()\n", "functions": ["unknown_function.rename", "image.normalizedDifference", "image.addBands"], "external_vars": [], "defined_vars": ["image", "ndvi"], "parameters": ["NDVI", "ndvi", "['B5', 'B4']"], "libraries": ["import ee", "import geemap"]}
{"code": "# Compute a simple expression using the elevation band.\njunk = elev.add(3)\nMap.addLayer(junk, {'min': 0, 'max': 500}, 'junk')\n", "task": "Add 3 to the elevation data stored in the `elev` variable and store the result in a new variable called `junk`. Then add the new elevation data to the `Map` object as a new layer with a minimum value of 0 and a maximum value of 500, using the name \"junk\" for the layer.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load the ALOS AW3D30 DSM image collection.\ndsm = ee.ImageCollection('JAXA/ALOS/AW3D30/V3_2')\n# Get the elevation in meters band.\nelev = dsm.select('DSM').first()\n", "functions": ["elev.add", "Map.addLayer"], "external_vars": ["elev", "Map"], "defined_vars": ["junk"], "parameters": [3, "junk", "junk", "{'min': 0, 'max': 500}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Reduce the slope over the ROI to get the mean slope value\nslope_mean = slope.reduceRegion(\n    reducer=ee.Reducer.mean(), geometry=geometry, scale=30\n)\nprint(\"Mean slope:\", slope_mean)\n", "task": "Calculate the mean slope value within the specified geometry using the `ee.Reducer.mean()` function and store the result in the variable `slope_mean`. Then, print the mean slope value using the `print` function.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the input datasets\nsrtm = ee.Image('USGS/SRTMGL1_003')\n# Define the region of interest (ROI) geometry\ngeometry = ee.Geometry.MultiPolygon([[[88.4176526607248, 26.958581780770697], [88.4176526607248, 26.785857070373325], [88.50554328572477, 26.785857070373325], [88.50554328572477, 26.958581780770697]], [\n                                    [87.97123481610889, 22.99437557223194], [87.97123481610889, 22.346848722531035], [88.53703071454639, 22.346848722531035], [88.53703071454639, 22.99437557223194]]], None, False)\n# Calculate the slope of the terrain\nslope = ee.Terrain.slope(srtm)\n", "functions": ["slope.reduceRegion", "ee.Reducer.mean", "print"], "external_vars": ["geometry", "ee", "slope", "print"], "defined_vars": ["slope_mean"], "parameters": ["Mean slope:", "slope_mean"], "libraries": ["import geemap", "import ee"]}
{"code": "# Add the annual CHIRPS sum to the map.\nMap.addLayer(chirps_anual, visparams, 'chuva anual')\n\n\n", "task": "Add the `chirps_anual` layer to the `Map` using the styling parameters defined in `visparams`. Name the layer \"chuva anual\".  The variables `chirps_anual`, `visparams`, and `Map` should be defined beforehand.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the CHIRPS image collection.\nchirps = ee.ImageCollection('UCSB-CHG/CHIRPS/DAILY')\n# Define the paises feature collection.\npaises = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017')\n# Filter the CHIRPS image collection by date.\ncol_filter = chirps.filterDate('2021-01-01', '2021-12-31')\n# Filter the paises feature collection by country.\nbr = paises.filterMetadata('country_na', 'equals', 'Brazil')\n# Calculate the annual CHIRPS sum.\nchirps_anual = col_filter.sum().clip(br)\n# Define the visualization parameters.\nvisparams = {'min': 0, 'max': 2800, 'palette': ['red', 'yellow', 'blue']}\n", "functions": ["Map.addLayer"], "external_vars": ["visparams", "Map", "chirps_anual"], "defined_vars": [], "parameters": ["chirps_anual", "visparams", "chuva anual"], "libraries": ["import geemap", "import ee"]}
{"code": "# Filter the Landsat 8 collection by date, cloud cover, and geometry\nls8_filtered = ls8.filterDate('2017-01-01', '2017-12-31') .filterMetadata('CLOUD_COVER', 'less_than', 10) .filterBounds(geometry)\n", "task": "Using the provided `ls8` variable, filter the data to include only Landsat 8 images acquired between January 1st and December 31st, 2017. Then, further filter the results to only include images with a cloud cover less than 10%. Finally, filter the results to only include images within the bounds defined by the `geometry` variable. Assign the resulting filtered dataset to the variable `ls8_filtered`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Define the Landsat 8 collection\nls8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n# Define the geometry of interest\ngeometry = ee.Geometry.Point([-50.2155865458148, -4.498646827554517])\n", "functions": ["unknown_function.filterBounds", "unknown_function.filterMetadata", "ls8.filterDate"], "external_vars": ["ls8", "geometry"], "defined_vars": ["ls8_filtered"], "parameters": ["geometry", "CLOUD_COVER", "less_than", 10, "2017-01-01", "2017-12-31"], "libraries": ["import ee", "import geemap"]}
{"code": "Map.addLayer(mask2001.clip(roi),{},'mask2001',False)\n", "task": "Add a layer to the Map object named \"mask2001\" using the clipped version of the mask2001 GeoDataFrame by the roi GeoDataFrame. Do not display the layer initially. Make sure to define the following variables: [roi, mask2001, Map].", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor = [[44.86557382828752, 37.08659871132482], [46.08505625016252, 37.08659871132482], [46.08505625016252,\n                                                                                        38.34669285754838], [44.86557382828752, 38.34669285754838], [44.86557382828752, 37.08659871132482]]\nroi = ee.Geometry.Polygon(cor)\n\n\ndef func_(img):\n    band = img.multiply(0.0001)\n    ndwi = band.normalizedDifference(\n        ['sur_refl_b01', 'sur_refl_b02']).rename('ndwi')\n    return ndwi\n\n\nmodis2001 = ee.ImageCollection(\n    'MODIS/061/MOD09Q1').select('sur.*').filterDate('2001', '2002').map(func_).median()\nthr = modis2001.gt(0.1)\nmask2001 = thr.updateMask(thr)\n", "functions": ["Map.addLayer", "mask2001.clip"], "external_vars": ["roi", "Map", "mask2001"], "defined_vars": [], "parameters": ["mask2001", false, "roi", "mask2001.clip(roi)", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add the geometries to the map\nMap.addLayer(rasau, {}, 'Rasau')\nMap.addLayer(teraju, { 'color': 'red' }, 'Teraju')\nMap.addLayer(combined_feature_collection, { 'color': 'yellow' }, 'Combined FeatureCollection')\n", "task": "Add the following layers to the map, using the provided variables: **rasau**, **teraju**, **combined_feature_collection** (all defined previously). Set the **rasau** layer with default styling, **teraju** with a red color, and **combined_feature_collection** with a yellow color.  Note: the variable **Map** is a reference to the map object.  ", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Define the geometries\nrasau = ee.Geometry.Polygon([[[109.36759927623041, -0.37732380252294057], [109.73289468638666, -0.3608446523071547], [\n                            109.74662759654291, -0.16034634016061264], [109.56535318248041, -0.09717511616032641], [109.37309244029291, -0.14661347930809696]]])\nteraju = ee.Geometry.Polygon([[[110.07347085826166, -0.4569725639866767], [110.42777994029291, -0.45971905813534153], [\n                             110.54862954966791, -0.20429142909870354], [110.15312173716791, -0.20429142909870354]]])\ncombined_feature_collection = rasau.union(teraju)\n", "functions": ["Map.addLayer", "Map.addLayer", "Map.addLayer"], "external_vars": ["teraju", "Map", "combined_feature_collection", "rasau"], "defined_vars": [], "parameters": ["rasau", "Rasau", "teraju", "Teraju", "combined_feature_collection", "Combined FeatureCollection", "{}", "{'color': 'red'}", "{'color': 'yellow'}"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the Sentinel-2 image collection.\ns2 = ee.ImageCollection(\"COPERNICUS/S2\")\n", "task": "Using the Earth Engine library (`ee`), load the Sentinel-2 image collection and assign it to a variable named `s2`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["s2"], "parameters": ["COPERNICUS/S2"], "libraries": ["import geemap", "import ee"]}
{"code": "# Clip the composite image to the region of interest\nclipped_image = composite.clip(delhi) .select('SR_B.*')\n", "task": "Clip the composite image using the geographic bounds defined by `delhi`, and then select only the bands that start with \"SR_B\" and assign them to a variable called `clipped_image`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Import an uploaded feature collection\ndelhi = ee.FeatureCollection('users/geonextgis/Delhi_New')\n# Import the Landsat 8 image collection\nl8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n# Filter the image collection by location, date, and metadata\nfilteredL8 = l8.filterBounds(delhi).filterDate(\n    '2020-01-01', '2020-12-31').filterMetadata('CLOUD_COVER', 'less_than', 10)\n# Create a median composite of the filtered image collection\ncomposite = filteredL8.median()\n", "functions": ["unknown_function.select", "composite.clip"], "external_vars": ["composite", "delhi"], "defined_vars": ["clipped_image"], "parameters": ["SR_B.*", "delhi"], "libraries": ["import geemap", "import ee"]}
{"code": "Map.addLayer(after.median().clip(geometry2),{'bands': ['SR_B5','SR_B4','SR_B3']},'after_rgb',False)\n", "task": "Add a layer to the Map object named \"after_rgb\" using the median of the \"after\" image clipped to the \"geometry2\" geometry. Use the bands \"SR_B5\", \"SR_B4\", and \"SR_B3\" for the visualization. Set the \"opacity\" parameter to False.  \\n\\n**Required variables:**\\n- `after` (Image): An Earth Engine image to be processed.\\n- `geometry2` (Geometry): A geometry to clip the image.\\n- `Map` (Map): The Earth Engine map object to add the layer to.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncor1 = [-121.30739155546495, 37.83353662375529]\ngeometry = ee.Geometry.Point(cor1)\ncor2 = [[-123.45801418605573, 38.81836572068789], [-122.44589870754011, 38.81836572068789], [-122.44589870754011,\n                                                                                             39.64593638831554], [-123.45801418605573, 39.64593638831554], [-123.45801418605573, 38.81836572068789]]\ngeometry2 = ee.Geometry.Polygon(cor2)\nafter = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').select(['SR_.*']).filterDate(\n    '2018', '2019').filter(ee.Filter.calendarRange(8, 10, 'month')).filterBounds(geometry2)\n", "functions": ["Map.addLayer", "unknown_function.clip", "after.median"], "external_vars": ["geometry2", "after", "Map"], "defined_vars": [], "parameters": ["after_rgb", false, "geometry2", "after.median().clip(geometry2)", "{'bands': ['SR_B5', 'SR_B4', 'SR_B3']}"], "libraries": ["import ee", "import geemap"]}
{"code": "# Add the image to the map\nMap.addLayer(dem)\n", "task": "Add the Digital Elevation Model (DEM) layer to the map. Make sure you have defined the variables `dem` (representing the DEM data) and `Map` (representing the map object).", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ndem = ee.Image('CGIAR/SRTM90_V4')\n", "functions": ["Map.addLayer"], "external_vars": ["dem", "Map"], "defined_vars": [], "parameters": ["dem"], "libraries": ["import ee", "import geemap"]}
{"code": "# Filter the collection by geometry and date\nl8limite = l8.filterBounds(geometry).filterDate('2020-10-01', '2021-01-31')\n", "task": "Filter the Landsat 8 data (`l8`) to include only data within the specified geographic bounds (`geometry`) and within the date range from October 1, 2020, to January 31, 2021. Store the filtered data in a new variable called `l8limite`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Define the geometry\ngeometry = ee.Geometry.Point([-64.30008741975684, -31.472731901048824])\n# Load the Landsat 8 collection\nl8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')\n", "functions": ["unknown_function.filterDate", "l8.filterBounds"], "external_vars": ["geometry", "l8"], "defined_vars": ["l8limite"], "parameters": ["2020-10-01", "2021-01-31", "geometry"], "libraries": ["import ee", "import geemap"]}
{"code": "# Select all protected areas in the WDPA designated as 100% marine\nmpas = wdpa.filterMetadata('MARINE', 'equals', '2')\n", "task": "Using the `wdpa` variable, filter the metadata to select entries where the `MARINE` field is equal to `2` and assign the result to the variable `mpas`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Import the World Database on Protected Areas (WDPA) as a Feature Collection\nwdpa = ee.FeatureCollection('WCMC/WDPA/current/polygons')\n", "functions": ["wdpa.filterMetadata"], "external_vars": ["wdpa"], "defined_vars": ["mpas"], "parameters": ["MARINE", "equals", "2"], "libraries": ["import geemap", "import ee"]}
{"code": "# Select a single Landsat 8 scene based on bounds.And cloud cover\nscene = ee.Image(l8.filterBounds(poi).filterDate('2022-01-01', '2022-12-31').sort('CLOUD_COVER').first())\n", "task": "Using the Earth Engine library (ee), filter Landsat 8 imagery (l8) for the specified point of interest (poi) within the year 2022. Sort the results by cloud cover and select the image with the lowest cloud cover.  Define the variable \"scene\" to store the selected image.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define Landsat 8 and Landsat 7 image collections\nl8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n# Define a point of interest (POI)\npoi = ee.Geometry.Point([-2.0340396892932078, 6.505214584360318])\n# Filter Landsat 8 image collection by date range\nfilterDate = l8.filterDate('2022-01-01', '2022-12-31')\n", "functions": ["ee.Image", "unknown_function.first", "unknown_function.sort", "unknown_function.filterDate", "l8.filterBounds"], "external_vars": ["poi", "l8", "ee"], "defined_vars": ["scene"], "parameters": ["CLOUD_COVER", "2022-01-01", "2022-12-31", "poi", "l8.filterBounds(poi).filterDate('2022-01-01', '2022-12-31').sort('CLOUD_COVER').first()"], "libraries": ["import geemap", "import ee"]}
{"code": "# Select the NDVI band.\nndvi = dataset.select('NDVI')\n", "task": "Using the dataset, select the band named \"NDVI\" and assign it to the variable ndvi.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n# Define the MODIS NDVI dataset.\ndataset = ee.ImageCollection(\n    'MODIS/006/MOD13Q1').filter(ee.Filter.date('2001-01-01', '2017-12-31'))\n", "functions": ["dataset.select"], "external_vars": ["dataset"], "defined_vars": ["ndvi"], "parameters": ["NDVI"], "libraries": ["import geemap", "import ee"]}
{"code": "# Load the 3DEP elevation raster.\nELEVATION_3DEP = ee.Image(\"USGS/3DEP/10m\")\n", "task": "Using the Earth Engine library (ee), define a variable named `ELEVATION_3DEP` and assign it to the image collection \"USGS/3DEP/10m\".", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["ELEVATION_3DEP"], "parameters": ["USGS/3DEP/10m"], "libraries": ["import geemap", "import ee"]}
{"code": "def func6_(img):\n    sm1km = img.select('SM_1km')\n    sm9km = img.select('SM_9km').divide(100.0).toFloat()\n    cor = sm1km.add(sm9km.subtract(sm_1km_mean)).rename('SM_1km_cor')\n    return cor.copyProperties(img, img.propertyNames()) \n\nsm_cor =  sm_1km.map(func6_)\n\n\n", "task": "Define variables `img`, `sm_cor`, `cor`, `sm9km`, and `sm1km`.  Then, use the function `func6_` to map over the image `sm_1km` and store the result in the variable `sm_cor`. `func6_` takes an image as input and returns a corrected image based on the `sm_1km_mean`.", "exec_path": "GEE", "context": "import geemap\nimport ee\nee.Initialize()\nMap = geemap.Map()\ncor = [[45.69105798238498, 28.274725424381415], [52.45863610738498, 28.274725424381415], [52.45863610738498,\n                                                                                          34.24300069681132], [45.69105798238498, 34.24300069681132], [45.69105798238498, 28.274725424381415]]\ngeometry = ee.Geometry.Polygon(cor)\ntime_start = ee.Date('2023')\ntime_end = ee.Date('2024')\nsm = ee.ImageCollection(\n    'NASA/SMAP/SPL3SMP_E/006').select('soil_moisture_am').filterDate(time_start, time_end)\nlist_10days = ee.List.sequence(0, time_end.difference(time_start, 'day'), 10).map(\n    lambda i: ee.Date.fromYMD(2023, 1, 1).advance(i, 'days'))\n\n\ndef func_(start_date):\n    start_date = ee.Date(start_date)\n    end_date = start_date.advance(10, 'days')\n    img = sm.filterDate(start_date, end_date).median()\n    resample = img.resample().reproject(crs=img.projection().crs(), scale=1000)\n    return resample.multiply(100).toInt().set('system:time_start', start_date.millis()).set('system:time_end', end_date.millis()).set('system:index', start_date.format('YYYY-MM-dd'))\n\n\nsm_10days = ee.ImageCollection(list_10days.map(func_))\ntemp = ee.ImageCollection(\n    'MODIS/061/MOD11A1').select('LST_.*').filterDate(time_start, time_end)\n\n\ndef func2_(start_date):\n    start_date = ee.Date(start_date)\n    end_date = start_date.advance(10, 'days')\n    img = temp.filterDate(start_date, end_date).mean()\n    lst_day = img.select('LST_Day_1km').multiply(0.02)\n    lst_night = img.select('LST_Night_1km').multiply(0.02)\n    lst_delta = lst_day.subtract(lst_night).rename('LST_delta')\n    return lst_day.addBands(lst_delta).set('system:time_start', start_date.millis()).set('system:time_end', end_date.millis()).set('system:index', start_date.format('YYYY-MM-dd'))\n\n\ntemp_10days = ee.ImageCollection(list_10days.map(func2_))\nsr = ee.ImageCollection('MODIS/061/MOD09GA').select('sur.*').combine(\n    temp.select('LST_Day.*')).filterDate(time_start, time_end).map(func_)\n\n\ndef func4_(start_date):\n    start_date = ee.Date(start_date)\n    end_date = start_date.advance(10, 'days')\n    ndvi = sr.select('ndvi').filterDate(start_date, end_date).max()\n    ms = sr.select('sur.*').filterDate(start_date, end_date).median()\n    return ms.addBands(ndvi).set('system:time_start', start_date.millis()).set('system:time_end', end_date.millis()).set('system:index', start_date.format('YYYY-MM-dd'))\n\n\nsr_10days = ee.ImageCollection(list_10days.map(func4_))\nlandcover = ee.ImageCollection('MODIS/061/MCD12Q1').mode().select('LC_Type1')\ncollection = sr_10days.combine(temp_10days).combine(sm_10days).map(\n    lambda img: img.addBands(landcover).copyProperties(img, img.propertyNames()))\n\n\ndef func5_(img):\n    training_data = img.stratifiedSample(\n        numPoints=10, classBand='soil_moisture_am', region=geometry, scale=1000)\n    model = ee.Classifier.smileGradientTreeBoost(80).train(\n        features=training_data, classProperty='soil_moisture_am', inputProperties=img.bandNames()).setOutputMode('REGRESSION')\n    band_name = img.bandNames().remove('soil_moisture_am')\n    result = img.select(band_name).classify(\n        model).rename('SM_1km').divide(100.0).toFloat()\n    return result.addBands(img.select(['soil_moisture_am'], ['SM_9km'])).copyProperties(img, ['system:time_start', 'system:time_end'])\n\n\nsm_1km = collection.map(func5_)\nsm_1km_mean = sm_1km.select('SM_1km').mean()\n", "functions": ["img.select", "unknown_function.toFloat", "unknown_function.divide", "img.select", "unknown_function.rename", "sm1km.add", "sm9km.subtract", "cor.copyProperties", "img.propertyNames", "sm_1km.map"], "external_vars": ["func6_", "sm_1km", "sm_1km_mean"], "defined_vars": ["sm1km", "img", "cor", "sm9km", "sm_cor"], "parameters": ["SM_1km", 100.0, "SM_9km", "SM_1km_cor", "sm_1km_mean", "img", "func6_", "sm9km.subtract(sm_1km_mean)", "img.propertyNames()"], "libraries": ["import geemap", "import ee"]}
{"code": "# Filter the Landsat collection by date.\nl8raw_filtered = l8raw.filterDate(start_date, end_date)\n", "task": "Filter the dataframe `l8raw` by date, keeping only rows with dates between `start_date` and `end_date`. Store the filtered dataframe in a new variable called `l8raw_filtered`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\n# Load a collection of Landsat 8 raw images.\nl8raw = ee.ImageCollection('LANDSAT/LC08/C02/T1')\n# Define the start and end dates for the images to be used in the composite.\nstart_date = '2017-01-01'\nend_date = '2017-12-31'\n", "functions": ["l8raw.filterDate"], "external_vars": ["l8raw", "end_date", "start_date"], "defined_vars": ["l8raw_filtered"], "parameters": ["start_date", "end_date"], "libraries": ["import ee", "import geemap"]}
{"code": "despeckel = sen1.focalMean(100, 'square', 'meters')\n", "task": "Calculate the focal mean of the Sentinel-1 image `sen1` with a neighborhood size of 100 pixels, using a square kernel and measuring distances in meters. Store the result in a variable called `despeckel`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\ncor = [[32.33741352024498, 31.356500050396157], [32.59559223118248, 31.356500050396157], [32.59559223118248,\n                                                                                          31.58490130730319], [32.33741352024498, 31.58490130730319], [32.33741352024498, 31.356500050396157]]\nroi = ee.Geometry.Polygon(cor)\nsen1 = ee.ImageCollection('COPERNICUS/S1_GRD').select('VV').filterDate('2014', '2015').filterBounds(roi).filter(ee.Filter.calendarRange(10, 10, 'month')).filter(\n    ee.Filter.calendarRange(4, 4, 'day_of_month')).filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')).filter(ee.Filter.eq('instrumentMode', 'IW')).mosaic()\n", "functions": ["sen1.focalMean"], "external_vars": ["sen1"], "defined_vars": ["despeckel"], "parameters": [100, "square", "meters"], "libraries": ["import ee", "import geemap"]}
{"code": "# Calculate 8-day mean temperature for Uganda in 2015.\nclippedLSTc = modLSTc.mean().clip(SwazilandBorder)\n", "task": "Calculate the mean of the `modLSTc` array, then clip the resulting value between the bounds defined by `SwazilandBorder`. Store the clipped mean in a new variable called `clippedLSTc`.", "exec_path": "GEE", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\n# Import country boundaries feature collection.\ndataset = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017')\n# Apply filter where country name equals Uganda.\nSwazilandBorder = dataset.filter(ee.Filter.eq('country_na', 'Swaziland'))\n# Import LST image collection.\nmodis = ee.ImageCollection('MODIS/MOD11A2')\n# Define a date range of interest; here, a start date is defined and the end date is determined by advancing 1 year from the start date.\nstart = ee.Date('2015-01-01')\ndateRange = ee.DateRange(start, start.advance(1, 'year'))\n# Filter the LST collection to include only images intersecting the desired date range.\nmod11a2 = modis.filterDate(dateRange)\n# Select only the 1km day LST data band.\nmodLSTday = mod11a2.select('LST_Day_1km')\n# Scale to Kelvin and convert to Celsius, set image acquisition time.\nmodLSTc = modLSTday.map(lambda img: img.multiply(0.02).subtract(\n    273.15).copyProperties(img, ['system:time_start']))\n", "functions": ["unknown_function.clip", "modLSTc.mean"], "external_vars": ["SwazilandBorder", "modLSTc"], "defined_vars": ["clippedLSTc"], "parameters": ["SwazilandBorder"], "libraries": ["import ee", "import geemap"]}
