{"code": "\nlandcover = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\").select(\"landcover\")\nMap.addLayer(landcover, {}, \"NLCD 2019\")\nMap.add_legend(title=\"NLCD Land Cover Classification\", builtin_legend=\"NLCD\")\n\n#\n", "task": "Using the Earth Engine library (ee) and the Map object, import the 2019 National Land Cover Database (NLCD) image, select the \"landcover\" band, add it to the map with the label \"NLCD 2019\", and add a legend using the built-in NLCD legend. This will require defining a variable called `landcover`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nMap = geemap.Map(center=[40, -100], zoom=4)\nimage = ee.ImageCollection('COPERNICUS/S2').filterDate('2018-09-01',\n                                                       '2018-09-30').map(lambda img: img.divide(10000)).median()\n", "functions": ["unknown_function.select", "ee.Image", "Map.addLayer", "Map.add_legend"], "external_vars": ["ee", "Map"], "defined_vars": ["landcover"], "parameters": ["landcover", "USGS/NLCD_RELEASES/2019_REL/NLCD/2019", "landcover", "NLCD 2019", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nMap = geemap.Map()\nMap\n\n#\n", "task": "Using the geemap library, create a new map object named `Map`.", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.colormaps as cm\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import geemap.colormaps as cm", "import geemap"]}
{"code": "\nMap = geemap.Map()\nMap.split_map(left_layer=\"Google Terrain\", right_layer=\"OpenTopoMap\")\nMap\n\n#\n", "task": "Using the geemap library, create a map object named \"Map\" and then split it into two layers. The left layer should be \"Google Terrain\" and the right layer should be \"OpenTopoMap\".", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map", "Map.split_map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\ndates = images.aggregate_array(\"system:time_start\").map(\n    lambda d: ee.Date(d).format(\"YYYY-MM-dd\")\n)\nprint(dates.getInfo())\n\n#\n", "task": "Using the Earth Engine library `ee`, extract the start time of each image in the `images` collection, format the dates as \"YYYY-MM-dd\", and print the resulting list of dates.  Define a variable called `dates` to store the formatted date list.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\nroi = ee.Geometry.Point([-114.762293, 36.06462])\nstart_date = '2015-01-01'\nend_date = '2019-12-31'\ncloud_threshold = 0.05\nimages = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(roi).filterDate(\n    start_date, end_date).filterMetadata('CLOUD_COVER', 'less_than', cloud_threshold)\n", "functions": ["unknown_function.map", "images.aggregate_array", "unknown_function.format", "ee.Date", "print", "dates.getInfo"], "external_vars": ["ee", "images", "print", "d"], "defined_vars": ["dates"], "parameters": ["system:time_start", "YYYY-MM-dd", "d", "lambda d: ee.Date(d).format('YYYY-MM-dd')", "dates.getInfo()"], "libraries": ["import ee", "import geemap"]}
{"code": "\ntopo = gpd.read_file(file_path + 'topo3.shp')\ntopo.head()\n\n#\n", "task": "Read the shapefile \"topo3.shp\" from the specified path using the `gpd.read_file()` function and store the resulting geodataframe in a variable called `topo`. Then, display the first few rows of the dataframe using the `head()` function.", "exec_path": "gemgis-main", "context": "import geopandas as gpd\nfile_path = 'data/example03/'\n", "functions": ["gpd.read_file", "topo.head"], "external_vars": ["file_path", "gpd"], "defined_vars": ["topo"], "parameters": ["file_path + 'topo3.shp'"], "libraries": ["import geopandas as gpd"]}
{"code": "\ngeemap.pie_chart(\n    \"forest_cover.csv\", names=\"NAME\", values=\"sum\", max_rows=20, height=400\n)\n\n#\n", "task": "Using the geemap library, create a pie chart visualization from the \"forest_cover.csv\" file.  Set the \"NAME\" column as the names for each slice of the pie and the \"sum\" column as the values for each slice. Limit the chart to a maximum of 20 rows of data and set the height to 400 pixels.  Make sure the \"forest_cover.csv\" file and the geemap library are available.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nfrom geemap.datasets import get_metadata\ndata = 'GOES-17'\n", "functions": ["geemap.pie_chart"], "external_vars": ["geemap"], "defined_vars": [], "parameters": ["forest_cover.csv"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata"]}
{"code": "\ndf = geemap.ee_to_df(fc)\ndf\n\n#\n", "task": "Convert the Earth Engine FeatureCollection `fc` to a Pandas DataFrame and store it in the variable `df` using the `geemap.ee_to_df` function.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nimport ee\nee.Initialize()\nfrom geemap.datasets import get_metadata\nstates = ee.FeatureCollection('TIGER/2018/States')\ndata = 'https://github.com/gee-community/geemap/blob/master/examples/data/us_cities.csv'\nfc = states.filter(ee.Filter.eq('NAME', 'Alaska'))\n", "functions": ["geemap.ee_to_df"], "external_vars": ["geemap", "fc"], "defined_vars": ["df"], "parameters": ["fc"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import get_metadata"]}
{"code": "\nimg = mpimg.imread('data/images/example32/orientations_example32.png')\nplt.figure(figsize=(10, 10))\nimgplot = plt.imshow(img)\nplt.axis('off')\nplt.tight_layout()\n\n#\n", "task": "Using the libraries **mpimg** and **plt**, read an image from the path \"data/images/example32/orientations_example32.png\" and store it in a variable called **img**.  Display the image using **plt.imshow** and store the resulting image plot in a variable called **imgplot**. Turn off the axis labels and use **plt.tight_layout** to adjust the plot.", "exec_path": "gemgis-main", "context": "import matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n", "functions": ["mpimg.imread", "plt.figure", "plt.imshow", "plt.axis", "plt.tight_layout"], "external_vars": ["plt", "mpimg"], "defined_vars": ["img", "imgplot"], "parameters": ["data/images/example32/orientations_example32.png", "img", "off"], "libraries": ["import matplotlib.image as mpimg", "import matplotlib.pyplot as plt"]}
{"code": "\ngeemap.ee_to_csv(fc, filename=\"europe.csv\")\n\n#\n", "task": "Use the `geemap` library to convert the FeatureCollection `fc` to a CSV file named \"europe.csv\". Make sure the `geemap` library is imported and that the FeatureCollection `fc` is defined.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\nfc = ee.FeatureCollection(\n    'USDOS/LSIB_SIMPLE/2017').filter(ee.Filter.eq('wld_rgn', 'Europe'))\n", "functions": ["geemap.ee_to_csv"], "external_vars": ["geemap", "fc"], "defined_vars": [], "parameters": ["fc"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "import geemap", "import ee", "from geemap.datasets import DATA"]}
{"code": "\n# ax.coastlines()\nplt.show()\n\n#\n", "task": "Display the currently generated plot using the Matplotlib library. ", "exec_path": "geemap-master", "context": "import matplotlib.pyplot as plt\n", "functions": ["plt.show"], "external_vars": ["plt"], "defined_vars": [], "parameters": [], "libraries": ["import matplotlib.pyplot as plt"]}
{"code": "\ndef submit_clicked(b):\n    with output:\n        output.clear_output()\n        if start_year.value > end_year.value:\n            print(\"The end year must be great than the start year.\")\n            return\n        if start_month.value > end_month.value:\n            print(\"The end month must be great than the start month.\")\n            return\n        if start_year.value == end_year.value:\n            add_progress_bar = False\n        else:\n            add_progress_bar = True\n\n        start_date = str(start_month.value).zfill(2) + \"-01\"\n        end_date = str(end_month.value).zfill(2) + \"-30\"\n\n        print(\"Computing...\")\n\n        nd_bands = None\n        if (first_band.value is not None) and (second_band.value is not None):\n            nd_bands = [first_band.value, second_band.value]\n\n        Map.add_landsat_ts_gif(\n            roi=Map.user_roi,\n            label=title.value,\n            start_year=start_year.value,\n            end_year=end_year.value,\n            start_date=start_date,\n            end_date=end_date,\n            bands=bands.value.split(\"/\"),\n            font_color=font_color.value,\n            frames_per_second=speed.value,\n            font_size=font_size.value,\n            add_progress_bar=add_progress_bar,\n            progress_bar_color=progress_bar_color.value,\n            download=True,\n            apply_fmask=cloud.value,\n            nd_bands=nd_bands,\n            nd_threshold=nd_threshold.value,\n            nd_palette=[\"black\", nd_color.value],\n        )\n", "task": "Create a function named `submit_clicked` that takes an argument `b`. Within the function, use a `with output:` block to clear the output and check if the `start_year` is greater than the `end_year`. If so, print an error message and return. Repeat this check for the `start_month` and `end_month`. If the `start_year` and `end_year` are equal, set the variable `add_progress_bar` to `False`, otherwise set it to `True`.  Define the variables `start_date` and `end_date` using the `start_month`, `end_month`, and `str` functions. Print `Computing...` to the output. Define the variable `nd_bands` as `None` and check if `first_band` and `second_band` have values. If both are not `None`, set `nd_bands` to a list containing `first_band` and `second_band`. Finally, call the `Map.add_landsat_ts_gif` function with the following arguments: `roi=Map.user_roi`, `label=title.value`, `start_year=start_year.value`, `end_year=end_year.value`, `start_date=start_date`, `end_date=end_date`, `bands=bands.value.split('/')`, `font_color=font_color.value`, `frames_per_second=speed.value`, `font_size=font_size.value`, `add_progress_bar=add_progress_bar`, `progress_bar_color=progress_bar_color.value`, `download=True`, `apply_fmask=cloud.value`, `nd_bands=nd_bands`, `nd_threshold=nd_threshold.value`, `nd_palette=['black', nd_color.value]`.", "exec_path": "geemap-master", "context": "import geemap\nimport ipywidgets as widgets\n#\nMap = geemap.Map()\nstyle = {'description_width': 'initial'}\ntitle = widgets.Text(description='Title:',\n                     value='Landsat Timelapse', width=200, style=style)\nspeed = widgets.IntSlider(description=' Frames per second:',\n                          tooltip='Frames per second:', value=10, min=1, max=30, style=style)\ncloud = widgets.Checkbox(\n    value=True, description='Apply fmask (remove clouds, shadows, snow)', style=style)\nstart_year = widgets.IntSlider(\n    description='Start Year:', value=1984, min=1984, max=2020, style=style)\nend_year = widgets.IntSlider(\n    description='End Year:', value=2020, min=1984, max=2020, style=style)\nstart_month = widgets.IntSlider(\n    description='Start Month:', value=5, min=1, max=12, style=style)\nend_month = widgets.IntSlider(\n    description='End Month:', value=10, min=1, max=12, style=style)\nfont_size = widgets.IntSlider(\n    description='Font size:', value=30, min=10, max=50, style=style)\nfont_color = widgets.ColorPicker(\n    concise=False, description='Font color:', value='white', style=style)\nprogress_bar_color = widgets.ColorPicker(\n    concise=False, description='Progress bar color:', value='blue', style=style)\nfirst_band = widgets.Dropdown(description='1st band:', options=[\n                              'Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2'], value=None, style=style)\nsecond_band = widgets.Dropdown(description='2nd band:', options=[\n                               'Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2'], value=None, style=style)\nnd_threshold = widgets.FloatSlider(\n    value=0, min=-1, max=1, step=0.01, description='Threshold:', orientation='horizontal')\nnd_color = widgets.ColorPicker(\n    concise=False, description='Color:', value='blue', style=style)\noutput = widgets.Output()\n", "functions": ["output.clear_output", "print", "print", "unknown_function.zfill", "str", "unknown_function.zfill", "str", "print", "Map.add_landsat_ts_gif", "bands.value.split"], "external_vars": ["Map", "progress_bar_color", "first_band", "output", "str", "bands", "font_size", "print", "title", "end_month", "nd_color", "speed", "end_year", "cloud", "nd_threshold", "second_band", "font_color", "start_month", "start_year"], "defined_vars": ["start_date", "b", "add_progress_bar", "end_date", "nd_bands"], "parameters": ["The end year must be great than the start year.", "The end month must be great than the start month.", 2, 2, "Computing...", "/", "start_month.value", "end_month.value"], "libraries": ["import ipywidgets as widgets", "import geemap"]}
{"code": "\n# colors can be defined using either hex code or RGB (0-255, 0-255, 0-255)\ncolors = [\"#8DD3C7\", \"#FFFFB3\", \"#BEBADA\", \"#FB8072\", \"#80B1D3\"]\n# legend_colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68 123)]\n\nm.add_legend(keys=keys, colors=colors, position=\"bottomright\")\nm\n\n#\n", "task": "Add a legend to the plot represented by the variable `m` using the keys defined in `keys`.  Define a variable called `colors` with a list of colors for the legend. Position the legend in the bottom right corner of the plot. ", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nm = geemap.Map(add_google_map=False)\nkeys = ['One', 'Two', 'Three', 'Four', 'etc']\n", "functions": ["m.add_legend"], "external_vars": ["m", "keys"], "defined_vars": ["colors"], "parameters": [], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\ncollection = \"sentinel-2-l2a\"\nquery = {\"eo:cloud_cover\": {\"lt\": \"10\"}}\nsearch = catalog.search(intersects=aoi, collections=\"sentinel-2-l2a\", query=query)\n\n#\n", "task": "Using the `catalog` object, search for Sentinel-2 L2A data that intersects with the `aoi` region and has a cloud cover less than 10%. Define the variables `collection`, `search`, and `query` accordingly.", "exec_path": "PlanetaryComputerExamples-main", "context": "import pystac_client\ncatalog = pystac_client.Client.open(\n    'https://planetarycomputer.microsoft.com/api/stac/v1')\naoi = {'type': 'Polygon', 'coordinates': [[[29.036865234375, 7.857940257224196], [31.4813232421875, 7.857940257224196], [\n    31.4813232421875, 10.055402736564236], [29.036865234375, 10.055402736564236], [29.036865234375, 7.857940257224196]]]}\n", "functions": ["catalog.search"], "external_vars": ["catalog", "aoi"], "defined_vars": ["search", "collection", "query"], "parameters": [], "libraries": ["import pystac_client"]}
{"code": "\nprojection = image.select(0).projection().getInfo()\nprojection\n\n#\n", "task": "Define a variable called `projection` and assign it the projection information of the first band in the image `image`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nimage = ee.Image(\n    'LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318').select(['B5', 'B4', 'B3'])\n", "functions": ["unknown_function.getInfo", "unknown_function.projection", "image.select"], "external_vars": ["image"], "defined_vars": ["projection"], "parameters": [0], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nm = geemap.Map(center=[40, -100], zoom=4)\nm.add_basemap(\"Esri.WorldImagery\")\n\nnlcd = ee.Image(\"USGS/NLCD_RELEASES/2021_REL/NLCD/2021\")\nlandcover = nlcd.select(\"landcover\")\n\nm.add_layer(landcover, {}, \"NLCD Land Cover 2021\")\nm.add_legend(\n    title=\"NLCD Land Cover Classification\", builtin_legend=\"NLCD\", height=\"455px\"\n)\nm\n\n#\n", "task": "Using the `geemap` and `ee` libraries, create a map centered at [40, -100] with zoom level 4. Add the \"Esri.WorldImagery\" basemap. Load the NLCD 2021 land cover data using `ee.Image('USGS/NLCD_RELEASES/2021_REL/NLCD/2021')` and assign it to the variable `nlcd`. Extract the land cover band from `nlcd` and assign it to the variable `landcover`. Add the `landcover` layer to the map with the label \"NLCD Land Cover 2021\". Finally, add a legend to the map using the built-in \"NLCD\" legend, with a title \"NLCD Land Cover Classification\" and a height of \"455px\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n# Load an image.\nimage = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318')\n", "functions": ["geemap.Map", "m.add_basemap", "ee.Image", "nlcd.select", "m.add_layer", "m.add_legend"], "external_vars": ["ee", "geemap"], "defined_vars": ["m", "landcover", "nlcd"], "parameters": ["Esri.WorldImagery", "USGS/NLCD_RELEASES/2021_REL/NLCD/2021", "landcover", "landcover", "NLCD Land Cover 2021", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nleafmap.download_file(url, output=\"image.tif\")\n\n#\n", "task": "Download a GeoTIFF image from the URL provided to a file named \"image.tif\". Ensure the \"leafmap\" library is imported and the \"url\" variable is defined.", "exec_path": "segment-geospatial-main", "context": "import leafmap\n#\nurl = 'https://github.com/opengeos/datasets/releases/download/raster/Derna_sample.tif'\n", "functions": ["leafmap.download_file"], "external_vars": ["leafmap", "url"], "defined_vars": [], "parameters": ["url"], "libraries": ["import leafmap"]}
{"code": "\n# Allowed output formats: csv, shp, json, kml, kmz\n# Allowed statistics type: MEAN, MAXIMUM, MINIMUM, MEDIAN, STD, MIN_MAX, VARIANCE, SUM\ngeemap.zonal_stats(dem, states, out_dem_stats, stat_type=\"MEAN\", scale=1000)\n\n#\n", "task": "Calculate the mean elevation of the `dem` raster within each polygon in the `states` feature collection. Store the results in a new feature collection called `out_dem_stats`. Make sure to define `dem`, `geemap`, `states`, and `out_dem_stats` before running the code. You will need to define `geemap` as a library, `dem` as the DEM raster, `states` as a feature collection of state boundaries, and `out_dem_stats` as a feature collection to store the results. Use a `scale` of 1000 for the zonal statistics calculation.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nimport ee\nee.Initialize()\nimport os\n# Add Earth Engine datasets\ndem = ee.Image('USGS/SRTMGL1_003')\nstates = ee.FeatureCollection('TIGER/2018/States')\ncentroid = ee.Geometry.Point([-122.4439, 37.7538])\nimage = ee.ImageCollection(\n    'LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()\nout_dir = os.path.expanduser('~/Downloads')\nout_dem_stats = os.path.join(out_dir, 'dem_stats.csv')\n", "functions": ["geemap.zonal_stats"], "external_vars": ["dem", "geemap", "states", "out_dem_stats"], "defined_vars": [], "parameters": ["dem", "states", "out_dem_stats"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "import ee", "import os"]}
{"code": "\np.set_background('white')\np.show_grid(color='black')\np.set_scale(1,1,1)\np.show()\n\n#\n", "task": "Set the background color of the visualization to white, show a black grid, and set the scale to 1:1:1.  Display the visualization. You will need to define the following variables: [p] ", "exec_path": "gemgis-main", "context": "import pyvista as pv\np = pv.Plotter(notebook=True)\n", "functions": ["p.set_background", "p.show_grid", "p.set_scale", "p.show"], "external_vars": ["p"], "defined_vars": [], "parameters": ["white", 1, 1, 1], "libraries": ["import pyvista as pv"]}
{"code": "\n# Let's pre-process and process our image collection:\nL8 = (ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')\n      .filterBounds(pivots)\n      .maskClouds()\n      .scaleAndOffset()\n      .spectralIndices(['EVI','GNDVI']))\n", "task": "Using the Earth Engine library (ee) and a predefined variable called \"pivots\", define a variable named \"L8\" that represents a Landsat 8 image collection. This collection should be filtered by the bounds of \"pivots\", masked for clouds, scaled and offset, and then calculate the Enhanced Vegetation Index (EVI) and Green Normalized Difference Vegetation Index (GNDVI) spectral indices.", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\npivots = ee.FeatureCollection([ee.Feature(ee.Geometry.Point([27.724856, 26.48504]).buffer(400), {'pivot': 0}), ee.Feature(ee.Geometry.Point(\n    [27.719427, 26.478505]).buffer(400), {'pivot': 1}), ee.Feature(ee.Geometry.Point([27.714185, 26.471802]).buffer(400), {'pivot': 2})])\n", "functions": ["unknown_function.spectralIndices", "unknown_function.scaleAndOffset", "unknown_function.maskClouds", "unknown_function.filterBounds", "ee.ImageCollection"], "external_vars": ["pivots", "ee"], "defined_vars": ["L8"], "parameters": ["pivots", "LANDSAT/LC08/C01/T1_SR", "['EVI', 'GNDVI']"], "libraries": ["import eemont", "import ee", "import geemap"]}
{"code": "\ntoggle_button = widgets.ToggleButton(\n    value=False,\n    description=\"Click me\",\n    disabled=False,\n    button_style=\"success\",  # 'success', 'info', 'warning', 'danger' or ''\n    tooltip=\"Description\",\n    icon=\"check\",  # (FontAwesome names without the `fa-` prefix)\n)\ntoggle_button\n\n#\n", "task": "Using the `widgets` library, create a `ToggleButton` named `toggle_button` with the following attributes: `value=False`, `description='Click me'`, `disabled=False`, `button_style='success'`, `tooltip='Description'`, and `icon='check'`.", "exec_path": "geemap-master", "context": "import ipywidgets as widgets\n", "functions": ["widgets.ToggleButton"], "external_vars": ["widgets"], "defined_vars": ["toggle_button"], "parameters": [], "libraries": ["import ipywidgets as widgets"]}
{"code": "\nMap = geemap.Map()\nMap\n\n#\n", "task": "Using the geemap library, create a new map object and assign it to the variable \"Map\".", "exec_path": "geemap-master", "context": "import geemap\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import geemap"]}
{"code": "\nfile_path = 'data/example33/'\ngg.download_gemgis_data.download_tutorial_data(filename=\"example33_folded_layers.zip\", dirpath=file_path)\n\n#\n", "task": "Download the \"example33_folded_layers.zip\" file from the GemGIS tutorial data repository using the `gg.download_gemgis_data.download_tutorial_data()` function.  Make sure the file is saved to the directory defined by the `file_path` variable. **Note:**  This instruction requires the `gg` object and the `file_path` variable to be defined.", "exec_path": "gemgis-main", "context": "import gemgis as gg\n", "functions": ["gg.download_gemgis_data.download_tutorial_data"], "external_vars": ["gg"], "defined_vars": ["file_path"], "parameters": [], "libraries": ["import gemgis as gg"]}
{"code": "\ndf = geemap.ee_to_df(fc)\ndf\n\n#\n", "task": "Using the `geemap` library, convert the Earth Engine FeatureCollection `fc` into a Pandas DataFrame and store it in the variable `df`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nstates = ee.FeatureCollection('TIGER/2018/States')\nfc = states.filter(ee.Filter.eq('NAME', 'Louisiana'))\n", "functions": ["geemap.ee_to_df"], "external_vars": ["geemap", "fc"], "defined_vars": ["df"], "parameters": ["fc"], "libraries": ["from geemap.datasets import get_metadata", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\ngeo = xr.open_dataset(fsspec.open(item.assets[\"slstr-geodetic-in\"].href).open()).load()\ngeo\n\n#\n", "task": "Open the slstr-geodetic-in asset from the item using fsspec and xr.open_dataset, load it into memory and assign it to the variable \"geo\".", "exec_path": "PlanetaryComputerExamples-main", "context": "import planetary_computer\nimport pystac_client\nimport xarray as xr\nimport fsspec\ncatalog = pystac_client.Client.open(\n    'https://planetarycomputer.microsoft.com/api/stac/v1', modifier=planetary_computer.sign_inplace)\nsearch = catalog.search(collections=['sentinel-3-slstr-lst-l2-netcdf'],\n                        intersects={'type': 'Point', 'coordinates': [-105, 40]})\nitem = next(search.items())\n", "functions": ["unknown_function.load", "xr.open_dataset", "unknown_function.open", "fsspec.open"], "external_vars": ["xr", "fsspec", "item"], "defined_vars": ["geo"], "parameters": ["fsspec.open(item.assets['slstr-geodetic-in'].href).open()", "item.assets['slstr-geodetic-in'].href"], "libraries": ["import fsspec", "import planetary_computer", "import pystac_client", "import xarray as xr"]}
{"code": "\ngeemap.download_from_url(url, in_cog)\n\n#\n", "task": "Download the file from the given URL and save it to the specified Google Earth Engine asset. Make sure to define the variables `in_cog` and `url` before executing this code.", "exec_path": "geemap-master", "context": "import geemap\n#\nurl = 'https://github.com/giswqs/leafmap/raw/master/examples/data/cog.tif'\nin_cog = 'cog.tif'\n", "functions": ["geemap.download_from_url"], "external_vars": ["in_cog", "geemap", "url"], "defined_vars": [], "parameters": ["url", "in_cog"], "libraries": ["import geemap"]}
{"code": "\ngdf.head()\n\n#\n", "task": "Display the first 5 rows of the DataFrame `gdf`.", "exec_path": "leafmap-master", "context": "import geopandas as gpd\nbuildings = 'https://open.gishub.org/data/elevation/buildings.geojson'\ngdf = gpd.read_file(buildings)\n", "functions": ["gdf.head"], "external_vars": ["gdf"], "defined_vars": [], "parameters": [], "libraries": ["import geopandas as gpd"]}
{"code": "\nm = geemap.Map(center=[39.9898, -105.2532], zoom=14)\nm.add_vector(data, layer_name=\"Buildings\")\nm\n\n#\n", "task": "Using the `geemap` library, create a map centered at coordinates [39.9898, -105.2532] with a zoom level of 14. Add a vector layer named \"Buildings\" to the map using the `data` variable. Define a variable `m` to store the map object.", "exec_path": "geemap-master", "context": "import geemap\n# A subset of the dataset retrieved from https://github.com/johannesuhl/shapefile2gif\ndata = 'https://github.com/giswqs/data/raw/main/us/boulder_buildings.zip'\n", "functions": ["geemap.Map", "m.add_vector"], "external_vars": ["geemap", "data"], "defined_vars": ["m"], "parameters": ["data"], "libraries": ["import geemap"]}
{"code": "\nMap = geemap.Map(center=(40, -100), zoom=4)\n\ndem = ee.Image(\"USGS/SRTMGL1_003\")\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\nvis_params = {\n    \"min\": 0,\n    \"max\": 4000,\n    \"palette\": [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"],\n}\n\nMap.addLayer(dem, vis_params, \"SRTM DEM\", True, 1)\nMap.addLayer(states, {}, \"US States\", True)\n\nMap\n\n#\n", "task": "Using the geemap and ee libraries, create a map centered at (40, -100) with a zoom level of 4. Load the SRTM DEM elevation data as an image and display it on the map with a custom visualization parameters. Then, load the US states as a FeatureCollection and add it to the map. Define the following variables: states, vis_params, dem, and Map.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\nimage = ee.Image('LANDSAT/LC09/C02/T1_L2/LC09_044034_20220503')\n", "functions": ["geemap.Map", "ee.Image", "ee.FeatureCollection", "Map.addLayer", "Map.addLayer"], "external_vars": ["ee", "geemap"], "defined_vars": ["dem", "Map", "vis_params", "states"], "parameters": ["USGS/SRTMGL1_003", "TIGER/2018/States", "dem", "vis_params", "SRTM DEM", true, 1, "states", "US States", true, "{}"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "import geemap", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nfile_path = 'data/example05/'\ngg.download_gemgis_data.download_tutorial_data(filename=\"example05_folded_layers.zip\", dirpath=file_path)\n\n#\n", "task": "Using the `gg` object, download the tutorial data named \"example05_folded_layers.zip\" and save it to the directory specified by the variable `file_path`. **Make sure to define the `file_path` variable before executing this instruction.**", "exec_path": "gemgis-main", "context": "import gemgis as gg\n", "functions": ["gg.download_gemgis_data.download_tutorial_data"], "external_vars": ["gg"], "defined_vars": ["file_path"], "parameters": [], "libraries": ["import gemgis as gg"]}
{"code": "\norientations['polarity'] = 1\norientations.head()\n\n#\n", "task": "Set the \"polarity\" column in the \"orientations\" DataFrame to 1 and then display the first few rows of the DataFrame.", "exec_path": "gemgis-main", "context": "import geopandas as gpd\nfile_path = 'data/22_creating_temperature_maps_from_gempy_models/'\norientations = gpd.read_file(file_path + 'orientations.shp')\n", "functions": ["orientations.head"], "external_vars": ["orientations"], "defined_vars": [], "parameters": [], "libraries": ["import geopandas as gpd"]}
{"code": "\n# Define a neighborhood with a kernel.\nsquare = ee.Kernel.square(**{\"radius\": 4})\n#\n", "task": "Using the Earth Engine library (`ee`), define a variable named `square` representing a square kernel with a radius of 4.", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.foliumap as emap\nimport geemap as emap\nimport ee\nee.Initialize()\n", "functions": ["ee.Kernel.square"], "external_vars": ["ee"], "defined_vars": ["square"], "parameters": [], "libraries": ["import geemap.foliumap as emap", "import geemap as emap", "import ee", "import geemap"]}
{"code": "\n# ## Sharpening Image Collections\nMap = geemap.Map()\n", "task": "Using the geemap library, create a new Map object and assign it to the variable \"Map\".", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import eemont", "import ee", "import geemap"]}
{"code": "\n# Pystac has several methods that allow you to access links:\n#\n# In[5]:\n\n#\n# Get all child links\ncat.get_child_links()\n\n#\n", "task": "Get a list of all child links from the variable \"cat\". The variable \"cat\" should be a dictionary containing the link information. You may need to define additional variables like \"links\" to store the returned child links.", "exec_path": "pystac-main", "context": "import pystac\n#\ncat = pystac.Catalog.from_file('./example-catalog/catalog.json')\n", "functions": ["cat.get_child_links"], "external_vars": ["cat"], "defined_vars": [], "parameters": [], "libraries": ["import pystac"]}
{"code": "\npoint = ee.Geometry.Point(-99.2222, 46.7816)\ncollection = (\n    ee.ImageCollection(\"USDA/NAIP/DOQQ\")\n    .filterBounds(point)\n    .filterDate(\"2008-01-01\", \"2018-01-01\")\n    .filter(ee.Filter.listContains(\"system:band_names\", \"N\"))\n)\n\n#\n", "task": "Using the ee library, define a point geometry with coordinates -99.2222, 46.7816 and assign it to the variable \"point\". Then, filter the USDA/NAIP/DOQQ image collection to include images that intersect with the point, are within the dates 2008-01-01 and 2018-01-01, and have a band named \"N\". Assign the resulting filtered image collection to the variable \"collection\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\npoint = ee.Geometry.Point([1.5, 1.5])\n", "functions": ["ee.Geometry.Point", "unknown_function.filter", "unknown_function.filterDate", "unknown_function.filterBounds", "ee.ImageCollection", "ee.Filter.listContains"], "external_vars": ["ee"], "defined_vars": ["collection", "point"], "parameters": [46.7816, "2008-01-01", "2018-01-01", "point", "USDA/NAIP/DOQQ", "system:band_names", "N", "-99.2222", "ee.Filter.listContains('system:band_names', 'N')"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "import geemap", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nMap.add_colorbar(\n    vis_params,\n    label=\"Elevation (m)\",\n    layer_name=\"SRTM DEM\",\n    orientation=\"vertical\",\n    transparent_bg=True,\n)\n\n#\n", "task": "Add a colorbar to the map using the provided visualization parameters (`vis_params`). Label the colorbar \"Elevation (m)\" and set the layer name to \"SRTM DEM\". Orient the colorbar vertically and ensure the background is transparent.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nimport geemap.colormaps as cm\n#\nMap = geemap.Map()\n# Set visualization parameters.\nvis_params = {'min': 0, 'max': 4000, 'palette': [\n    '006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']}\n", "functions": ["Map.add_colorbar"], "external_vars": ["Map", "vis_params"], "defined_vars": [], "parameters": ["vis_params"], "libraries": ["import geemap.colormaps as cm", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nout_dir = os.getcwd()\n\nlandsat = os.path.join(out_dir, \"landsat.tif\")\ndem = os.path.join(out_dir, \"dem.tif\")\n\n#\n", "task": "Using the `os` module, define variables `out_dir`, `landsat`, and `dem`. Set `out_dir` to the current working directory. Set `landsat` to the path of a file named `landsat.tif` within `out_dir`. Set `dem` to the path of a file named `dem.tif` within `out_dir`.", "exec_path": "leafmap-master", "context": "import os\n", "functions": ["os.getcwd", "os.path.join", "os.path.join"], "external_vars": ["os"], "defined_vars": ["landsat", "dem", "out_dir"], "parameters": ["out_dir", "landsat.tif", "out_dir", "dem.tif"], "libraries": ["import os"]}
{"code": "\n# Select a region around the largest 2020 fire, Beachie Creek.\ngeom = ee.Geometry.Polygon(\n    [[[-122.77807114256022, 45.370803623985665],\n      [-122.77807114256022, 44.519360582318896],\n      [-121.46520493162272, 44.519360582318896],\n      [-121.46520493162272, 45.370803623985665]]]\n)\n", "task": "Using the ee library, define a variable named \"geom\" that represents a polygon with the following coordinates: [[-122.77807114256022, 45.370803623985665], [-122.77807114256022, 44.519360582318896], [-121.46520493162272, 44.519360582318896], [-121.46520493162272, 45.370803623985665]]", "exec_path": "wxee-main", "context": "import ee\nee.Initialize()\nimport wxee\nwxee.Initialize()\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee"], "defined_vars": ["geom"], "parameters": ["[[[-122.77807114256022, 45.370803623985665], [-122.77807114256022, 44.519360582318896], [-121.46520493162272, 44.519360582318896], [-121.46520493162272, 45.370803623985665]]]"], "libraries": ["import wxee", "import ee"]}
{"code": "\n# Assets\nt_assets = rich.table.Table(\"Key\", \"Value\")\nfor key, asset in items[0].assets.items():\n    t_assets.add_row(key, asset.title)\nt_assets\n\n#\n", "task": "Using the `rich` library, create a table named `t_assets` with columns \"Key\" and \"Value\".  Iterate through the assets of the first item in the `items` list. For each asset, define variables `key` and `asset` and add a row to `t_assets` with the key and the asset title.", "exec_path": "PlanetaryComputerExamples-main", "context": "import planetary_computer\nimport pystac_client\nimport rich.table\n# Open the Planetary Computer STAC API\ncatalog = pystac_client.Client.open(\n    'https://planetarycomputer.microsoft.com/api/stac/v1', modifier=planetary_computer.sign_inplace)\ncollection = catalog.get_collection('usgs-lcmap-conus-v13')\n# Search the catalog and collection for desired items\nlatitude = 45.523064\nlongitude = -122.676483\nPortland = [longitude, latitude]\ngeometry = {'type': 'Point', 'coordinates': Portland}\nsearch = catalog.search(collections=collection,\n                        intersects=geometry, datetime='2020/2021')\nitems = list(search.get_items())\n", "functions": ["rich.table.Table", "unknown_function.assets.items", "t_assets.add_row"], "external_vars": ["items", "rich"], "defined_vars": ["t_assets", "key", "asset"], "parameters": ["Key", "Value", "key", "asset.title"], "libraries": ["import planetary_computer", "import rich.table", "import pystac_client"]}
{"code": "\nm = geemap.Map()\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nfc = states.filter(ee.Filter.inList(\"NAME\", [\"California\", \"Oregon\", \"Washington\"]))\nm.add_layer(fc, {}, \"West Coast\")\nm.center_object(fc, 5)\nm\n\n#\n", "task": "Using the **ee** and **geemap** libraries, create a map object named **m**. Then, define a variable **states** as an Earth Engine FeatureCollection representing US states from the TIGER/2018/States dataset. Filter the states to include only California, Oregon, and Washington and store the result in a variable named **fc**. Finally, add this filtered FeatureCollection to the map as a layer named \"West Coast\" and center the map on the FeatureCollection with a zoom level of 5.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map", "ee.FeatureCollection", "states.filter", "ee.Filter.inList", "m.add_layer", "m.center_object"], "external_vars": ["ee", "geemap"], "defined_vars": ["m", "fc", "states"], "parameters": ["TIGER/2018/States", "NAME", "fc", "West Coast", "fc", 5, "ee.Filter.inList('NAME', ['California', 'Oregon', 'Washington'])", "['California', 'Oregon', 'Washington']", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nm = leafmap.Map(center=(51.5, -0.15), zoom=17)\nm\n\n#\n", "task": "Using the `leafmap` library, create a map object named `m` centered at coordinates (51.5, -0.15) with a zoom level of 17.", "exec_path": "leafmap-master", "context": "import leafmap\nimport leafmap.colormaps as cm\nimport leafmap.foliumap as leafmap\n", "functions": ["leafmap.Map"], "external_vars": ["leafmap"], "defined_vars": ["m"], "parameters": [], "libraries": ["import leafmap.foliumap as leafmap", "import leafmap.colormaps as cm", "import leafmap"]}
{"code": "\nm = leafmap.Map()\nm.add_widget(fig, position=\"bottomright\")\nm\n", "task": "Using the `leafmap` library, create a map object named `m`. Then, add the widget `fig` to the bottom-right corner of the map using the `add_widget` method.", "exec_path": "leafmap-master", "context": "import leafmap\nimport matplotlib.pyplot as plt\nfig, ax = plt.subplots(figsize=(4, 3))\n", "functions": ["leafmap.Map", "m.add_widget"], "external_vars": ["leafmap", "fig"], "defined_vars": ["m"], "parameters": ["fig"], "libraries": ["import matplotlib.pyplot as plt", "import leafmap"]}
{"code": "\nm = geemap.Map(center=[21.79, 70.87], zoom=3)\nimage = ee.Image(\"USGS/SRTMGL1_003\")\nvis_params = {\n    \"min\": 0,\n    \"max\": 6000,\n    \"palette\": [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"],  # 'terrain'\n}\nm.add_layer(image, vis_params, \"SRTM\")\nm\n\n#\n", "task": "Using the `ee` and `geemap` libraries, create a map centered at coordinates [21.79, 70.87] with a zoom level of 3. Define a variable `image` to represent the SRTMGL1_003 image from USGS. Define a `vis_params` dictionary for visualization with minimum value 0, maximum value 6000, and a specified palette. Add the `image` to the map using `vis_params` and label it as \"SRTM\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map", "ee.Image", "m.add_layer"], "external_vars": ["ee", "geemap"], "defined_vars": ["m", "image", "vis_params"], "parameters": ["USGS/SRTMGL1_003", "image", "vis_params", "SRTM"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nMap = geemap.Map()\nMap\n\n#\n", "task": "Using the `geemap` library, create a new map object named `Map`.", "exec_path": "geemap-master", "context": "import geemap\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import geemap"]}
{"code": "\ndf = geemap.csv_to_df(\"esa_cropland.csv\")\ndf.head()\n\n#\n", "task": "Using the geemap library, read the CSV file \"esa_cropland.csv\" into a Pandas DataFrame named \"df\" and then display the first few rows of the DataFrame.", "exec_path": "geemap-master", "context": "import geemap\n", "functions": ["geemap.csv_to_df", "df.head"], "external_vars": ["geemap"], "defined_vars": ["df"], "parameters": ["esa_cropland.csv"], "libraries": ["import geemap"]}
{"code": "\n# If used over an ee.Image, the result will be the same:\nS2.first().getSTAC()\n", "task": "Get the STAC (Spacecraft Time and Clock) of the first element in the list S2. **Note:** You need to define the variable `S2` before running this instruction.", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\nS2 = ee.ImageCollection('COPERNICUS/S2_SR')\n", "functions": ["unknown_function.getSTAC", "S2.first"], "external_vars": ["S2"], "defined_vars": [], "parameters": [], "libraries": ["import eemont", "import ee", "import geemap"]}
{"code": "\nMap.add_basemap(\"OpenTopoMap\")\n", "task": "Add the \"OpenTopoMap\" basemap to the map object `Map`.  You will need to define the `Map` object first.", "exec_path": "geemap-master", "context": "import geemap\nMap = geemap.Map(center=(40, -100), zoom=4)\n", "functions": ["Map.add_basemap"], "external_vars": ["Map"], "defined_vars": [], "parameters": ["OpenTopoMap"], "libraries": ["import geemap"]}
{"code": "\nsearch = catalog.search(\n    collections=[\"landsat-c2-l2\"],\n    bbox=bbox_of_interest,\n    datetime=time_of_interest,\n    query={\"eo:cloud_cover\": {\"lt\": 10}},\n)\n\nitems = search.item_collection()\nprint(f\"Returned {len(items)} Items\")\n\n#\n", "task": "Using the provided `catalog` object, search for Landsat Collection 2 Level 2 data within the bounding box `bbox_of_interest` during the time period `time_of_interest`. Filter the results to include only items with a cloud cover less than 10%. Define variables named `search` and `items` to store the search results and the collection of items, respectively. Print the number of items returned using the `print` function and the `len` function.", "exec_path": "PlanetaryComputerExamples-main", "context": "import pystac_client\nimport planetary_computer\n#\ncatalog = pystac_client.Client.open(\n    'https://planetarycomputer.microsoft.com/api/stac/v1', modifier=planetary_computer.sign_inplace)\nbbox_of_interest = [-122.2751, 47.5469, -121.9613, 47.7458]\ntime_of_interest = '2021-01-01/2021-12-31'\n", "functions": ["catalog.search", "search.item_collection", "print", "len"], "external_vars": ["print", "catalog", "time_of_interest", "len", "bbox_of_interest"], "defined_vars": ["items", "search"], "parameters": ["items", "f'Returned {len(items)} Items'"], "libraries": ["import planetary_computer", "import pystac_client"]}
{"code": "\ntopo_raster = rasterio.open(file_path + 'raster21.tif')\n\n#\n", "task": "Using the `rasterio` library, open the raster file named \"raster21.tif\" located at the path specified by `file_path` and store the resulting raster object in a variable named `topo_raster`.", "exec_path": "gemgis_data-main", "context": "import rasterio\nfile_path = 'data/example21_coal_seam_mining/'\n", "functions": ["rasterio.open"], "external_vars": ["file_path", "rasterio"], "defined_vars": ["topo_raster"], "parameters": ["file_path + 'raster21.tif'"], "libraries": ["import rasterio"]}
{"code": "\nstats = geemap.image_stats(image, scale=30)\nstats\n\n#\n", "task": "Using the `geemap` library, calculate the image statistics for the `image` variable with a scale of 30. Store the results in a variable named `stats`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\ncentroid = ee.Geometry.Point([-122.4439, 37.7538])\nimage = ee.ImageCollection(\n    'LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()\n", "functions": ["geemap.image_stats"], "external_vars": ["image", "geemap"], "defined_vars": ["stats"], "parameters": ["image"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\ngeemap.bar_chart(\n    \"treeloss.csv\",\n    x=\"NAME\",\n    y=\"sum\",\n    max_rows=20,\n    x_label=\"County\",\n    y_label=\"Forest loss area (km2)\",\n)\n\n#\n\n\n", "task": "Using the geemap library, create a bar chart visualization from the \"treeloss.csv\" file. Set the x-axis to \"NAME\", the y-axis to \"sum\", limit the number of bars to 20, and label the axes as \"County\" and \"Forest loss area (km2)\".", "exec_path": "geemap-master", "context": "import geemap\n", "functions": ["geemap.bar_chart"], "external_vars": ["geemap"], "defined_vars": [], "parameters": ["treeloss.csv"], "libraries": ["import geemap"]}
{"code": "\nMap = geemap.Map()\n\n#\n", "task": "Using the geemap library, create a new map object and assign it to the variable `Map`.", "exec_path": "geemap-master", "context": "import geemap\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import geemap"]}
{"code": "\ngg.download_gemgis_data.download_tutorial_data(filename=\"11_removing_interfaces_within_fault_buffers.zip\", dirpath=file_path)\n\n#\n", "task": "Download the tutorial data for removing interfaces within fault buffers from the GEMGIS website and store it in the specified directory. **Make sure to define the following variables before running:**  [gg, file_path]", "exec_path": "gemgis-main", "context": "import gemgis as gg\nfile_path = 'data/11_removing_interfaces_within_fault_buffers/'\n", "functions": ["gg.download_gemgis_data.download_tutorial_data"], "external_vars": ["file_path", "gg"], "defined_vars": [], "parameters": [], "libraries": ["import gemgis as gg"]}
{"code": "\ndf = geemap.ee_to_df(features)\ndf\n\n#\n", "task": "Using the `geemap` library, convert the Earth Engine feature collection `features` into a Pandas DataFrame and assign it to the variable `df`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nimport geemap.chart as chart\nfeatures = ee.FeatureCollection(\n    'projects/google/charts_feature_example').select('[0-9][0-9]_ppt|label')\n", "functions": ["geemap.ee_to_df"], "external_vars": ["features", "geemap"], "defined_vars": ["df"], "parameters": ["features"], "libraries": ["import ee", "import geemap.chart as chart", "import geemap"]}
{"code": "\nhbox3 = widgets.HBox([speed, download])\nhbox3\n\n#\n", "task": "Define a horizontal box layout named `hbox3` using the `widgets.HBox` function. The box should contain two elements: the `speed` widget and the `download` widget.", "exec_path": "geemap-master", "context": "import ipywidgets as widgets\nstyle = {'description_width': 'initial'}\nspeed = widgets.IntSlider(description='Frames per second:',\n                          tooltip='Frames per second:', value=10, min=1, max=30, style=style)\ndownload = widgets.Checkbox(\n    value=False, description='Download the GIF', style=style)\n", "functions": ["widgets.HBox"], "external_vars": ["download", "widgets", "speed"], "defined_vars": ["hbox3"], "parameters": ["[speed, download]"], "libraries": ["import ipywidgets as widgets"]}
{"code": "\nstyle = {\"description_width\": \"initial\"}\ntitle = widgets.Text(\n    description=\"Title:\", value=\"Landsat Timelapse\", width=200, style=style\n)\n\nbands = widgets.Dropdown(\n    description=\"Select RGB Combo:\",\n    options=[\n        \"Red/Green/Blue\",\n        \"NIR/Red/Green\",\n        \"SWIR2/SWIR1/NIR\",\n        \"NIR/SWIR1/Red\",\n        \"SWIR2/NIR/Red\",\n        \"SWIR2/SWIR1/Red\",\n        \"SWIR1/NIR/Blue\",\n        \"NIR/SWIR1/Blue\",\n        \"SWIR2/NIR/Green\",\n        \"SWIR1/NIR/Red\",\n    ],\n    value=\"NIR/Red/Green\",\n    style=style,\n)\n\nhbox1 = widgets.HBox([title, bands])\nhbox1\n\n#\n", "task": "Using the `widgets` library, create a horizontal box layout (HBox) containing a Text widget for the title and a Dropdown widget for band selection. Define the following variables: `title`, `bands`, `hbox1`, and `style`. Set the style description width to \"initial\". The title should be \"Landsat Timelapse\" and the band selection options are [\"Red/Green/Blue\", \"NIR/Red/Green\", \"SWIR2/SWIR1/NIR\", \"NIR/SWIR1/Red\", \"SWIR2/NIR/Red\", \"SWIR2/SWIR1/Red\", \"SWIR1/NIR/Blue\", \"NIR/SWIR1/Blue\", \"SWIR2/NIR/Green\", \"SWIR1/NIR/Red\"] with \"NIR/Red/Green\" as the default value.", "exec_path": "geemap-master", "context": "import ipywidgets as widgets\n", "functions": ["widgets.Text", "widgets.Dropdown", "widgets.HBox"], "external_vars": ["widgets"], "defined_vars": ["bands", "style", "hbox1", "title"], "parameters": ["[title, bands]"], "libraries": ["import ipywidgets as widgets"]}
{"code": "\nwidgets.ColorPicker(\n    concise=False, description=\"Pick a color\", value=\"blue\", disabled=False\n)\n\n#\n", "task": "Create a color picker using the `widgets` library.  The picker should be non-concise, have the description \"Pick a color\", a default value of \"blue\", and be enabled.  **You must define the following variables:** `widgets`", "exec_path": "geemap-master", "context": "import ipywidgets as widgets\n", "functions": ["widgets.ColorPicker"], "external_vars": ["widgets"], "defined_vars": [], "parameters": [], "libraries": ["import ipywidgets as widgets"]}
{"code": "\n# Now, let's see how many images do we have in the list now!\nlen(S2selected)\n", "task": "Calculate the length of the list S2selected. You will need to define the following variables: [S2selected].", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\nimport geemap.colormaps as cm\npoi = ee.Geometry.PointFromQuery(\n    'Oporto, Portugal', user_agent='eemont-tutorial-024')\nS2 = ee.ImageCollection('COPERNICUS/S2_SR').filterBounds(poi).filterDate(\n    '2020-01-01', '2020-07-01').preprocess().spectralIndices()\n# If you want to select images from a collection, convert the collection to a list and use container emulation methods!\nS2list = S2.toList(S2.size())\nS2selected = S2list[20:-5]\n", "functions": ["len"], "external_vars": ["S2selected", "len"], "defined_vars": [], "parameters": ["S2selected"], "libraries": ["import eemont", "import geemap.colormaps as cm", "import ee", "import geemap"]}
{"code": "\nwidget = geemap.show_html(html)\nwidget\n\n#\n", "task": "Using the geemap library, display the HTML content stored in the `html` variable within a widget. Assign the resulting widget to the variable `widget`.", "exec_path": "geemap-master", "context": "import geemap\nhtml = geemap.create_legend(title='NLCD Land Cover Type',\n                            builtin_legend='NLCD', draggable=False, position='bottomright')\n", "functions": ["geemap.show_html"], "external_vars": ["html", "geemap"], "defined_vars": ["widget"], "parameters": ["html"], "libraries": ["import geemap"]}
{"code": "\n# Check how many items were returned\nitems = search.item_collection()\nprint(f\"Returned {len(items)} Items\")\n\n#\n", "task": "Use the `search` object to retrieve a collection of items.  Store this collection in a variable called `items`. Then, print a message that indicates the number of items returned using the `len` function and the `print` function.", "exec_path": "PlanetaryComputerExamples-main", "context": "import pystac_client\nimport planetary_computer\n#\ncatalog = pystac_client.Client.open(\n    'https://planetarycomputer.microsoft.com/api/stac/v1', modifier=planetary_computer.sign_inplace)\narea_of_interest = {'type': 'Polygon', 'coordinates': [[[-124.134521484375, 49.00724918431423], [-121.75872802734375, 49.00724918431423], [\n    -121.75872802734375, 50.07300647938297], [-124.134521484375, 50.07300647938297], [-124.134521484375, 49.00724918431423]]]}\nsearch = catalog.search(\n    collections=['nrcan-landcover'], intersects=area_of_interest)\n", "functions": ["search.item_collection", "print", "len"], "external_vars": ["search", "len", "print"], "defined_vars": ["items"], "parameters": ["items", "f'Returned {len(items)} Items'"], "libraries": ["import planetary_computer", "import pystac_client"]}
{"code": "\ngeemap.ee_export_vector_to_drive(\n    fc, description=\"TN\", fileFormat=\"SHP\", folder=\"export\"\n)\n\n#\n", "task": "Export the feature collection `fc` to your Google Drive as a shapefile (SHP) within the folder \"export\", using the `geemap.ee_export_vector_to_drive()` function. Set the description to \"TN\". You need to define the variables `fc` and `geemap`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nstates = ee.FeatureCollection('TIGER/2018/States')\nfc = states.filter(ee.Filter.eq('NAME', 'Tennessee'))\n", "functions": ["geemap.ee_export_vector_to_drive"], "external_vars": ["geemap", "fc"], "defined_vars": [], "parameters": ["fc"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\np = pv.Plotter(notebook=True)\np.add_mesh(mesh=mesh, cmap='gist_earth', scalar_bar_args=sargs, texture=texture)\n\np.set_background('white')\np.show_grid(color='black')\np.set_scale(1,1,10)\np.show()\n", "task": "Using the provided variables `pv`, `mesh`, `sargs`, and `texture`, create a 3D plot using the `Plotter` class from the `pv` library. Set the background to white, display a black grid, and scale the plot by a factor of 10 along the z-axis. Apply the `gist_earth` colormap to the mesh and display a scalar bar using the `sargs` dictionary.  Define a variable `p` to store the Plotter object.", "exec_path": "gemgis-main", "context": "import gemgis as gg\nimport pyvista as pv\nimport rasterio\nfile_path = 'data/14_visualizing_topography_and_maps_with_pyvista/'\ndem = rasterio.open(file_path + 'DEM50.tif')\nsargs = dict(fmt='%.0f', color='black')\nwms_map = gg.web.load_as_array('https://ows.terrestris.de/osm/service?', 'OSM-WMS', 'default',\n                               'EPSG:4647', [32320000, 32500000, 5690000, 5800000], [2800, 2000], 'image/png')\nwms_stacked = gg.visualization.convert_to_rgb(array=wms_map)\nmesh, texture = gg.visualization.drape_array_over_dem(\n    array=wms_stacked, dem=dem)\n", "functions": ["pv.Plotter", "p.add_mesh", "p.set_background", "p.show_grid", "p.set_scale", "p.show"], "external_vars": ["texture", "pv", "sargs", "mesh"], "defined_vars": ["p"], "parameters": ["white", 1, 1, 10], "libraries": ["import gemgis as gg", "import rasterio", "import pyvista as pv"]}
{"code": "\nurl = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2016_Land_Cover_L48/wms?\"\nMap.add_wms_layer(\n    url,\n    layers=\"NLCD_2016_Land_Cover_L48\",\n    name=\"NLCD 2016 CONUS Land Cover\",\n    format=\"image/png\",\n    transparent=True,\n)\nMap.add_legend(builtin_legend=\"NLCD\")\n\nMap\n\n#\n", "task": "Add a WMS layer to the map object `Map` from the provided URL `url`. The layer should be named \"NLCD 2016 CONUS Land Cover\" and display the NLCD 2016 Land Cover data. Set the format to \"image/png\" and enable transparency. Also, add a built-in legend for the NLCD data.", "exec_path": "leafmap-master", "context": "import leafmap\nMap = leafmap.Map()\n", "functions": ["Map.add_wms_layer", "Map.add_legend"], "external_vars": ["Map"], "defined_vars": ["url"], "parameters": ["url"], "libraries": ["import leafmap"]}
{"code": "\nin_shp = \"countries.shp\"\nfc = geemap.shp_to_ee(in_shp)\n\n#\n", "task": "Using the `geemap` library, convert the shapefile located at the path specified by the variable `in_shp` into an Earth Engine FeatureCollection and store it in the variable `fc`.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nfrom geemap.datasets import get_metadata\n", "functions": ["geemap.shp_to_ee"], "external_vars": ["geemap"], "defined_vars": ["fc", "in_shp"], "parameters": ["in_shp"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata"]}
{"code": "\ngeemap.ee_export_vector_to_drive(\n    fc, description=\"Alaska\", fileFormat=\"SHP\", folder=\"export\"\n)\n\n#\n", "task": "Using the geemap library and the feature collection `fc`, export the vector data to Google Drive as a shapefile named \"Alaska\" in a folder named \"export\". You will need to define the following variables before running this code: `geemap` and `fc`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nstates = ee.FeatureCollection('TIGER/2018/States')\nfc = states.filter(ee.Filter.eq('NAME', 'Alaska'))\n", "functions": ["geemap.ee_export_vector_to_drive"], "external_vars": ["geemap", "fc"], "defined_vars": [], "parameters": ["fc"], "libraries": ["import ee", "import geemap"]}
{"code": "\ntraining = image.sample(\n    **{\n        \"region\": region,\n        \"scale\": 150,\n        \"numPixels\": 5000,\n        \"seed\": 1,\n        \"geometries\": True,\n    }\n)\nm.add_layer(training, {}, \"Training samples\")\n\n#\n", "task": "Sample training data from the `image` object within the specified `region` using a scale of 150, 5000 pixels, and a seed of 1. Include geometric information in the samples. Store the resulting training data in a variable called `training`. Then, add this `training` data as a layer to the map object `m`, labeling it \"Training samples\".", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nimport ee\nee.Initialize()\nfrom geemap.datasets import get_metadata\nm = geemap.Map()\ngeometry = ee.Geometry.Point([-86.893044, 41.718642])\npoint = ee.Geometry.Point(-99.2222, 46.7816)\ndata = 'GOES-17'\nstart_date = '2020-09-05T15:00:00'\nend_date = '2020-09-06T02:00:00'\nregion = ee.Geometry.BBox(-149.352, 64.5532, -147.0976, 65.1277)\ncollection = geemap.landsat_timeseries(\n    region, start_year=2021, end_year=2021, start_date='06-01', end_date='09-01')\nimage = collection.first()\n", "functions": ["image.sample", "m.add_layer"], "external_vars": ["image", "m", "region"], "defined_vars": ["training"], "parameters": ["training", "Training samples", "{}"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import get_metadata"]}
{"code": "\nm = leafmap.Map(center=(40, -100), zoom=3, basemap=\"stamen-terrain\", height=500)\nm\n\n#\n", "task": "Using the `leafmap` library, create a map object named `m` centered at coordinates (40, -100) with a zoom level of 3. Use the \"stamen-terrain\" basemap and set the map height to 500 pixels.", "exec_path": "leafmap-master", "context": "import leafmap.plotlymap as leafmap\n", "functions": ["leafmap.Map"], "external_vars": ["leafmap"], "defined_vars": ["m"], "parameters": [], "libraries": ["import leafmap.plotlymap as leafmap"]}
{"code": "\n# Add NLCD data\ndataset = ee.Image(\"USGS/NLCD_RELEASES/2021_REL/NLCD/2021\")\nlandcover = dataset.select(\"landcover\")\nm.add_layer(landcover, {}, \"NLCD 2021\")\n#\n", "task": "Using the Earth Engine library (ee) and a map object (m), load the 2021 National Land Cover Database (NLCD) dataset and add it as a layer to the map. Define variables named `dataset` and `landcover` to store the loaded dataset and selected landcover band, respectively.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nm = geemap.Map(center=[40, -100], zoom=4)\ncentroid = ee.Geometry.Point([-122.4439, 37.7538])\nimage = ee.ImageCollection(\n    'LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()\n", "functions": ["ee.Image", "dataset.select", "m.add_layer"], "external_vars": ["ee", "m"], "defined_vars": ["landcover", "dataset"], "parameters": ["USGS/NLCD_RELEASES/2021_REL/NLCD/2021", "landcover", "landcover", "NLCD 2021", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nurl = \"https://github.com/opengeos/leafmap/raw/master/examples/data/us_cities.csv\"\nleafmap.csv_to_df(url).head()\n\n#\n", "task": "Using the `leafmap` library, read the CSV file located at the URL specified by the `url` variable and display the first five rows of the resulting DataFrame.", "exec_path": "leafmap-master", "context": "import leafmap\n", "functions": ["unknown_function.head", "leafmap.csv_to_df"], "external_vars": ["leafmap"], "defined_vars": ["url"], "parameters": ["url"], "libraries": ["import leafmap"]}
{"code": "\n# ## Using the inspector tool\n#\n# In[ ]:\n\n#\n# Create an interactive map\nMap = geemap.Map(center=(40, -100), zoom=4)\n#\n", "task": "Using the geemap library, create a map object named \"Map\" centered at coordinates (40, -100) with a zoom level of 4.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nmesh, texture = gg.visualization.drape_array_over_dem(array=wms_stacked,\n                                                      dem=dem)\n\n#\n", "task": "Using the gg library, drape the array wms_stacked over the digital elevation model (DEM) represented by the variable dem. Store the resulting mesh and texture in the variables mesh and texture respectively.", "exec_path": "gemgis-main", "context": "import gemgis as gg\nimport rasterio\nfile_path = 'data/14_visualizing_topography_and_maps_with_pyvista/'\nmesh = gg.visualization.read_raster(\n    path=file_path + 'DEM50.tif', nodata_val=9999.0, name='Elevation [m]')\ndem = rasterio.open(file_path + 'DEM50.tif')\nwms_map = gg.web.load_as_array('https://ows.terrestris.de/osm/service?', 'OSM-WMS', 'default',\n                               'EPSG:4647', [32320000, 32500000, 5690000, 5800000], [2800, 2000], 'image/png')\nwms_stacked = gg.visualization.convert_to_rgb(array=wms_map)\n", "functions": ["gg.visualization.drape_array_over_dem"], "external_vars": ["dem", "wms_stacked", "gg"], "defined_vars": ["texture", "mesh"], "parameters": [], "libraries": ["import gemgis as gg", "import rasterio"]}
{"code": "\nm = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm.add_colormap(position=(55, 5), **params)\nm\n\n#\n", "task": "Using the `leafmap` library, create a map object named `m`. Add the \"OpenTopoMap\" basemap to it. Then, add a colormap to the map using the `add_colormap` method, placing it at position (55, 5). Use the `params` dictionary for the colormap parameters.", "exec_path": "leafmap-master", "context": "import leafmap.foliumap as leafmap\n#\nparams = {'width': 4.0, 'height': 0.3, 'vmin': 0, 'vmax': 6000, 'cmap': 'terrain',\n          'label': 'Elevation (m)', 'orientation': 'horizontal', 'transparent': False}\n", "functions": ["leafmap.Map", "m.add_basemap", "m.add_colormap"], "external_vars": ["leafmap", "params"], "defined_vars": ["m"], "parameters": ["OpenTopoMap"], "libraries": ["import leafmap.foliumap as leafmap"]}
{"code": "\nm = geemap.Map()\nurl = \"https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif\"\nm.add_cog_layer(url, name=\"Fire (pre-event)\")\nm\n\n#\n", "task": "Using the geemap library, create a new map object named \"m\". Define a variable \"url\" with the provided URL, and add a COG layer to the map using the \"url\" and name it \"Fire (pre-event)\".", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nfrom geemap.datasets import get_metadata\ndata = 'https://github.com/gee-community/geemap/blob/master/examples/data/us_cities.csv'\n", "functions": ["geemap.Map", "m.add_cog_layer"], "external_vars": ["geemap"], "defined_vars": ["url", "m"], "parameters": ["url"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata"]}
{"code": "\nraster_clipped = gg.raster.clip_by_bbox(raster=raster, \n                                        bbox=bbox)\n\n#\n", "task": "Clip the raster object `raster` by the bounding box defined in `bbox` using the `gg.raster.clip_by_bbox` function.  Store the resulting clipped raster object in a variable named `raster_clipped`.", "exec_path": "gemgis-main", "context": "import gemgis as gg\nimport rasterio\nfile_path = 'data/04_clipping_data/'\nraster = rasterio.open(file_path + 'raster.tif')\nbbox = [250, 750, 250, 750]\n", "functions": ["gg.raster.clip_by_bbox"], "external_vars": ["raster", "bbox", "gg"], "defined_vars": ["raster_clipped"], "parameters": [], "libraries": ["import gemgis as gg", "import rasterio"]}
{"code": "\nfig, ax = plt.subplots(figsize=(12, 4), dpi=100)\nds.sel(time=slice(\"2010\", \"2019\"))[\"tmin\"].mean(dim=[\"x\", \"y\"]).plot(ax=ax);\n\n#\n", "task": "Using the libraries `plt`, `ds`, and `slice`, create a plot of the average minimum temperature (`tmin`) from 2010 to 2019. Set the figure size to (12, 4) and the DPI to 100. The plot should be created on an axis named `ax`, which will be part of a figure named `fig`.", "exec_path": "PlanetaryComputerExamples-main", "context": "import fsspec\nimport matplotlib.pyplot as plt\nimport pystac\nimport xarray as xr\n#\nurl = 'https://planetarycomputer.microsoft.com/api/stac/v1/collections/daymet-daily-hi'\ncollection = pystac.read_file(url)\nasset = collection.assets['zarr-https']\nstore = fsspec.get_mapper(asset.href)\nds = xr.open_zarr(store, **asset.extra_fields['xarray:open_kwargs'])\nfig = plt.figure(figsize=(10, 6), dpi=100)\n", "functions": ["plt.subplots", "unknown_function.plot", "unknown_function.mean", "ds.sel", "slice"], "external_vars": ["ds", "plt", "slice"], "defined_vars": ["ax", "fig"], "parameters": ["2010", "2019"], "libraries": ["import fsspec", "import matplotlib.pyplot as plt", "import pystac", "import xarray as xr"]}
{"code": "\nimg = mpimg.imread('data/images/example30/orientations_example30.png')\nplt.figure(figsize=(10, 10))\nimgplot = plt.imshow(img)\nplt.axis('off')\nplt.tight_layout()\n\n#\n", "task": "Using the libraries **mpimg** and **plt**, read the image located at \"data/images/example30/orientations_example30.png\" and assign it to the variable **img**.  Then, display the image in a figure with size (10, 10) and turn off the axis. Define variables **imgplot** and **img** in your code. Use **plt.tight_layout()** to adjust the layout.", "exec_path": "gemgis-main", "context": "import matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n", "functions": ["mpimg.imread", "plt.figure", "plt.imshow", "plt.axis", "plt.tight_layout"], "external_vars": ["plt", "mpimg"], "defined_vars": ["img", "imgplot"], "parameters": ["data/images/example30/orientations_example30.png", "img", "off"], "libraries": ["import matplotlib.image as mpimg", "import matplotlib.pyplot as plt"]}
{"code": "\nMap = geemap.Map()\nMap\n\n#\n", "task": "Using the geemap library, create a new map object and assign it to the variable \"Map\".", "exec_path": "geemap-master", "context": "import geemap\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import geemap"]}
{"code": "\nprint(best_image.get(\"system:band_names\").getInfo())\n\n#\n", "task": "Print the band names associated with the best image. Make sure `best_image` is a dictionary containing a key `system:band_names` which holds a reference to an object with an `getInfo` method.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nroi = ee.Geometry.Point([-114.762293, 36.06462])\nimages = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(\n    roi).filterDate('2015-01-01', '2019-12-31').sort('CLOUD_COVER')\n# best_image = images.toList(images.size()).get(0)\nbest_image = images.first().select(['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7'])\n", "functions": ["print", "unknown_function.getInfo", "best_image.get"], "external_vars": ["best_image", "print"], "defined_vars": [], "parameters": ["system:band_names", "best_image.get('system:band_names').getInfo()"], "libraries": ["import ee", "import geemap"]}
{"code": "\ntimelapse = geemap.landsat_timelapse(\n    roi,\n    out_gif=\"las_vegas.gif\",\n    start_year=1984,\n    end_year=2023,\n    bands=[\"NIR\", \"Red\", \"Green\"],\n    frames_per_second=5,\n    title=\"Las Vegas, NV\",\n    font_color=\"blue\",\n)\ngeemap.show_image(timelapse)\n\n#\n", "task": "Using the `geemap` library, create a timelapse animation of Landsat imagery over the region defined by the `roi` variable. Set the output GIF filename to `las_vegas.gif`, start year to 1984, end year to 2023, use the NIR, Red, and Green bands, set the frame rate to 5 frames per second, and add a title \"Las Vegas, NV\" with blue font.  Define a variable named `timelapse` to store the resulting timelapse object and then display the timelapse using `geemap.show_image(timelapse)`.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nimport ee\nee.Initialize()\nfrom geemap.datasets import get_metadata\ngeometry = ee.Geometry.Point([-86.893044, 41.718642])\ndata = 'https://github.com/gee-community/geemap/blob/master/examples/data/us_cities.csv'\npoint = ee.Geometry.Point(-99.2222, 46.7816)\nroi = ee.Geometry.BBox(-115.5541, 35.8044, -113.9035, 36.5581)\n", "functions": ["geemap.landsat_timelapse", "geemap.show_image"], "external_vars": ["geemap", "roi"], "defined_vars": ["timelapse"], "parameters": ["roi", "timelapse"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import get_metadata"]}
{"code": "\ndf = geemap.ee_to_df(fc)\ndf\n\n#\n", "task": "Convert the Earth Engine feature collection `fc` to a Pandas DataFrame and store it in the variable `df` using the `geemap.ee_to_df` function.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\nfc = ee.FeatureCollection(\n    'USDOS/LSIB_SIMPLE/2017').filter(ee.Filter.eq('wld_rgn', 'Europe'))\n", "functions": ["geemap.ee_to_df"], "external_vars": ["geemap", "fc"], "defined_vars": ["df"], "parameters": ["fc"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "import geemap", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nMap = geemap.Map()\n\nfirst_image = ee.Image(images.toList(images.size()).get(0))\nlandsat_vis = {\"bands\": [\"NIR\", \"Red\", \"Green\"], \"min\": 0, \"max\": 3500}\nMap.addLayer(first_image, landsat_vis, \"First image\")\n\nfirst_water_image = ee.Image(water_images.toList(water_images.size()).get(0)).selfMask()\nMap.addLayer(first_water_image, {\"palette\": \"blue\"}, \"First NDWI\")\n\nMap\n\n#\n", "task": "Using the geemap library, create a map object named `Map`. Define a variable named `first_image` by selecting the first image from the `images` list using the `ee.Image` function. Create a dictionary named `landsat_vis` with bands \"NIR\", \"Red\", and \"Green\" and set min and max values to 0 and 3500 respectively. Add `first_image` to the map using the `addLayer` function with the `landsat_vis` dictionary and the label \"First image\". Define a variable named `first_water_image` by selecting the first image from the `water_images` list using the `ee.Image` function and apply a self mask to it. Finally, add `first_water_image` to the map with a blue palette and the label \"First NDWI\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nimage = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_039035_20150724')\nndwi_threshold = 0\nstart_date = '2015-01-01'\nend_date = '2019-12-31'\n\n\ndef extract_water(img):\n    ndwi_image = img.normalizedDifference(['B3', 'B5'])\n    water_image = ndwi_image.gt(ndwi_threshold)\n    return water_image\n\n\nstate_name = 'Nevada'\nroi = ee.FeatureCollection(\n    'TIGER/2018/States').filter(ee.Filter.eq('NAME', state_name))\nimages = geemap.landsat_timeseries(\n    roi=roi, start_year=1984, end_year=2019, start_date='06-01', end_date='09-30')\n\n\ndef extract_water(img):\n    ndwi_image = img.normalizedDifference(['Green', 'NIR'])\n    water_image = ndwi_image.gt(ndwi_threshold)\n    return water_image\n\n\nwater_images = images.map(extract_water)\n", "functions": ["geemap.Map", "ee.Image", "unknown_function.get", "images.toList", "images.size", "Map.addLayer", "unknown_function.selfMask", "ee.Image", "unknown_function.get", "water_images.toList", "water_images.size", "Map.addLayer"], "external_vars": ["ee", "images", "geemap", "water_images"], "defined_vars": ["first_water_image", "Map", "first_image", "landsat_vis"], "parameters": [0, "first_image", "landsat_vis", "First image", 0, "first_water_image", "First NDWI", "images.toList(images.size()).get(0)", "images.size()", "water_images.toList(water_images.size()).get(0)", "water_images.size()", "{'palette': 'blue'}"], "libraries": ["import ee", "import geemap"]}
{"code": "\nm = leafmap.Map()\nbefore = (\n    \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\n)\nafter = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\"\nm.split_map(before, after, left_label=\"Before\", right_label=\"After\")\nm\n\n#\n", "task": "Using the `leafmap` library, create a map object called `m`. Define two variables `before` and `after` with the provided URLs. Use the `split_map` function of the `m` object to create a side-by-side comparison of the images at the given URLs. Label the left side as \"Before\" and the right side as \"After\".", "exec_path": "leafmap-master", "context": "import leafmap\n", "functions": ["leafmap.Map", "m.split_map"], "external_vars": ["leafmap"], "defined_vars": ["m", "after", "before"], "parameters": ["before", "after"], "libraries": ["import leafmap"]}
{"code": "\nlandsat_url = (\n    \"https://drive.google.com/file/d/1EV38RjNxdwEozjc9m0FcO3LFgAoAX1Uw/view?usp=sharing\"\n)\nleafmap.download_file(landsat_url, \"landsat.tif\", unzip=False)\n\n#\n", "task": "Using the `leafmap` library, download the Landsat image from the provided URL `landsat_url` and save it as \"landsat.tif\". Do not unzip the file.", "exec_path": "leafmap-master", "context": "import leafmap\nimport leafmap.colormaps as cm\nimport leafmap.foliumap as leafmap\n", "functions": ["leafmap.download_file"], "external_vars": ["leafmap"], "defined_vars": ["landsat_url"], "parameters": ["landsat_url", "landsat.tif"], "libraries": ["import leafmap.foliumap as leafmap", "import leafmap.colormaps as cm", "import leafmap"]}
{"code": "\ndef get_utm(point):\n    longitude, latitude = point.x, point.y\n    buffer = 0.001\n    utm_crs_list = query_utm_crs_info(\n        datum_name=\"WGS 84\",\n        area_of_interest=AreaOfInterest(\n            west_lon_degree=longitude - buffer,\n            south_lat_degree=latitude - buffer,\n            east_lon_degree=longitude + buffer,\n            north_lat_degree=latitude + buffer,\n        ),\n    )\n    utm_crs = CRS.from_epsg(utm_crs_list[0].code)\n    return utm_crs\n\n#\n", "task": "Define a function named `get_utm` that takes a `point` object as input. The `point` object has `x` and `y` attributes representing longitude and latitude, respectively. You need to define variables `buffer`, `latitude`, `longitude`, `utm_crs_list`, `utm_crs`.  Use the provided functions `query_utm_crs_info` and `AreaOfInterest` to determine the UTM CRS for the given point. Finally, return the `utm_crs` object. Make sure to import the `CRS` class from the relevant library.", "exec_path": "PlanetaryComputerExamples-main", "context": "", "functions": ["query_utm_crs_info", "AreaOfInterest", "CRS.from_epsg"], "external_vars": ["query_utm_crs_info", "CRS", "AreaOfInterest"], "defined_vars": ["buffer", "latitude", "utm_crs_list", "utm_crs", "longitude", "point"], "parameters": ["utm_crs_list[0].code"], "libraries": []}
{"code": "\nMap = geemap.Map()\nfc = ee.FeatureCollection(\"USDOS/LSIB_SIMPLE/2017\").filter(\n    ee.Filter.eq(\"wld_rgn\", \"Europe\")\n)\n\nMap.addLayer(fc, {}, \"Europe\")\nMap.centerObject(fc, 3)\nMap\n\n#\n", "task": "Using the geemap and ee libraries, create a map object named \"Map\" and define a feature collection named \"fc\" representing the \"Europe\" region from the \"USDOS/LSIB_SIMPLE/2017\" dataset. Then, add the feature collection to the map and center the map on it with a zoom level of 3.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\n", "functions": ["geemap.Map", "unknown_function.filter", "ee.FeatureCollection", "ee.Filter.eq", "Map.addLayer", "Map.centerObject"], "external_vars": ["ee", "geemap"], "defined_vars": ["Map", "fc"], "parameters": ["USDOS/LSIB_SIMPLE/2017", "wld_rgn", "Europe", "fc", "Europe", "fc", 3, "ee.Filter.eq('wld_rgn', 'Europe')", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "import geemap", "import ee", "from geemap.datasets import DATA"]}
{"code": "\ndf = pd.DataFrame(\n    {\n        \"City\": [\"Buenos Aires\", \"Brasilia\", \"Santiago\", \"Bogota\", \"Caracas\"],\n        \"Country\": [\"Argentina\", \"Brazil\", \"Chile\", \"Colombia\", \"Venezuela\"],\n        \"Coordinates\": [\n            \"POINT(-58.66 -34.58)\",\n            \"POINT(-47.91 -15.78)\",\n            \"POINT(-70.66 -33.45)\",\n            \"POINT(-74.08 4.60)\",\n            \"POINT(-66.86 10.48)\",\n        ],\n    }\n)\n\n#\n", "task": "Using the pandas library (pd), create a DataFrame called \"df\" with the following data:\\n\\nCity | Country | Coordinates\\n------- | -------- | --------\\nBuenos Aires | Argentina | POINT(-58.66 -34.58)\\nBrasilia | Brazil | POINT(-47.91 -15.78)\\nSantiago | Chile | POINT(-70.66 -33.45)\\nBogota | Colombia | POINT(-74.08 4.60)\\nCaracas | Venezuela | POINT(-66.86 10.48)", "exec_path": "geopandas-main", "context": "import pandas as pd\n", "functions": ["pd.DataFrame"], "external_vars": ["pd"], "defined_vars": ["df"], "parameters": ["{'City': ['Buenos Aires', 'Brasilia', 'Santiago', 'Bogota', 'Caracas'], 'Country': ['Argentina', 'Brazil', 'Chile', 'Colombia', 'Venezuela'], 'Coordinates': ['POINT(-58.66 -34.58)', 'POINT(-47.91 -15.78)', 'POINT(-70.66 -33.45)', 'POINT(-74.08 4.60)', 'POINT(-66.86 10.48)']}"], "libraries": ["import pandas as pd"]}
{"code": "\nm = geemap.Map(center=[41.718934, -86.894547], zoom=11)\nm.add_gui(\"timelapse\")\nm\n\n#\n", "task": "Using the geemap library, create a map centered at coordinates [41.718934, -86.894547] with a zoom level of 11. Define the map as variable \"m\" and add a timelapse GUI to it.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nfrom geemap.datasets import get_metadata\ndata = 'https://github.com/gee-community/geemap/blob/master/examples/data/us_cities.csv'\n", "functions": ["geemap.Map", "m.add_gui"], "external_vars": ["geemap"], "defined_vars": ["m"], "parameters": ["timelapse"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata"]}
{"code": "\nm = leafmap.Map(center=[40, -100], zoom=4)\nm\n\n#\n", "task": "Using the `leafmap` library, create a map object named `m` centered at coordinates [40, -100] with a zoom level of 4.", "exec_path": "leafmap-master", "context": "import leafmap\n", "functions": ["leafmap.Map"], "external_vars": ["leafmap"], "defined_vars": ["m"], "parameters": [], "libraries": ["import leafmap"]}
{"code": "\n# And visualize the components.\nMap.addLayer(modis, {\"min\": [-1000, -1000, -100], \"max\": [9000, 2000, 800], \"bands\": [\"TCB\", \"TCG\", \"TCW\"]}, \"MODIS TC\")\n#\n", "task": "Add a layer to the map named \"MODIS TC\" using the `modis` variable. Set the minimum and maximum values for the three bands (TCB, TCG, TCW) to [-1000, -1000, -100] and [9000, 2000, 800] respectively. Make sure the `Map` and `modis` variables are defined.", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\n# Authenticate and Initialize Earth Engine and geemap.\nMap = geemap.Map()\n# Load an image from the MODIS NBAR collection and add tasseled cap components.\nmodis = ee.Image('MODIS/006/MCD43A4/2020_05_01').tasseledCap()\n", "functions": ["Map.addLayer"], "external_vars": ["modis", "Map"], "defined_vars": [], "parameters": ["modis", "MODIS TC", "{'min': [-1000, -1000, -100], 'max': [9000, 2000, 800], 'bands': ['TCB', 'TCG', 'TCW']}"], "libraries": ["import eemont", "import ee", "import geemap"]}
{"code": "\nMap.addLayerControl()\nMap\n", "task": "Add a layer control to the map. Make sure you have defined the variable `Map` beforehand.", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.foliumap as emap\nimport geemap as emap\nMap = geemap.Map(center=[40, -100], zoom=4)\n", "functions": ["Map.addLayerControl"], "external_vars": ["Map"], "defined_vars": [], "parameters": [], "libraries": ["import geemap.foliumap as emap", "import geemap as emap", "import geemap"]}
{"code": "\nMap = leafmap.Map(center=[40, -100], zoom=4, add_google_map=False, layers_control=True)\n\n#\n", "task": "Using the `leafmap` library, create a new map object named `Map` centered at coordinates [40, -100] with a zoom level of 4. Disable the Google Maps basemap and enable the layers control.", "exec_path": "leafmap-master", "context": "import leafmap\n", "functions": ["leafmap.Map"], "external_vars": ["leafmap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import leafmap"]}
{"code": "\nimg = mpimg.imread('data/images/example31/interfaces_example31.png')\nplt.figure(figsize=(10, 10))\nimgplot = plt.imshow(img)\nplt.axis('off')\nplt.tight_layout()\n\n#\n", "task": "Using the libraries \"plt\" and \"mpimg\", read the image \"data/images/example31/interfaces_example31.png\" and store it in a variable called \"img\". Then, display the image using \"plt.imshow\" and store the resulting image plot in a variable called \"imgplot\". Ensure the axes are turned off and the layout is adjusted for a figure size of (10, 10).", "exec_path": "gemgis_data-main", "context": "import matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n", "functions": ["mpimg.imread", "plt.figure", "plt.imshow", "plt.axis", "plt.tight_layout"], "external_vars": ["plt", "mpimg"], "defined_vars": ["img", "imgplot"], "parameters": ["data/images/example31/interfaces_example31.png", "img", "off"], "libraries": ["import matplotlib.image as mpimg", "import matplotlib.pyplot as plt"]}
{"code": "\nm = leafmap.Map(center=[40, -100], zoom=4)\nm.add_basemap(\"HYBRID\")\nm.add_basemap(\"NLCD 2019 CONUS Land Cover\")\nm.add_legend(builtin_legend=\"NLCD\", title=\"NLCD Land Cover Type\")\nm\n\n#\n", "task": "Using the `leafmap` library, create a map centered at latitude 40 and longitude -100 with a zoom level of 4. Add a hybrid basemap and a basemap displaying \"NLCD 2019 CONUS Land Cover\". Finally, add a legend for the NLCD land cover data with the title \"NLCD Land Cover Type\". Define a variable `m` to store the map object.", "exec_path": "leafmap-master", "context": "import leafmap\n", "functions": ["leafmap.Map", "m.add_basemap", "m.add_basemap", "m.add_legend"], "external_vars": ["leafmap"], "defined_vars": ["m"], "parameters": ["HYBRID", "NLCD 2019 CONUS Land Cover"], "libraries": ["import leafmap"]}
{"code": "\nm = geemap.Map(center=[40, -100], zoom=4)\ndem = ee.Image(\"USGS/3DEP/10m\")\nvis = {\"min\": 0, \"max\": 4000, \"palette\": \"terrain\"}\nm.add_layer(dem, vis, \"DEM\")\nm\n\n#\n", "task": "Using the `geemap` and `ee` libraries, create a map centered at [40, -100] with a zoom level of 4. Define a variable `dem` as an `ee.Image` object representing the USGS 3DEP 10m elevation data. Create a visualization dictionary `vis` with minimum and maximum values of 0 and 4000, respectively, and a terrain palette. Add the `dem` layer to the map using the `vis` dictionary and label it \"DEM\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\ncentroid = ee.Geometry.Point([-122.4439, 37.7538])\nimage = ee.ImageCollection(\n    'LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()\n", "functions": ["geemap.Map", "ee.Image", "m.add_layer"], "external_vars": ["ee", "geemap"], "defined_vars": ["m", "dem", "vis"], "parameters": ["USGS/3DEP/10m", "dem", "vis", "DEM"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nstyle = {\"color\": \"#ffff0088\", \"fillColor\": \"#00000000\"}\nMap.addLayer(countries.style(**style), {}, \"Countries\")\n\n#\n", "task": "Add a layer to the map named \"Countries\" using the \"countries\" GeoJSON data, styled with the provided \"style\" object.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nMap = geemap.Map()\ncountries = ee.FeatureCollection(geemap.examples.get_ee_path('countries'))\n", "functions": ["Map.addLayer", "countries.style"], "external_vars": ["Map", "countries"], "defined_vars": ["style"], "parameters": ["Countries", "countries.style(**style)", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "\ngeemap.ee_export_image(image, filename=\"landsat.tif\", scale=30, region=region)\n\n#\n", "task": "Export the image `image` as a GeoTIFF file named \"landsat.tif\" with a scale of 30 meters and a region specified by the variable `region` using the `geemap` library.  Make sure the variables `region` and `image` are defined before executing this instruction.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nimage = ee.Image(\n    'LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318').select(['B5', 'B4', 'B3'])\nregion = ee.Geometry.BBox(-122.5955, 37.5339, -122.0982, 37.8252)\n", "functions": ["geemap.ee_export_image"], "external_vars": ["image", "geemap", "region"], "defined_vars": [], "parameters": ["image"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nMap = geemap.Map()\nMap.add_basemap(\"HYBRID\")\nlandcover = ee.Image(\"USGS/NLCD/NLCD2016\").select(\"landcover\")\nMap.addLayer(landcover, {}, \"NLCD Land Cover\")\nMap.add_legend(builtin_legend=\"NLCD\")\nMap\n\n#\n", "task": "Using the `ee` and `geemap` libraries, create a map object named `Map` and add a HYBRID basemap. Then, load the NLCD 2016 land cover data into an `ee.Image` object named `landcover`, selecting the 'landcover' band. Add the `landcover` to the map with the label \"NLCD Land Cover\". Finally, add a built-in legend for the NLCD land cover data.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap import geojson_to_ee, ee_to_geojson\n", "functions": ["geemap.Map", "Map.add_basemap", "unknown_function.select", "ee.Image", "Map.addLayer", "Map.add_legend"], "external_vars": ["ee", "geemap"], "defined_vars": ["Map", "landcover"], "parameters": ["HYBRID", "landcover", "USGS/NLCD/NLCD2016", "landcover", "NLCD Land Cover", "{}"], "libraries": ["from geemap import geojson_to_ee, ee_to_geojson", "import ee", "import geemap"]}
{"code": "\ndef addDate(image):\n    img_date = ee.Date(image.date())\n    img_date = ee.Number.parse(img_date.format(\"YYYYMMdd\"))\n    return image.addBands(ee.Image(img_date).rename(\"date\").toInt())\n\n#\n", "task": "Using the Earth Engine library (ee), write a function called `addDate` that takes an image (`image`) as input and adds a band named \"date\" containing the date of the image in YYYYMMdd format. Ensure that the variables `image` and `img_date` are defined before calling the function. ", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Date", "image.date", "ee.Number.parse", "img_date.format", "image.addBands", "unknown_function.toInt", "unknown_function.rename", "ee.Image"], "external_vars": ["ee"], "defined_vars": ["image", "img_date"], "parameters": ["YYYYMMdd", "date", "img_date", "image.date()", "img_date.format('YYYYMMdd')", "ee.Image(img_date).rename('date').toInt()"], "libraries": ["import ee", "import geemap"]}
{"code": "\ncollection = catalog.get_collection(\"daymet-daily-na\")\nprint(collection)\n\n#\n", "task": "Use the `catalog` object to get the collection named \"daymet-daily-na\" and store it in a variable called `collection`. Then, print the contents of the `collection` variable using the `print` function.", "exec_path": "PlanetaryComputerExamples-main", "context": "import pystac_client\nimport planetary_computer\ncatalog = pystac_client.Client.open(\n    'https://planetarycomputer.microsoft.com/api/stac/v1', modifier=planetary_computer.sign_inplace)\n", "functions": ["catalog.get_collection", "print"], "external_vars": ["catalog", "print"], "defined_vars": ["collection"], "parameters": ["daymet-daily-na", "collection"], "libraries": ["import planetary_computer", "import pystac_client"]}
{"code": "\nm = geemap.Map()\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nfc = states.filter(ee.Filter.eq(\"NAME\", \"Louisiana\"))\nm.add_layer(fc, {}, \"Louisiana\")\nm.center_object(fc, 7)\nm\n\n#\n", "task": "Using the geemap and ee libraries, create a map object (m) and add a layer representing the state of Louisiana. Define the following variables: states, m, fc. Use the TIGER/2018/States dataset and filter for the state with the name \"Louisiana\". Center the map on the state with a zoom level of 7.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map", "ee.FeatureCollection", "states.filter", "ee.Filter.eq", "m.add_layer", "m.center_object"], "external_vars": ["ee", "geemap"], "defined_vars": ["m", "fc", "states"], "parameters": ["TIGER/2018/States", "NAME", "Louisiana", "fc", "Louisiana", "fc", 7, "ee.Filter.eq('NAME', 'Louisiana')", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\ndataset.aggregate_array(\"system:index\")\n\n#\n", "task": "Aggregate the array of system indexes in the dataset. The following variables need to be defined: [dataset]", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\ndataset = ee.ImageCollection('JRC/GSW1_4/MonthlyHistory')\n", "functions": ["dataset.aggregate_array"], "external_vars": ["dataset"], "defined_vars": [], "parameters": ["system:index"], "libraries": ["from geemap.datasets import get_metadata", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\n# use cartoee to get a map\nax = cartoee.get_map(image, vis_params=vis, basemap=\"SATELLITE\", zoom_level=8)\n#\n", "task": "Using the `cartoee` library, create a map visualization of the `image` data. Set the `vis_params` to `vis`, the basemap to `SATELLITE`, and the zoom level to 8. Define a variable `ax` to store the resulting map object.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap import cartoee\nimport cartopy.io.img_tiles as cimgt\n# get a landsat image to visualize\nimage = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')\n# define the visualization parameters to view\nvis = {'bands': ['B5', 'B4', 'B3'], 'min': 0, 'max': 5000, 'gamma': 1.3}\nbasemap = cimgt.OSM()\n", "functions": ["cartoee.get_map"], "external_vars": ["cartoee", "vis", "image"], "defined_vars": ["ax"], "parameters": ["image"], "libraries": ["from geemap import cartoee", "import ee", "import cartopy.io.img_tiles as cimgt", "import geemap"]}
{"code": "\nMap = geemap.Map()\nMap\n\n#\n", "task": "Using the geemap library, create a new Map object and assign it to the variable \"Map\".", "exec_path": "geemap-master", "context": "import geemap\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import geemap"]}
{"code": "\nroi = m.user_roi\n\nif roi is None:\n    roi = ee.Geometry.BBox(-112.8089, 33.7306, -88.5951, 46.6244)\n    m.add_layer(roi, {}, \"ROI\")\n\nm.center_object(roi)\n\n#\n", "task": "Using the `m` and `ee` objects, define a variable `roi` that represents the user's selected region of interest (ROI). If the `roi` variable is empty (None), set it to a bounding box defined by the coordinates (-112.8089, 33.7306, -88.5951, 46.6244) and add this box as a layer to the map `m` with the label \"ROI\". Finally, center the map `m` on this `roi`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nm = geemap.Map()\n", "functions": ["ee.Geometry.BBox", "m.add_layer", "m.center_object"], "external_vars": ["m", "ee"], "defined_vars": ["roi"], "parameters": [33.7306, 46.6244, "roi", "ROI", "roi", "-112.8089", "-88.5951", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nMap = geemap.Map()\nMap.addLayer(L9['NDWI'],{\"min\":0,\"max\":1,\"palette\":cm.palettes.ndwi},\"NDWI\")\nMap.centerObject(poi.centroid(1),11)\nMap\n\n\n", "task": "Using the geemap library, create a map object called \"Map\". Add a layer to the map called \"NDWI\" using the NDWI band from the L9 variable. Set the minimum value to 0, maximum value to 1, and use the ndwi palette from the cm library. Then, center the map on the centroid of the poi object, zoomed to a level of 11.", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\nimport geemap.colormaps as cm\npoi = ee.Geometry.BBoxFromQuery(\n    'Salvajina, Colombia', user_agent='eemont-tutorial-035')\nL9 = ee.ImageCollection('LANDSAT/LC09/C02/T1_L2').filterBounds(poi).filterDate(\n    '2021-10-01', '2022-04-01').preprocess().spectralIndices(['NIRv', 'NDWI']).median()\n", "functions": ["geemap.Map", "Map.addLayer", "Map.centerObject", "poi.centroid"], "external_vars": ["L9", "poi", "cm", "geemap"], "defined_vars": ["Map"], "parameters": ["NDWI", 11, 1, "L9['NDWI']", "{'min': 0, 'max': 1, 'palette': cm.palettes.ndwi}", "poi.centroid(1)"], "libraries": ["import eemont", "import geemap.colormaps as cm", "import ee", "import geemap"]}
{"code": "\nNLCD_layer_names = [\"NLCD \" + str(year) for year in range(2001, 2017, 5)]\nprint(NLCD_layer_names)\n\n#\n", "task": "Define a variable called `NLCD_layer_names` and assign it a list of strings. The strings should be formatted as \"NLCD \" followed by the year, where the years range from 2001 to 2016 in increments of 5. Use the `range`, `str`, and `print` functions to create the list and print it to the console.", "exec_path": "geemap-master", "context": "", "functions": ["str", "range", "print"], "external_vars": ["print", "range", "str"], "defined_vars": ["year", "NLCD_layer_names"], "parameters": ["year", 2001, 2017, 5, "NLCD_layer_names"], "libraries": []}
{"code": "\nclient = dask.distributed.Client(processes=False)\nprint(f\"/proxy/{client.scheduler_info()['services']['dashboard']}/status\")\n\n#\n", "task": "Using the `dask` library, create a client object called `client` without starting separate processes. Then, print the URL to access the dask dashboard.", "exec_path": "PlanetaryComputerExamples-main", "context": "import dask.distributed\n", "functions": ["dask.distributed.Client", "print", "client.scheduler_info"], "external_vars": ["dask", "print"], "defined_vars": ["client"], "parameters": ["f'/proxy/{client.scheduler_info()['services']['dashboard']}/status'"], "libraries": ["import dask.distributed"]}
{"code": "\nprint(best_image.get(\"system:time_start\").getInfo())\n\n#\n", "task": "Print the value of the \"system:time_start\" field within the \"best_image\" variable.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nroi = ee.Geometry.Point([-114.762293, 36.06462])\nimages = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(\n    roi).filterDate('2015-01-01', '2019-12-31').sort('CLOUD_COVER')\n# best_image = images.toList(images.size()).get(0)\nbest_image = images.first().select(['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7'])\n", "functions": ["print", "unknown_function.getInfo", "best_image.get"], "external_vars": ["best_image", "print"], "defined_vars": [], "parameters": ["system:time_start", "best_image.get('system:time_start').getInfo()"], "libraries": ["import ee", "import geemap"]}
{"code": "\nareas = states.aggregate_array(\"ALAND\").getInfo()\nprint(areas)\n\n#\n", "task": "Use the `states` variable to calculate the total land area of each state in the dataset and store the results in a variable called `areas`. Then, print the `areas` variable.", "exec_path": "geemap-master", "context": "import geemap\nimport ee\nee.Initialize()\nstates = ee.FeatureCollection('TIGER/2018/States').sort('ALAND', False)\n", "functions": ["unknown_function.getInfo", "states.aggregate_array", "print"], "external_vars": ["print", "states"], "defined_vars": ["areas"], "parameters": ["ALAND", "areas"], "libraries": ["import ee", "import geemap"]}
{"code": "\n# Add 5-year Landsat TOA composite\nlandsat = ee.Image(\"LANDSAT/LE7_TOA_5YEAR/1999_2003\")\nlandsat_vis = {\"bands\": [\"B4\", \"B3\", \"B2\"], \"gamma\": 1.4}\nm.add_layer(landsat, landsat_vis, \"Landsat\", False)\n#\n", "task": "Using the Earth Engine library (ee), load the Landsat 7 TOA 5-year composite for 1999-2003 and assign it to the variable \"landsat\". Define a visualization dictionary \"landsat_vis\" to display bands B4, B3, and B2 with a gamma correction of 1.4. Then, add this Landsat image to the map (m) with the name \"Landsat\" and set it to be initially hidden.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nm = geemap.Map(center=[40, -100], zoom=4)\ncentroid = ee.Geometry.Point([-122.4439, 37.7538])\nimage = ee.ImageCollection(\n    'LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()\n", "functions": ["ee.Image", "m.add_layer"], "external_vars": ["ee", "m"], "defined_vars": ["landsat", "landsat_vis"], "parameters": ["LANDSAT/LE7_TOA_5YEAR/1999_2003", "landsat", "landsat_vis", "Landsat", false], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\n###############################################################################\n# Pixel Registration\n# ------------------\n#\n# Pixel registration locates the grid points in the middle of the grid segments\n# rather than in the corner of each grid node.\n#\n# First, let's take our 1000x1000 region and use the 100 unit spacing from the\n# first example and set the ``pixel_register`` parameter to ``True``. Without\n# pixel registration our grid should have dimensions of 11x11. With pixel\n# registration we expect the dimensions of the grid to be the dimensions of the\n# non-registered grid minus one, or equal to the number of segments between the\n# grid points in the non-registered grid (10x10).\n\nspacing = 100\npixel_easting, pixel_northing = vd.grid_coordinates(\n    region=region, spacing=spacing, pixel_register=True\n)\nprint(pixel_easting.shape, pixel_northing.shape)\n#\n", "task": "Using the `vd` module, calculate the grid coordinates for the `region` with a spacing of `spacing`. Set the `pixel_register` to True. Store the resulting easting and northing coordinates in `pixel_easting` and `pixel_northing` respectively. Then, print the shape of both `pixel_easting` and `pixel_northing` using the `print` function.", "exec_path": "verde-main", "context": "import verde as vd\nwest, east, south, north = (0, 1000, 0, 1000)\nregion = (west, east, south, north)\n", "functions": ["vd.grid_coordinates", "print"], "external_vars": ["vd", "print", "region"], "defined_vars": ["spacing", "pixel_easting", "pixel_northing"], "parameters": ["pixel_easting.shape", "pixel_northing.shape"], "libraries": ["import verde as vd"]}
{"code": "\n# plot the map over the region of interest\nax = cartoee.get_map(image, vis_params=vis, region=zoom_region)\n#\n", "task": "Using the `cartoee` library, create a map visualization using the `get_map` function.  Pass the `image` variable as the input, use `vis` as the `vis_params`, and set the map region to `zoom_region`.  Assign the resulting map object to a variable named `ax`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap import cartoee\n# get a landsat image to visualize\nimage = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')\n# define the visualization parameters to view\nvis = {'bands': ['B5', 'B4', 'B3'], 'min': 0, 'max': 5000, 'gamma': 1.3}\n# formatted a [E,S,W,N]\nzoom_region = [-121.8025, 37.3458, -122.6265, 37.9178]\n", "functions": ["cartoee.get_map"], "external_vars": ["cartoee", "vis", "image", "zoom_region"], "defined_vars": ["ax"], "parameters": ["image"], "libraries": ["from geemap import cartoee", "import ee", "import geemap"]}
{"code": "\n###############################################################################\n# We select 4 normalizers depending on a single parameter lambda and\n# plot their transformation behavior within the interval [-5, 5].\n#\n# For the shape parameter lambda, we create a list of 8 values ranging from\n# -1 to 2.5.\n\nlmbdas = [i * 0.5 for i in range(-2, 6)]\nnormalizers = [\n    gs.normalizer.BoxCox,\n    gs.normalizer.YeoJohnson,\n    gs.normalizer.Modulus,\n    gs.normalizer.Manly,\n]\n#\n", "task": "Define a list named `lmbdas` containing values from -1 to 2.5 with a step of 0.5. Also, define a list named `normalizers` containing the following normalizers from the `gs` library: `BoxCox`, `YeoJohnson`, `Modulus`, and `Manly`.", "exec_path": "GSTools", "context": "import gstools as gs\n", "functions": ["range"], "external_vars": ["range", "gs"], "defined_vars": ["i", "normalizers", "lmbdas"], "parameters": [6, "-2"], "libraries": ["import gstools as gs"]}
{"code": "\ntime_range = \"2020-12-01/2020-12-31\"\nbbox = [-122.2751, 47.5469, -121.9613, 47.7458]\n\nsearch = catalog.search(collections=[\"landsat-c2-l2\"], bbox=bbox, datetime=time_range)\nitems = search.get_all_items()\nlen(items)\n\n#\n", "task": "Using the provided `catalog` object, search for Landsat Collection 2 Level 2 data within the bounding box `bbox` and time range `time_range`. Store the results in the variable `search`. Then, retrieve all items from the search results and store them in the variable `items`. Finally, calculate the number of items using the `len` function and print the result.", "exec_path": "PlanetaryComputerExamples-main", "context": "import pystac_client\nimport planetary_computer\ncatalog = pystac_client.Client.open(\n    'https://planetarycomputer.microsoft.com/api/stac/v1', modifier=planetary_computer.sign_inplace)\n", "functions": ["catalog.search", "search.get_all_items", "len"], "external_vars": ["catalog", "len"], "defined_vars": ["time_range", "bbox", "search", "items"], "parameters": ["items"], "libraries": ["import planetary_computer", "import pystac_client"]}
{"code": "\nm = leafmap.Map()\nm.add_basemap_gui()\nm\n\n#\n", "task": "Using the `leafmap` library, create a map object named `m` and add a basemap GUI to it.", "exec_path": "leafmap-master", "context": "import leafmap\n", "functions": ["leafmap.Map", "m.add_basemap_gui"], "external_vars": ["leafmap"], "defined_vars": ["m"], "parameters": [], "libraries": ["import leafmap"]}
{"code": "\n# In[ ]:\n\n#\n# Get image\nlon = -115.1585\nlat = 36.1500\nstart_year = 1984\nend_year = 2011\n\npoint = ee.Geometry.Point(lon, lat)\nyears = ee.List.sequence(start_year, end_year)\n", "task": "Using the Earth Engine library (ee), define a point geometry based on the given longitude (lon) and latitude (lat). Then, create a list of years from the start_year to end_year using the ee.List.sequence function. Define the variables: point, lat, start_year, end_year, years, lon.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap import cartoee\n", "functions": ["ee.Geometry.Point", "ee.List.sequence"], "external_vars": ["ee"], "defined_vars": ["lon", "lat", "years", "end_year", "start_year", "point"], "parameters": ["lon", "lat", "start_year", "end_year"], "libraries": ["from geemap import cartoee", "import ee", "import geemap"]}
{"code": "\n# Load an image.\nimage = ee.Image(\"LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318\")\n#\n", "task": "Using the Earth Engine library (ee), define a variable called `image` that represents an image from the Landsat 8 collection with the ID `LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318`.", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.foliumap as emap\nimport geemap as emap\nimport ee\nee.Initialize()\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["image"], "parameters": ["LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318"], "libraries": ["import geemap.foliumap as emap", "import geemap as emap", "import ee", "import geemap"]}
{"code": "\n# Import hourly predicted temperature image collection for northern winter\n# solstice. Note that predictions extend for 384 hours; limit the collection\n# to the first 24 hours.\ntempCol = (\n    ee.ImageCollection(\"NOAA/GFS0P25\")\n    .filterDate(\"2018-12-22\", \"2018-12-23\")\n    .limit(24)\n    .select(\"temperature_2m_above_ground\")\n)\n#\n", "task": "Using the ee library, define a variable named `tempCol` that represents an Earth Engine ImageCollection. The collection should be filtered to include data from the `NOAA/GFS0P25` dataset between December 22nd and December 23rd, 2018. Limit the collection to 24 images and select the `temperature_2m_above_ground` band.", "exec_path": "geemap-master", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["unknown_function.select", "unknown_function.limit", "unknown_function.filterDate", "ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["tempCol"], "parameters": ["temperature_2m_above_ground", 24, "2018-12-22", "2018-12-23", "NOAA/GFS0P25"], "libraries": ["import ee", "import geemap"]}
{"code": "\n# Print the elevation of Mount Everest.\nxy = ee.Geometry.Point([86.9250, 27.9881])\nelev = image.sample(xy, 30).first().get(\"elevation\").getInfo()\nprint(\"Mount Everest elevation (m):\", elev)\n#\n", "task": "Using the Earth Engine library (`ee`) and an image object named `image`, sample the image at the location defined by the point `xy` (which needs to be defined). Use a sample radius of 30 meters. Extract the `elevation` property from the first sample and store it in the variable `elev` (which needs to be defined). Finally, use the `print` function to display the elevation value in meters.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\n# Add Earth Engine dataset\nimage = ee.Image('USGS/SRTMGL1_003')\n", "functions": ["ee.Geometry.Point", "unknown_function.getInfo", "unknown_function.get", "unknown_function.first", "image.sample", "print"], "external_vars": ["ee", "image", "print"], "defined_vars": ["elev", "xy"], "parameters": ["elevation", "xy", 30, "Mount Everest elevation (m):", "elev", "[86.925, 27.9881]"], "libraries": ["import ee", "import geemap"]}
{"code": "\ndef extract_water(img):\n    ndwi_image = img.normalizedDifference([\"Green\", \"NIR\"])\n    water_image = ndwi_image.gt(ndwi_threshold)\n    return water_image\n\n#\n", "task": "Define a function called `extract_water` that takes an image `img` as input. Calculate the Normalized Difference Water Index (NDWI) using the `normalizedDifference` method on `img` for the 'Green' and 'NIR' bands, storing the result in `ndwi_image`. Then, create a binary mask `water_image` by applying a threshold comparison using `gt` (greater than) on `ndwi_image` with the predefined `ndwi_threshold`. Finally, return `water_image`.", "exec_path": "geemap-master", "context": "ndwi_threshold = 0\n\n\ndef extract_water(img):\n    ndwi_image = img.normalizedDifference(['B3', 'B5'])\n    water_image = ndwi_image.gt(ndwi_threshold)\n    return water_image\n", "functions": ["img.normalizedDifference", "ndwi_image.gt"], "external_vars": ["ndwi_threshold"], "defined_vars": ["water_image", "img", "ndwi_image"], "parameters": ["ndwi_threshold", "['Green', 'NIR']"], "libraries": []}
{"code": "\nm.set_plot_options(add_marker_cluster=True, marker=None)\nm.roi_reducer = ee.Reducer.mean()\n\n#\n", "task": "Configure the map object `m` to enable marker clustering and set the reducer for the region of interest to the mean using the Earth Engine library `ee`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\n#\nMap = geemap.Map()\nm = geemap.Map()\n", "functions": ["m.set_plot_options", "ee.Reducer.mean"], "external_vars": ["m", "ee"], "defined_vars": [], "parameters": [], "libraries": ["import ee", "import geemap"]}
{"code": "\nwell = pv.Line((500,500, 800), (500, 500, 300))\nwell_tube = well.tube(radius=10)\nwell_tube\n\n#\n", "task": "Using the pv library, define a line object named \"well\" with coordinates (500, 500, 800) for the start point and (500, 500, 300) for the end point. Then, create a tube object named \"well_tube\" by applying the \"tube\" method to the \"well\" object with a radius of 10.", "exec_path": "gemgis-main", "context": "import pyvista as pv\n", "functions": ["pv.Line", "well.tube"], "external_vars": ["pv"], "defined_vars": ["well", "well_tube"], "parameters": ["(500, 500, 800)", "(500, 500, 300)"], "libraries": ["import pyvista as pv"]}
{"code": "\nout_csv = os.path.join(work_dir, \"landsat.csv\")\ngeemap.extract_values_to_points(in_fc, landsat7, out_csv)\n", "task": "Using the `os` module, create a variable called `out_csv` by joining the `work_dir` and `landsat.csv`. Then, using the `geemap` module, call the `extract_values_to_points` function with the following arguments: `in_fc`, `landsat7`, and `out_csv`.", "exec_path": "geemap-master", "context": "import os\nimport ee\nee.Initialize()\nimport geemap\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\nwork_dir = os.path.expanduser('~/Downloads')\nin_shp = os.path.join(work_dir, 'us_cities.shp')\nin_fc = geemap.shp_to_ee(in_shp)\n", "functions": ["os.path.join", "geemap.extract_values_to_points"], "external_vars": ["landsat7", "in_fc", "os", "geemap", "work_dir"], "defined_vars": ["out_csv"], "parameters": ["work_dir", "landsat.csv", "in_fc", "landsat7", "out_csv"], "libraries": ["import os", "import ee", "import geemap"]}
{"code": "\n# Add Earth Engine layers to the map\nMap.addLayer(dem, vis_params, \"SRTM DEM\")\nMap.addLayer(\n    landsat7,\n    {\"bands\": [\"B4\", \"B3\", \"B2\"], \"min\": 20, \"max\": 200, \"gamma\": 2.0},\n    \"Landsat 7\",\n)\nMap.addLayer(states, {}, \"US States\")\n#\n", "task": "Add the following layers to the map using the Map.addLayer() function:\\n\\n1. **SRTM DEM:** Add the `dem` layer with the visualization parameters specified in `vis_params`. Name the layer \"SRTM DEM\".\\n2. **Landsat 7:** Add the `landsat7` layer with the following visualization parameters: `{\"bands\": [\"B4\", \"B3\", \"B2\"], \"min\": 20, \"max\": 200, \"gamma\": 2.0}`. Name the layer \"Landsat 7\".\\n3. **US States:** Add the `states` layer with no visualization parameters. Name the layer \"US States\".\\n\\n**Required Variables:**\\n\\n* `vis_params`\\n* `landsat7`\\n* `states`\\n* `dem`\\n* `Map`", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\nstates = ee.FeatureCollection('TIGER/2018/States')\ndem = ee.Image('USGS/SRTMGL1_003')\nvis_params = {'min': 0, 'max': 4000, 'palette': [\n    '006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']}\nimage = ee.Image('LANDSAT/LC09/C02/T1_L2/LC09_044034_20220503')\n# Create an interactive map\nMap = geemap.Map(center=(40, -100), zoom=4)\n# Add Earth Engine datasets\nlandsat7 = ee.Image(\n    'LANDSAT/LE7_TOA_5YEAR/1999_2003').select(['B1', 'B2', 'B3', 'B4', 'B5', 'B7'])\n", "functions": ["Map.addLayer", "Map.addLayer", "Map.addLayer"], "external_vars": ["landsat7", "Map", "dem", "vis_params", "states"], "defined_vars": [], "parameters": ["dem", "vis_params", "SRTM DEM", "landsat7", "Landsat 7", "states", "US States", "{'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2.0}", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "import geemap", "import ee", "from geemap.datasets import DATA"]}
{"code": "\n###############################################################################\n# Like :func:`verde.cross_val_score`, :class:`~verde.SplineCV` can also run the\n# grid search in parallel using `Dask <https://dask.org/>`__ by specifying the\n# ``delayed`` attribute:\n\nspline = vd.SplineCV(dampings=dampings, delayed=True)\n#\n", "task": "Define a variable named `spline` using the `SplineCV` function from the `vd` module. Set the `dampings` parameter to the value of the `dampings` variable and set the `delayed` parameter to `True`.", "exec_path": "verde-main", "context": "import verde as vd\ndampings = [None, 0.0001, 0.001, 0.01]\n", "functions": ["vd.SplineCV"], "external_vars": ["dampings", "vd"], "defined_vars": ["spline"], "parameters": [], "libraries": ["import verde as vd"]}
{"code": "\nMap.on_interaction(handle_interaction)\n", "task": "Set up an event listener on the `Map` object that triggers the `handle_interaction` function whenever an interaction occurs.  You will need to define the `handle_interaction` function and the `Map` object.", "exec_path": "geemap-master", "context": "import geemap\nimport ee\nee.Initialize()\nimport ipywidgets as widgets\n#\nMap = geemap.Map(center=[37.71, 105.47], zoom=4)\noutput_widget = widgets.Output(layout={'border': '1px solid black'})\n\n\ndef handle_interaction(**kwargs):\n    latlon = kwargs.get('coordinates')\n    if kwargs.get('type') == 'click':\n        Map.default_style = {'cursor': 'wait'}\n        xy = ee.Geometry.Point(latlon[::-1])\n        selected_fc = fc.filterBounds(xy)\n        with output_widget:\n            output_widget.clear_output()\n            try:\n                admin1_id = selected_fc.first().get('ADM1_ZH').getInfo()\n                admin2_id = selected_fc.first().get('ADM2_ZH').getInfo()\n                Map.layers = Map.layers[:4]\n                geom = selected_fc.geometry()\n                layer_name = admin1_id + '-' + admin2_id\n                Map.addLayer(ee.Image().paint(geom, 0, 2), {\n                             'palette': 'red'}, layer_name)\n                print(layer_name)\n            except Exception as e:\n                print('No feature could be found')\n                Map.layers = Map.layers[:4]\n        Map.default_style = {'cursor': 'pointer'}\n", "functions": ["Map.on_interaction"], "external_vars": ["Map", "handle_interaction"], "defined_vars": [], "parameters": ["handle_interaction"], "libraries": ["import ipywidgets as widgets", "import ee", "import geemap"]}
{"code": "\nimg = mpimg.imread('data/images/example27/dem_example27.png')\nplt.figure(figsize=(10, 10))\nimgplot = plt.imshow(img)\nplt.axis('off')\nplt.tight_layout()\n\n#\n", "task": "Using the libraries `mpimg` and `plt`, read the image located at `'data/images/example27/dem_example27.png'` into a variable called `img`. Display the image using `plt.imshow` and store the result in a variable called `imgplot`. Turn off the axis using `plt.axis('off')` and adjust the layout using `plt.tight_layout()`.", "exec_path": "gemgis-main", "context": "import matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n", "functions": ["mpimg.imread", "plt.figure", "plt.imshow", "plt.axis", "plt.tight_layout"], "external_vars": ["plt", "mpimg"], "defined_vars": ["img", "imgplot"], "parameters": ["data/images/example27/dem_example27.png", "img", "off"], "libraries": ["import matplotlib.image as mpimg", "import matplotlib.pyplot as plt"]}
{"code": "\nMap = geemap.Map()\ncollection = ee.ImageCollection(\"COPERNICUS/S2_SR\")\nimage = collection.median()\n\nvis = {\n    \"min\": 0.0,\n    \"max\": 3000,\n    \"bands\": [\"B4\", \"B3\", \"B2\"],\n}\n\nMap.setCenter(83.277, 17.7009, 12)\nMap.addLayer(image, vis, \"Sentinel-2\")\nMap\n\n#\n", "task": "Using the ee and geemap libraries, create a map centered at 83.277, 17.7009 with a zoom level of 12.  Load the Sentinel-2 SR image collection and calculate the median image. Display the median image on the map using the specified visualization parameters. Define the following variables: `image`, `vis`, `collection`, and `Map`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\n", "functions": ["geemap.Map", "ee.ImageCollection", "collection.median", "Map.setCenter", "Map.addLayer"], "external_vars": ["ee", "geemap"], "defined_vars": ["collection", "image", "vis", "Map"], "parameters": ["COPERNICUS/S2_SR", 83.277, 17.7009, 12, "image", "vis", "Sentinel-2"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "import geemap", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nfig, ax = plt.subplots(1, figsize=(5,5))\n\ninterfaces.plot(ax=ax, column='formation', legend=True, aspect='equal')\n\nplt.grid()\nax.set_xlabel('X [m]')\nax.set_ylabel('Y [m]')\n\n#\n", "task": "Using the matplotlib library (`plt`) and the `interfaces` object, create a plot of the `formation` column from `interfaces`. The plot should have equal axes, a grid, and labels for the X and Y axes. Define the figure (`fig`) and axes (`ax`) for the plot.", "exec_path": "gemgis_data-main", "context": "import geopandas as gpd\nimport matplotlib.pyplot as plt\n#\nfile_path = 'data/example09_faulted_layers/'\ninterfaces = gpd.read_file(file_path + 'interfaces9.shp')\n", "functions": ["plt.subplots", "interfaces.plot", "plt.grid", "ax.set_xlabel", "ax.set_ylabel"], "external_vars": ["plt", "interfaces"], "defined_vars": ["fig", "ax"], "parameters": [1, "X [m]", "Y [m]"], "libraries": ["import geopandas as gpd", "import matplotlib.pyplot as plt"]}
{"code": "\nm = geemap.Map(center=(40, -100), zoom=4)\n\ndem = ee.Image(\"USGS/SRTMGL1_003\")\nlandsat7 = ee.Image(\"LANDSAT/LE7_TOA_5YEAR/1999_2003\").select(\n    [\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B7\"]\n)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\nvis_params = {\n    \"min\": 0,\n    \"max\": 4000,\n    \"palette\": [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"],\n}\n\nm.add_layer(dem, vis_params, \"SRTM DEM\")\nm.add_layer(\n    landsat7,\n    {\"bands\": [\"B4\", \"B3\", \"B2\"], \"min\": 20, \"max\": 200, \"gamma\": 2.0},\n    \"Landsat 7\",\n)\nm.add_layer(states, {}, \"US States\")\nm.add(\"inspector\")\nm\n\n#\n", "task": "Using the `ee` and `geemap` libraries, create an interactive map centered at (40, -100) with a zoom level of 4. Define variables `m`, `landsat7`, `states`, `vis_params`, and `dem` for a map, Landsat 7 image, US states, visualization parameters, and a SRTM DEM image, respectively. Then, add layers for the DEM image, Landsat 7 image, and US states, using the defined visualization parameters. Finally, add an inspector to the map.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n# Load an image.\nimage = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318')\n", "functions": ["geemap.Map", "ee.Image", "unknown_function.select", "ee.Image", "ee.FeatureCollection", "m.add_layer", "m.add_layer", "m.add_layer", "m.add"], "external_vars": ["ee", "geemap"], "defined_vars": ["m", "landsat7", "states", "dem", "vis_params"], "parameters": ["USGS/SRTMGL1_003", "LANDSAT/LE7_TOA_5YEAR/1999_2003", "TIGER/2018/States", "dem", "vis_params", "SRTM DEM", "landsat7", "Landsat 7", "states", "US States", "inspector", "['B1', 'B2', 'B3', 'B4', 'B5', 'B7']", "{'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2.0}", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\ninterfaces = gpd.read_file(file_path + 'interfaces27.shp')\ninterfaces.head()\n\n#\n", "task": "Using the `gpd` library, read the shapefile \"interfaces27.shp\" located at the path defined by the variable `file_path`. Store the resulting GeoDataFrame in a variable named `interfaces` and then display the first few rows of the dataframe.", "exec_path": "gemgis-main", "context": "import geopandas as gpd\nfile_path = 'data/example27/'\n", "functions": ["gpd.read_file", "interfaces.head"], "external_vars": ["file_path", "gpd"], "defined_vars": ["interfaces"], "parameters": ["file_path + 'interfaces27.shp'"], "libraries": ["import geopandas as gpd"]}
{"code": "\n# Mosaic the visualization layers and display (or export).\nmosaic = ee.ImageCollection([imageRGB, ndwiRGB]).mosaic()\nMap.addLayer(mosaic, {}, \"mosaic\")\n#\n", "task": "Create a mosaic image from the `imageRGB` and `ndwiRGB` images using the `ee.ImageCollection` and `mosaic` methods. Assign the resulting mosaic image to a variable named `mosaic`. Then, add the mosaic image to the map using the `Map.addLayer` method with an empty dictionary for visualization parameters and the label \"mosaic\".", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.foliumap as emap\nimport geemap as emap\nimport ee\nee.Initialize()\nMap = geemap.Map()\n# Load an image.\nimage = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')\n# Create an NDWI image, define visualization parameters and display.\nndwi = image.normalizedDifference(['B3', 'B5'])\n# Mask the non-watery parts of the image, where NDWI < 0.4.\nndwiMasked = ndwi.updateMask(ndwi.gte(0.4))\n# Create visualization layers.\nimageRGB = image.visualize(**{'bands': ['B5', 'B4', 'B3'], 'max': 0.5})\nndwiRGB = ndwiMasked.visualize(\n    **{'min': 0.5, 'max': 1, 'palette': ['00FFFF', '0000FF']})\n", "functions": ["unknown_function.mosaic", "ee.ImageCollection", "Map.addLayer"], "external_vars": ["ee", "ndwiRGB", "Map", "imageRGB"], "defined_vars": ["mosaic"], "parameters": ["mosaic", "mosaic", "[imageRGB, ndwiRGB]", "{}"], "libraries": ["import geemap.foliumap as emap", "import geemap as emap", "import ee", "import geemap"]}
{"code": "\n# Let's visualize our new points (color green):\nMap.addLayer(multiPointFromQuery,{'color':'green'},'MultiPoint Nominatim')\nMap.centerObject(multiPointFromQuery,5)\nMap\n", "task": "Add a layer to the map called \"MultiPoint Nominatim\" displaying the points in `multiPointFromQuery` with a green color and zoom the map to fit the extent of the points with a zoom level of 5.", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\n# Authenticate and Initialize Earth Engine and geemap.\nMap = geemap.Map()\n# Different properties are obtained using different geocoders.\nquery = 'Amazonas'\nmultiPointFromQuery = ee.Geometry.MultiPointFromQuery(\n    query, user_agent='eemont-tutorial-010')\n", "functions": ["Map.addLayer", "Map.centerObject"], "external_vars": ["multiPointFromQuery", "Map"], "defined_vars": [], "parameters": ["multiPointFromQuery", "MultiPoint Nominatim", "multiPointFromQuery", 5, "{'color': 'green'}"], "libraries": ["import eemont", "import ee", "import geemap"]}
{"code": "\nMap = geemap.Map()\ncollection = (\n    ee.ImageCollection(\"COPERNICUS/S2_SR\")\n    .filterDate(\"2021-01-01\", \"2022-01-01\")\n    .filter(ee.Filter.lt(\"CLOUDY_PIXEL_PERCENTAGE\", 5))\n)\nimage = collection.median()\n\nvis = {\n    \"min\": 0.0,\n    \"max\": 3000,\n    \"bands\": [\"B4\", \"B3\", \"B2\"],\n}\n\nMap.setCenter(83.277, 17.7009, 12)\nMap.addLayer(image, vis, \"Sentinel-2\")\nMap\n\n#\n", "task": "Using the ee and geemap libraries, create a map centered at coordinates (83.277, 17.7009) with a zoom level of 12. Load a Sentinel-2 image collection from the period 2021-01-01 to 2022-01-01, filtering for images with less than 5% cloud cover. Calculate the median image from the filtered collection and add it to the map with the specified visualization parameters. Define the following variables: image, vis, collection, and Map.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\n", "functions": ["geemap.Map", "unknown_function.filter", "unknown_function.filterDate", "ee.ImageCollection", "ee.Filter.lt", "collection.median", "Map.setCenter", "Map.addLayer"], "external_vars": ["ee", "geemap"], "defined_vars": ["collection", "image", "vis", "Map"], "parameters": ["2021-01-01", "2022-01-01", "COPERNICUS/S2_SR", "CLOUDY_PIXEL_PERCENTAGE", 5, 83.277, 17.7009, 12, "image", "vis", "Sentinel-2", "ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 5)"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "import geemap", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nMap = geemap.Map()\ncountries = ee.FeatureCollection(\"users/giswqs/public/countries\")\nMap.addLayer(countries, {}, \"Countries\")\nMap\n\n#\n", "task": "Using the `geemap` and `ee` libraries, define a variable called `Map` and assign it a new `geemap.Map` object.  Then, define a variable called `countries` and assign it an Earth Engine FeatureCollection of countries from the `users/giswqs/public/countries` collection. Finally, add the `countries` FeatureCollection to the `Map` object with the label \"Countries\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["geemap.Map", "ee.FeatureCollection", "Map.addLayer"], "external_vars": ["ee", "geemap"], "defined_vars": ["Map", "countries"], "parameters": ["users/giswqs/public/countries", "countries", "Countries", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "\n# Display the results.\nMap.setCenter(-122.054, 37.7295, 10)\nMap.addLayer(direction, {\"min\": -2, \"max\": 2}, \"direction\")\nMap.addLayer(gradient, {\"min\": -7, \"max\": 7}, \"gradient\")\n\nMap.addLayerControl()\nMap\n\n#\n\n\n", "task": "Using the provided `Map` object, center it at coordinates (-122.054, 37.7295) with a zoom level of 10. Add the `direction` layer with a color scale ranging from -2 to 2, and the `gradient` layer with a color scale ranging from -7 to 7. Finally, add a layer control to the map. Make sure the `direction` and `gradient` layers are defined externally.", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.foliumap as emap\nimport geemap as emap\nimport ee\nee.Initialize()\nMap = geemap.Map(center=[40, -100], zoom=4)\n# Load a Landsat 8 image and select the panchromatic band.\nimage = ee.Image('LANDSAT/LC08/C01/T1/LC08_044034_20140318').select('B8')\n# Compute the image gradient in the X and Y directions.\nxyGrad = image.gradient()\n# Compute the magnitude of the gradient.\ngradient = xyGrad.select('x').pow(2).add(xyGrad.select('y').pow(2)).sqrt()\n# Compute the direction of the gradient.\ndirection = xyGrad.select('y').atan2(xyGrad.select('x'))\n", "functions": ["Map.setCenter", "Map.addLayer", "Map.addLayer", "Map.addLayerControl"], "external_vars": ["direction", "gradient", "Map"], "defined_vars": [], "parameters": [37.7295, 10, "direction", "direction", "gradient", "gradient", "-122.054", "{'min': -2, 'max': 2}", "{'min': -7, 'max': 7}"], "libraries": ["import geemap.foliumap as emap", "import geemap as emap", "import ee", "import geemap"]}
{"code": "\nm = leafmap.Map()\n\n#\n", "task": "Using the `leafmap` library, create a new map object and assign it to the variable `m`.", "exec_path": "leafmap-master", "context": "import leafmap.foliumap as leafmap\n", "functions": ["leafmap.Map"], "external_vars": ["leafmap"], "defined_vars": ["m"], "parameters": [], "libraries": ["import leafmap.foliumap as leafmap"]}
{"code": "\n# condtions\ncond_pos = [0.3, 1.1, 1.9, 3.3, 4.7]\ncond_val = [0.47, 0.74, 0.56, 1.47, 1.74]\ncond_err = [0.01, 0.0, 0.1, 0.05, 0]\n# resulting grid\ngridx = np.linspace(0.0, 15.0, 151)\n# spatial random field class\nmodel = gs.Gaussian(dim=1, var=0.9, len_scale=1, nugget=0.1)\n#\n", "task": "Using the libraries `np` and `gs`, define the following variables: `cond_pos`, `cond_val`, `cond_err`, `gridx`, and `model`.", "exec_path": "GSTools", "context": "import gstools as gs\nimport numpy as np\n", "functions": ["np.linspace", "gs.Gaussian"], "external_vars": ["np", "gs"], "defined_vars": ["cond_val", "model", "cond_err", "gridx", "cond_pos"], "parameters": [0.0, 15.0, 151], "libraries": ["import numpy as np", "import gstools as gs"]}
{"code": "\n# ## Color palettes\n# To display a single band of an image in color, set the `parameter` with a color ramp represented by a list of CSS-style color strings. (See this [reference](http://en.wikipedia.org/wiki/Web_colors) for more information). The following example illustrates how to use colors from cyan (`00FFFF`) to blue (`0000FF`) to render a [Normalized Difference Water Index (NDWI)](http://www.tandfonline.com/doi/abs/10.1080/01431169608948714) image.\n# \n# In this example, note that the `min` and `max` parameters indicate the range of pixel values to which the palette should be applied. Intermediate values are linearly stretched. Also note that the `opt_show` parameter is set to `False`. This results in the visibility of the layer being off when it is added to the map. It can always be turned on again using the Layer Manager in the upper right corner of the map. The result should look something like below.\n#\n# In[ ]:\n\n#\n# Create a default map\nMap = geemap.Map()\n#\n", "task": "Using the geemap library, create a new map object and assign it to the variable \"Map\".", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.foliumap as emap\nimport geemap as emap\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import geemap.foliumap as emap", "import geemap as emap", "import geemap"]}
{"code": "\nMap = geemap.Map()\n\ncollection = (\n    ee.ImageCollection(\"MODIS/MCD43A4_006_NDVI\")\n    .filter(ee.Filter.date(\"2018-04-01\", \"2018-05-01\"))\n    .select(\"NDVI\")\n)\nvis_params = {\n    \"min\": 0.0,\n    \"max\": 1.0,\n    \"palette\": [\n        \"FFFFFF\",\n        \"CE7E45\",\n        \"DF923D\",\n        \"F1B555\",\n        \"FCD163\",\n        \"99B718\",\n        \"74A901\",\n        \"66A000\",\n        \"529400\",\n        \"3E8601\",\n        \"207401\",\n        \"056201\",\n        \"004C00\",\n        \"023B01\",\n        \"012E01\",\n        \"011D01\",\n        \"011301\",\n    ],\n}\n\nfirst_image = collection.first()\n\nMap.addLayer(first_image, vis_params, \"First image\", False)\nMap.setCenter(-7.03125, 31.0529339857, 2)\nMap\n\n#\n", "task": "Using the ee and geemap libraries, create a map object called \"Map\" and display the first image in the MODIS/MCD43A4_006_NDVI collection for the dates \"2018-04-01\" to \"2018-05-01\", selecting the NDVI band. Define variables \"vis_params\", \"collection\", and \"first_image\" to represent the visualization parameters, image collection, and first image respectively. Center the map at coordinates (-7.03125, 31.0529339857) with a zoom level of 2.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["geemap.Map", "unknown_function.select", "unknown_function.filter", "ee.ImageCollection", "ee.Filter.date", "collection.first", "Map.addLayer", "Map.setCenter"], "external_vars": ["ee", "geemap"], "defined_vars": ["collection", "Map", "vis_params", "first_image"], "parameters": ["NDVI", "MODIS/MCD43A4_006_NDVI", "2018-04-01", "2018-05-01", "first_image", "vis_params", "First image", false, 31.0529339857, 2, "ee.Filter.date('2018-04-01', '2018-05-01')", "-7.03125"], "libraries": ["import ee", "import geemap"]}
{"code": "\nMap = geemap.Map(center=[40, -100], zoom=4)\nMap.add_basemap(\"ROADMAP\")  # Add Google Map\nMap\n\n#\n", "task": "Using the geemap library, create a map centered at latitude 40 and longitude -100 with a zoom level of 4. Add a ROADMAP basemap to the map. Define a variable named `Map` to store the map object.", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.foliumap as emap\nimport geemap as emap\n", "functions": ["geemap.Map", "Map.add_basemap"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": ["ROADMAP"], "libraries": ["import geemap.foliumap as emap", "import geemap as emap", "import geemap"]}
{"code": "\nMap = geemap.Map(center=[40, -100], zoom=4)\n\nMap.setCenter(-110, 40, 5)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n#     .filter(ee.Filter.eq('STUSPS', 'TN'))\n# // Turn the strings into numbers\nstates = states.map(lambda f: f.set(\"STATEFP\", ee.Number.parse(f.get(\"STATEFP\"))))\n\nstate_image = ee.Image().float().paint(states, \"STATEFP\")\n\nvisParams = {\n    \"palette\": [\"purple\", \"blue\", \"green\", \"yellow\", \"orange\", \"red\"],\n    \"min\": 0,\n    \"max\": 50,\n    \"opacity\": 0.8,\n}\n\ncounties = ee.FeatureCollection(\"TIGER/2016/Counties\")\n# print(counties.first().propertyNames().getInfo())\n\nimage = ee.Image().paint(states, 0, 2)\n# Map.setCenter(-99.844, 37.649, 4)\n# Map.addLayer(image, {'palette': 'FF0000'}, 'TIGER/2018/States')\nMap.addLayer(state_image, visParams, \"TIGER/2016/States\")\nMap.addLayer(ee.Image().paint(counties, 0, 1), {}, \"TIGER/2016/Counties\")\n\nMap.addLayerControl()\nMap\n\n#\n", "task": "Using the geemap and ee libraries, create a map centered at coordinates (40, -100) with a zoom level of 4. Then, center the map at coordinates (-110, 40) with a zoom level of 5. Define a variable called \"states\" as an ee.FeatureCollection representing US states from the TIGER/2018/States dataset. Map over the \"states\" collection using lambda function \"f\", setting the 'STATEFP' property of each feature to an integer parsed from the existing 'STATEFP' property. Define a variable called \"state_image\" as an ee.Image with float type, painting the \"states\" collection with the 'STATEFP' property. Define a variable called \"visParams\" as a dictionary with a palette of colors, minimum and maximum values, and opacity for visualization. Define a variable called \"counties\" as an ee.FeatureCollection representing US counties from the TIGER/2016/Counties dataset. Define a variable called \"image\" as an ee.Image painting the \"states\" collection with a value of 0 and a width of 2. Add the \"state_image\" to the map with the \"visParams\" and label \"TIGER/2016/States\". Add a layer to the map representing the \"counties\" collection painted with a value of 0 and a width of 1, without any visualization parameters, and label \"TIGER/2016/Counties\". Finally, add a layer control to the map.", "exec_path": "geemap-master", "context": "import geemap\nimport ee\nee.Initialize()\ndataset = ee.FeatureCollection(\n    'TIGER/2010/Blocks').filter(ee.Filter.eq('statefp10', '47'))\nimage = ee.Image().float().paint(dataset, 'pop10')\n", "functions": ["geemap.Map", "Map.setCenter", "ee.FeatureCollection", "states.map", "f.set", "ee.Number.parse", "f.get", "unknown_function.paint", "unknown_function.float", "ee.Image", "ee.FeatureCollection", "unknown_function.paint", "ee.Image", "Map.addLayer", "Map.addLayer", "unknown_function.paint", "ee.Image", "Map.addLayerControl"], "external_vars": ["ee", "geemap", "f"], "defined_vars": ["image", "counties", "Map", "state_image", "states", "visParams"], "parameters": [40, 5, "TIGER/2018/States", "STATEFP", "STATEFP", "states", "STATEFP", "TIGER/2016/Counties", "states", 0, 2, "state_image", "visParams", "TIGER/2016/States", "TIGER/2016/Counties", "counties", 0, 1, "-110", "lambda f: f.set('STATEFP', ee.Number.parse(f.get('STATEFP')))", "ee.Number.parse(f.get('STATEFP'))", "f.get('STATEFP')", "ee.Image().paint(counties, 0, 1)", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "\n# Point of interest.\npoint = ee.Geometry.Point([-74.0592,11.3172])\n", "task": "Define a variable named `point` using the Earth Engine library (`ee`) to represent a point geometry with coordinates -74.0592 longitude and 11.3172 latitude.", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport datetime\nimport geemap\n", "functions": ["ee.Geometry.Point"], "external_vars": ["ee"], "defined_vars": ["point"], "parameters": ["[-74.0592, 11.3172]"], "libraries": ["import eemont", "import ee", "import datetime", "import geemap"]}
{"code": "\nroi = m.user_roi\nif roi is None:\n    roi = ee.Geometry.BBox(-99.1019, 47.1274, -99.0334, 47.1562)\n    m.add_layer(roi, {}, \"ROI\")\n    m.center_object(roi)\n\n#\n", "task": "Define a variable `roi` using the `m.user_roi` object. If `roi` is `None`, create a new `ee.Geometry.BBox` with the coordinates (-99.1019, 47.1274, -99.0334, 47.1562), add it as a layer to the map using `m.add_layer` with the label \"ROI\", and center the map on this geometry using `m.center_object`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nm = geemap.Map(center=[40, -100], zoom=4)\n", "functions": ["ee.Geometry.BBox", "m.add_layer", "m.center_object"], "external_vars": ["m", "ee"], "defined_vars": ["roi"], "parameters": [47.1274, 47.1562, "roi", "ROI", "roi", "-99.1019", "-99.0334", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nfig = plt.figure(figsize=(15, 10))\n\nprojection = ccrs.EqualEarth(central_longitude=-180)\n#\n", "task": "Using the libraries `plt` and `ccrs`, create a figure named `fig` with dimensions (15, 10) and an EqualEarth projection centered at -180 degrees longitude, storing the projection in a variable named `projection`.", "exec_path": "geemap-master", "context": "import matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\n", "functions": ["plt.figure", "ccrs.EqualEarth"], "external_vars": ["ccrs", "plt"], "defined_vars": ["projection", "fig"], "parameters": [], "libraries": ["import matplotlib.pyplot as plt", "import cartopy.crs as ccrs"]}
{"code": "\nWAPOR_ET.getCitation()\n", "task": "Retrieve the citation for the WAPOR_ET dataset.", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\nWAPOR_ET = ee.ImageCollection('FAO/WAPOR/2/L1_AETI_D')\n", "functions": ["WAPOR_ET.getCitation"], "external_vars": ["WAPOR_ET"], "defined_vars": [], "parameters": [], "libraries": ["import eemont", "import ee", "import geemap"]}
{"code": "\n# plot the result with cartoee using the Goode homolosine projection\nax = cartoee.get_map(\n    ocean, vis_params=visualization, region=bbox, cmap=\"plasma\", proj=projection\n)\ncb = cartoee.add_colorbar(\n    ax, vis_params=visualization, loc=\"bottom\", cmap=\"plasma\", orientation=\"horizontal\"\n)\n\nax.set_title(\"Robinson projection\")\n\nax.coastlines()\nplt.show()\n\n#\n", "task": "Using the `cartoee` library, create a map visualization of the `ocean` data.  Use the `visualization` parameters for the visualization. Set the region of the map to `bbox` and use the `plasma` colormap. Project the map using the `projection` provided. Define variables `ax` and `cb` to store the map axes and colorbar, respectively. Add a colorbar to the bottom of the map using `cartoee.add_colorbar` and set the colormap to `plasma` and orientation to `horizontal`. Set the title of the map to \"Robinson projection\". Display the map using `plt.show()`.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nimport matplotlib.pyplot as plt\nimport ee\nee.Initialize()\nimport cartopy.crs as ccrs\nregion = [-180, -60, 180, 85]\ncmap = 'gist_earth'\nvis_params = {'min': 0.0, 'max': 1.0, 'palette': ['FFFFFF', 'CE7E45', 'DF923D', 'F1B555', 'FCD163', '99B718',\n                                                  '74A901', '66A000', '529400', '3E8601', '207401', '056201', '004C00', '023B01', '012E01', '011D01', '011301']}\n# specify region to focus on\nbbox = [-180, -88, 180, 88]\n# get an earth engine image of ocean data for Jan-Mar 2018\nocean = ee.ImageCollection('NASA/OCEANDATA/MODIS-Terra/L3SMI').filter(\n    ee.Filter.date('2018-01-01', '2018-03-01')).median().select(['sst'], ['SST'])\n# will plot the Sea Surface Temp with specific range and colormap\nvisualization = {'bands': 'SST', 'min': -2, 'max': 30}\n# create a new Robinson projection centered on the Pacific\nprojection = ccrs.Robinson(central_longitude=-180)\n", "functions": ["cartoee.get_map", "cartoee.add_colorbar", "ax.set_title", "ax.coastlines", "plt.show"], "external_vars": ["projection", "ocean", "visualization", "cartoee", "plt", "bbox"], "defined_vars": ["ax", "cb"], "parameters": ["ocean", "ax", "Robinson projection"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "import matplotlib.pyplot as plt", "import ee", "import cartopy.crs as ccrs"]}
{"code": "\nregion = ee.Geometry.BBox(-112.5439, 34.0891, -85.0342, 49.6858)\nMap.addLayer(region, {}, \"ROI\")\nMap.centerObject(region)\n\n#\n", "task": "Using the Earth Engine library (ee) and the Map object, define a region variable as a bounding box with the provided coordinates. Add this region as a layer to the Map with the label \"ROI\" and center the Map on this region.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\n#\nMap = geemap.Map(center=[40, -100], zoom=4)\n", "functions": ["ee.Geometry.BBox", "Map.addLayer", "Map.centerObject"], "external_vars": ["ee", "Map"], "defined_vars": ["region"], "parameters": [34.0891, 49.6858, "region", "ROI", "region", "-112.5439", "-85.0342", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "\nregion = m.user_roi\nif region is None:\n    region = ee.Geometry.BBox(-88.40, 29.88, -77.90, 35.39)\n\nfc = ee.FeatureCollection(\"TIGER/2018/States\").filterBounds(region)\nm.add_layer(fc, {}, \"Southeastern U.S.\")\nm.center_object(fc, 6)\n\n#\n", "task": "Using the `ee` and `m` objects, define variables named `region` and `fc`.  If `region` is None, set it to a bounding box defined using `ee.Geometry.BBox()` with coordinates (-88.4, 29.88, -77.9, 35.39).  Then, set `fc` to a FeatureCollection of states from the `TIGER/2018/States` dataset filtered by the `region`. Add this feature collection to the map as a layer labeled \"Southeastern U.S.\" and center the map on the collection with a zoom level of 6.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nm = geemap.Map()\n", "functions": ["ee.Geometry.BBox", "unknown_function.filterBounds", "ee.FeatureCollection", "m.add_layer", "m.center_object"], "external_vars": ["m", "ee"], "defined_vars": ["fc", "region"], "parameters": [29.88, 35.39, "region", "TIGER/2018/States", "fc", "Southeastern U.S.", "fc", 6, "-88.4", "-77.9", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\n# Create a source image where the geometry is 1, everything else is 0.\nsources = ee.Image().toByte().paint(geometry, 1)\n#\n", "task": "Create an Earth Engine image called `sources` that represents a single pixel value of 1 within the specified `geometry`.  The image should be of byte data type.  The variables `ee` and `geometry` should be defined.", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.foliumap as emap\nimport geemap as emap\nimport ee\nee.Initialize()\n# A rectangle representing Bangui, Central African Republic.\ngeometry = ee.Geometry.Rectangle([18.5229, 4.3491, 18.5833, 4.4066])\n", "functions": ["unknown_function.paint", "unknown_function.toByte", "ee.Image"], "external_vars": ["ee", "geometry"], "defined_vars": ["sources"], "parameters": ["geometry", 1], "libraries": ["import geemap.foliumap as emap", "import geemap as emap", "import ee", "import geemap"]}
{"code": "\n###############################################################################\n# Rotation Angles\n# ---------------\n#\n# The main directions of the field don't have to coincide with the spatial\n# directions :math:`x`, :math:`y` and :math:`z`. Therefore you can provide\n# rotation angles for the model:\n\nmodel = gs.Gaussian(dim=3, var=2.0, len_scale=[10, 2], angles=2.5)\nmodel.plot(\"vario_spatial\")\nprint(\"Rotation angles\", model.angles)\n#\n\n\n", "task": "Using the external library `gs`, define a variable named `model` as a Gaussian model with 3 dimensions, variance of 2.0, length scale of [10, 2], and rotation angles of 2.5. Then, plot the spatial variogram of the model using the `plot` method. Finally, use the external function `print` to display the rotation angles of the model.", "exec_path": "GSTools", "context": "import gstools as gs\n", "functions": ["gs.Gaussian", "model.plot", "print"], "external_vars": ["print", "gs"], "defined_vars": ["model"], "parameters": ["vario_spatial", "Rotation angles", "model.angles"], "libraries": ["import gstools as gs"]}
{"code": "\ndef reproject_to_chip(\n    chip_info, input_path, output_path, resampling=Resampling.nearest\n):\n    \"\"\"\n    Reproject a raster at input_path to chip_info, saving to output_path.\n\n    Use Resampling.nearest for classification rasters. Otherwise use something\n    like Resampling.bilinear for continuous data.\n    \"\"\"\n    with rasterio.open(input_path) as src:\n        kwargs = src.meta.copy()\n        kwargs.update(\n            {\n                \"crs\": chip_info.crs,\n                \"transform\": chip_info.transform,\n                \"width\": chip_info.shape[1],\n                \"height\": chip_info.shape[0],\n                \"driver\": \"GTiff\",\n            }\n        )\n\n        with rasterio.open(output_path, \"w\", **kwargs) as dst:\n            for i in range(1, src.count + 1):\n                reproject(\n                    source=rasterio.band(src, i),\n                    destination=rasterio.band(dst, i),\n                    src_transform=src.transform,\n                    src_crs=src.crs,\n                    dst_transform=chip_info.transform,\n                    dst_crs=chip_info.crs,\n                    resampling=Resampling.nearest,\n                )\n\n#\n", "task": "Read a raster file from the specified input path using `rasterio` and store it in the `src` variable. Use the `range` variable to define the input data type and set the output data type to `float32`. Additionally, define the `chip_info` variable using `src.meta` with the specified `resampling` method. Then, define the `output_path` variable using the specified `input_path` and replace the file extension with the specified file format. Finally, define the `dst` variable by using the `reproject` function from `rasterio` to reproject the data from the `src` variable to the specified `chip_info` with the given `Resampling` method, `kwargs`, and `output_path`. ", "exec_path": "PlanetaryComputerExamples-main", "context": "import rasterio\nfrom rasterio.warp import reproject, Resampling\n", "functions": ["rasterio.open", "src.meta.copy", "kwargs.update", "rasterio.open", "range", "reproject", "rasterio.band", "rasterio.band"], "external_vars": ["Resampling", "range", "reproject", "rasterio"], "defined_vars": ["i", "kwargs", "chip_info", "resampling", "input_path", "src", "dst", "output_path"], "parameters": ["input_path", "output_path", "w", 1, "src", "i", "dst", "i", "{'crs': chip_info.crs, 'transform': chip_info.transform, 'width': chip_info.shape[1], 'height': chip_info.shape[0], 'driver': 'GTiff'}", "src.count + 1"], "libraries": ["import rasterio", "from rasterio.warp import reproject, Resampling"]}
{"code": "\n# ### Query for available data\n# \n# MODIS is a global dataset with a variety of products available within each larger category (vegetation, snow, fire, temperature, and reflectance). The [MODIS group](https://planetarycomputer.microsoft.com/dataset/group/modis) contains a complete listing of available collections. Each collection's format follows`modis-{product}-061`, where `product` is the MODIS product id. The `-061` suffix indicates that all of the MODIS collections are part of the [MODIS 6.1 update](https://atmosphere-imager.gsfc.nasa.gov/documentation/collection-61).\n# \n# Let's access Thermal Anomalies/Fire 8-Day 1km (14A2) data for the 2021 Dixie Wildfire in California. The wildfire extents included Butte, Plumas, Lassen, Shasta, and Tehama counties and burned approximately 936,309 acres. \n#\n# In[3]:\n\n#\n# 2021 Dixie Wildfire in California\nlatitude = 40.7310\nlongitude = -122.9420\nlocation = [longitude, latitude]\ngeometry = {\n    \"type\": \"Point\",\n    \"coordinates\": location,\n}\ndatetimes = [\n    \"2021-07-12\",\n    \"2021-07-20\",\n    \"2021-07-28\",\n    \"2021-08-05\",\n    \"2021-08-13\",\n    \"2021-08-21\",\n]\n\nbuffer = 0.7\nbbox = [longitude - buffer, latitude - buffer, longitude + buffer, latitude + buffer]\nitems = dict()\n#\n", "task": "Define the following variables: **location**, **buffer**, **latitude**, **geometry**, **items**, **datetimes**, **longitude**, **bbox**. Use a dictionary named **dict**.  Then assign the values shown in the provided code.", "exec_path": "PlanetaryComputerExamples-main", "context": "", "functions": ["dict"], "external_vars": ["dict"], "defined_vars": ["geometry", "buffer", "location", "latitude", "bbox", "longitude", "items", "datetimes"], "parameters": [], "libraries": []}
{"code": "\nMap = geemap.Map()\nMap\n\n#\n", "task": "Create a new map object named `Map` using the `geemap` library.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\n# %%\n# **Second option:** we can pass other ``crop_geom`` argument to :func:`~geoutils.Vector.crop`, including another :class:`~geoutils.Vector` or a\n# simple :class:`tuple` of bounds.\n\nbounds = rast.get_bounds_projected(out_crs=vect.crs)\nvect.crop(\n    crop_geom=(bounds.left + 0.5 * (bounds.right - bounds.left), bounds.bottom, bounds.right, bounds.top), inplace=True\n)\n\nrast.plot(ax=\"new\", cmap=\"Greys_r\", alpha=0.7)\nvect.plot(ref_crs=rast, fc=\"none\", ec=\"tab:purple\", lw=3)\n\n#\n\n\n", "task": "Crop the vector data `vect` to the extent of the raster `rast` and then plot both the raster and the cropped vector data. Define the variable `bounds` to represent the extent of the raster in the coordinate system of the vector data.", "exec_path": "geoutils-main", "context": "import geoutils as gu\n# sphinx_gallery_thumbnail_number = 3\nfilename_rast = gu.examples.get_path('everest_landsat_b4_cropped')\nfilename_vect = gu.examples.get_path('everest_rgi_outlines')\nrast = gu.Raster(filename_rast)\nvect = gu.Vector(filename_vect)\n", "functions": ["rast.get_bounds_projected", "vect.crop", "rast.plot", "vect.plot"], "external_vars": ["rast", "vect"], "defined_vars": ["bounds"], "parameters": [], "libraries": ["import geoutils as gu"]}
{"code": "\nMap = geemap.Map(center=[37.75, -122.45], zoom=12)\n\ncollection = (\n    ee.ImageCollection(\"COPERNICUS/S2_SR\")\n    .filterBounds(ee.Geometry.Point([-122.45, 37.75]))\n    .filterMetadata(\"CLOUDY_PIXEL_PERCENTAGE\", \"less_than\", 10)\n)\n\nvis_params = {\"min\": 0, \"max\": 4000, \"bands\": [\"B8\", \"B4\", \"B3\"]}\n\nMap.add_time_slider(collection, vis_params)\nMap\n\n#\n", "task": "Using the `ee` and `geemap` libraries, create a map centered at coordinates [37.75, -122.45] with a zoom level of 12. Filter the Sentinel-2 Surface Reflectance (COPERNICUS/S2_SR) image collection to include images within the bounds of the specified point and have a cloud cover percentage less than 10%. Define the `vis_params` dictionary to set the visualization parameters for the imagery. Then, add a time slider to the map using the filtered image collection and the `vis_params`. Make sure to define the variables `vis_params`, `Map`, and `collection` accordingly.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map", "unknown_function.filterMetadata", "unknown_function.filterBounds", "ee.ImageCollection", "ee.Geometry.Point", "Map.add_time_slider"], "external_vars": ["ee", "geemap"], "defined_vars": ["collection", "Map", "vis_params"], "parameters": ["CLOUDY_PIXEL_PERCENTAGE", "less_than", 10, "COPERNICUS/S2_SR", "collection", "vis_params", "ee.Geometry.Point([-122.45, 37.75])", "[-122.45, 37.75]"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nMap = geemap.Map()\nMap\n\n#\n", "task": "Using the `geemap` library, create a new map object named `Map`.", "exec_path": "geemap-master", "context": "import geemap\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import geemap"]}
{"code": "\n# %% We plot it.\nrast.plot(cmap=\"terrain\")\n#\n", "task": "Plot the raster dataset `rast` using the \"terrain\" colormap.", "exec_path": "geoutils-main", "context": "import geoutils as gu\n# sphinx_gallery_thumbnail_number = 2\nfilename_rast = gu.examples.get_path('exploradores_aster_dem')\nrast = gu.Raster(filename_rast)\n", "functions": ["rast.plot"], "external_vars": ["rast"], "defined_vars": [], "parameters": [], "libraries": ["import geoutils as gu"]}
{"code": "\nroi = m.user_roi\nif roi is None:\n    roi = ee.Geometry.BBox(-171.21, -57.13, 177.53, 79.99)\n    m.add_layer(roi)\n    m.center_object(roi)\n\n#\n", "task": "Define a variable called `roi` using the `user_roi` property of the `m` object. If `roi` is `None`, set it to an `ee.Geometry.BBox` object with coordinates (-171.21, -57.13, 177.53, 79.99). Then, add this `roi` as a layer to the map (`m`) and center the map on this `roi`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nm = geemap.Map()\n", "functions": ["ee.Geometry.BBox", "m.add_layer", "m.center_object"], "external_vars": ["m", "ee"], "defined_vars": ["roi"], "parameters": [177.53, 79.99, "roi", "roi", "-171.21", "-57.13"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nm = geemap.Map()\nm.add_stac_layer(url, bands=[\"pan\"], name=\"Panchromatic\")\nm.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\")\nm\n\n#\n", "task": "Using the `geemap` library, create a map object named `m`. Then add two STAC layers to the map using the provided `url`. The first layer should use the \"pan\" band and be named \"Panchromatic\". The second layer should use the \"B3\", \"B2\", and \"B1\" bands and be named \"False color\".", "exec_path": "geemap-master", "context": "import geemap\nurl = 'https://tinyurl.com/22vptbws'\n", "functions": ["geemap.Map", "m.add_stac_layer", "m.add_stac_layer"], "external_vars": ["geemap", "url"], "defined_vars": ["m"], "parameters": ["url", "url"], "libraries": ["import geemap"]}
{"code": "\nm = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nimage = \"https://i.imgur.com/SpmE7Cs.png\"\nm.add_image(image, position=\"bottomright\")\nm\n\n#\n\n\n", "task": "Using the `leafmap` library, create a map object named `m`. Add the \"OpenTopoMap\" basemap to the map. Define a variable `image` containing the URL \"https://i.imgur.com/SpmE7Cs.png\". Add this image to the map using the `add_image` function, placing it in the bottom-right corner.", "exec_path": "leafmap-master", "context": "import leafmap.foliumap as leafmap\n", "functions": ["leafmap.Map", "m.add_basemap", "m.add_image"], "external_vars": ["leafmap"], "defined_vars": ["m", "image"], "parameters": ["OpenTopoMap", "image"], "libraries": ["import leafmap.foliumap as leafmap"]}
{"code": "\nm.clear_controls()\n\n#\n", "task": "Clear the controls of the object \"m\". You will need to define the variable \"m\" beforehand.", "exec_path": "geemap-master", "context": "import geemap.plotlymap as geemap\nm = geemap.Map(basemap='stamen-toner')\n", "functions": ["m.clear_controls"], "external_vars": ["m"], "defined_vars": [], "parameters": [], "libraries": ["import geemap.plotlymap as geemap"]}
{"code": "\n# Many measures of texture are output by `image.glcm()`. For a complete reference on the outputs, see [Haralick et al. (1973)](http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4309314&tag=1) and [Conners et al. (1984)](http://www.sciencedirect.com/science/article/pii/0734189X8490197X).\n# \n# Local measures of spatial association such as Gearys C [(Anselin 1995)](http://onlinelibrary.wiley.com/doi/10.1111/j.1538-4632.1995.tb00338.x/abstract) can be computed in Earth Engine using `image.neighborhoodToBands()`. Using the image from the previous example:\n#\n# In[ ]:\n\n#\n# Create a list of weights for a 9x9 kernel.\nlist = [1, 1, 1, 1, 1, 1, 1, 1, 1]\n# The center of the kernel is zero.\ncenterList = [1, 1, 1, 1, 0, 1, 1, 1, 1]\n# Assemble a list of lists: the 9x9 kernel weights as a 2-D matrix.\nlists = [list, list, list, list, centerList, list, list, list, list]\n# Create the kernel from the weights.\n# Non-zero weights represent the spatial neighborhood.\nkernel = ee.Kernel.fixed(9, 9, lists, -4, -4, False)\n#\n", "task": "Using the Earth Engine library (ee), define a 9x9 fixed kernel with a center value of 0 and all other values set to 1. Define the following variables: \"list\", \"centerList\", \"lists\", and \"kernel\".", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.foliumap as emap\nimport geemap as emap\nimport ee\nee.Initialize()\n", "functions": ["ee.Kernel.fixed"], "external_vars": ["ee"], "defined_vars": ["kernel", "lists", "list", "centerList"], "parameters": [9, 9, "lists", false, "-4", "-4"], "libraries": ["import geemap.foliumap as emap", "import geemap as emap", "import ee", "import geemap"]}
{"code": "\ngdf.plot(column='Z', cmap='gist_earth', aspect='equal', legend=True)\nplt.grid()\n\n#\n", "task": "Using the geopandas dataframe `gdf` and the matplotlib library `plt`, create a choropleth map where the color of each region is determined by the value in the `Z` column. Use the `gist_earth` colormap and set the aspect ratio to `equal`. Include a legend and grid lines on the map.", "exec_path": "gemgis-main", "context": "import gemgis as gg\nimport rasterio\nimport matplotlib.pyplot as plt\nfile_path = 'data/08_sampling_interfaces_orientations_from_raster/'\nraster = rasterio.open(file_path + 'raster.tif')\npoint_x = [100, 200, 300, 400, 500]\npoint_y = [100, 200, 300, 400, 500]\ngdf = gg.raster.sample_interfaces(\n    raster=raster, point_x=point_x, point_y=point_y, formation='Test', crs='EPSG:4326')\n", "functions": ["gdf.plot", "plt.grid"], "external_vars": ["plt", "gdf"], "defined_vars": [], "parameters": [], "libraries": ["import gemgis as gg", "import rasterio", "import matplotlib.pyplot as plt"]}
{"code": "\nwell1 = pv.Line((1750,7000,0), (1750,7000, 1000))\nwell1_tube = well1.tube(radius=50)\nwell1_tube\n\n#\n", "task": "Using the `pv` library, create a line object named `well1` starting at coordinates (1750, 7000, 0) and ending at (1750, 7000, 1000). Then, create a tube object named `well1_tube` based on `well1` with a radius of 50.", "exec_path": "gemgis_data-main", "context": "import pyvista as pv\n", "functions": ["pv.Line", "well1.tube"], "external_vars": ["pv"], "defined_vars": ["well1_tube", "well1"], "parameters": ["(1750, 7000, 0)", "(1750, 7000, 1000)"], "libraries": ["import pyvista as pv"]}
{"code": "\ntopo.plot(column='Z', aspect=1, legend=True, cmap='gist_earth')\n\n#\n", "task": "Using the provided geospatial data stored in the variable `topo`, create a plot with the following specifications:  \\n\\n* Plot the column labeled \"Z\". \\n* Set the aspect ratio to 1. \\n* Include a legend. \\n* Use the \"gist_earth\" colormap. \\n\\nPlease define the following variables before executing the code:  \\n\\n* `topo`  (a geospatial DataFrame or object)", "exec_path": "gemgis_data-main", "context": "import geopandas as gpd\n#\nfile_path = 'data/example10_faulted_folded_layers/'\ntopo = gpd.read_file(file_path + 'topo10.shp')\n", "functions": ["topo.plot"], "external_vars": ["topo"], "defined_vars": [], "parameters": [], "libraries": ["import geopandas as gpd"]}
{"code": "\ngeemap.ee_initialize()\n\n#\n", "task": "Initialize the Earth Engine library using the `geemap` module.", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.cartoee as cartoee\nimport geemap.colormaps as cmp\n", "functions": ["geemap.ee_initialize"], "external_vars": ["geemap"], "defined_vars": [], "parameters": [], "libraries": ["import geemap.cartoee as cartoee", "import geemap.colormaps as cmp", "import geemap"]}
{"code": "\ntype(wfs)\n\n#\n", "task": "Determine the data type of the variable `wfs`. You will need to define the variable `wfs` beforehand.", "exec_path": "gemgis-main", "context": "import gemgis as gg\n#\nwfs = gg.web.load_wfs(\n    'https://nibis.lbeg.de/net3/public/ogc.ashx?NodeId=476&Service=WFS&')\n", "functions": ["type"], "external_vars": ["wfs", "type"], "defined_vars": [], "parameters": ["wfs"], "libraries": ["import gemgis as gg"]}
{"code": "\nMap = geemap.Map()\nMap\n\n#\n", "task": "Using the geemap library, create a new map object named \"Map\".", "exec_path": "geemap-master", "context": "import geemap\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import geemap"]}
{"code": "\ngeemap.show_image(out_gif)\n\n#\n", "task": "Display the animated GIF image stored in the `out_gif` variable using the `geemap` library. Ensure that `geemap` is imported and that `out_gif` is a valid path to a GIF file. ", "exec_path": "geemap-master", "context": "import geemap\nout_gif = 'output.gif'\n", "functions": ["geemap.show_image"], "external_vars": ["geemap", "out_gif"], "defined_vars": [], "parameters": ["out_gif"], "libraries": ["import geemap"]}
{"code": "\nMap = geemap.Map(center=(40, -100), zoom=4)\n#\n", "task": "Using the geemap library, create a map object named \"Map\" centered at coordinates (40, -100) with a zoom level of 4.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nimport geemap.colormaps as cm\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import geemap.colormaps as cm", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nMap = geemap.Map()\n\nregion = ee.Geometry.BBox(-179, -89, 179, 89)\nstart_date = \"2021-01-01\"\nend_date = \"2022-01-01\"\n\ndw_class = geemap.dynamic_world(region, start_date, end_date, return_type=\"class\")\ndw = geemap.dynamic_world(region, start_date, end_date, return_type=\"hillshade\")\n\ndw_vis = {\"min\": 0, \"max\": 8, \"palette\": \"dw\"}\n\nMap.addLayer(dw_class, dw_vis, \"DW Land Cover\", False)\nMap.addLayer(dw, {}, \"DW Land Cover Hillshade\")\n\nMap.add_legend(title=\"Dynamic World Land Cover\", builtin_legend=\"Dynamic_World\")\nMap.setCenter(-88.9088, 43.0006, 12)\nMap\n\n#\n", "task": "Using the libraries ee and geemap, create a map (Map) of the world using Dynamic World Land Cover data for the year 2021.  You will need to define the following variables: end_date, Map, dw, dw_vis, dw_class, start_date, and region. Add the Dynamic World land cover data as a layer (with the layer name \"DW Land Cover\") and display the land cover types using the DW palette.  You can also add a hillshade layer (\"DW Land Cover Hillshade\") and a legend with the title \"Dynamic World Land Cover.\" Center the map at (-88.9088, 43.0006) and zoom in to a zoom level of 12.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["geemap.Map", "ee.Geometry.BBox", "geemap.dynamic_world", "geemap.dynamic_world", "Map.addLayer", "Map.addLayer", "Map.add_legend", "Map.setCenter"], "external_vars": ["ee", "geemap"], "defined_vars": ["Map", "dw", "dw_vis", "region", "end_date", "dw_class", "start_date"], "parameters": [179, 89, "region", "start_date", "end_date", "region", "start_date", "end_date", "dw_class", "dw_vis", "DW Land Cover", false, "dw", "DW Land Cover Hillshade", 43.0006, 12, "-179", "-89", "{}", "-88.9088"], "libraries": ["import ee", "import geemap"]}
{"code": "\n# Let's define a point of interest:\npoi = ee.Geometry.BBoxFromQuery(\"Buenos Aires, Argentina\",user_agent = \"eemont-tutorial-030\")\n", "task": "Using the Earth Engine library (ee), define a variable named **poi** that represents the bounding box of the location \"Buenos Aires, Argentina\".", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\nimport geemap.colormaps as cm\n", "functions": ["ee.Geometry.BBoxFromQuery"], "external_vars": ["ee"], "defined_vars": ["poi"], "parameters": ["Buenos Aires, Argentina"], "libraries": ["import eemont", "import geemap.colormaps as cm", "import ee", "import geemap"]}
{"code": "\npkgs = [\n    \"leafmap\",\n    \"geopandas\",\n    \"keplergl\",\n    \"pydeck\",\n    \"xarray_leaflet\",\n    \"osmnx\",\n    \"pygeos\",\n    \"imageio\",\n    \"tifffile\",\n]\nif \"google.colab\" in sys.modules:\n    for pkg in pkgs:\n        install(pkg)\n\n#\n", "task": "Install a list of packages (`pkgs`) if the current environment is Google Colab using the `install` function from the `sys` module.  Define the following variables: `pkgs` (list of package names) and `pkg` (individual package name).", "exec_path": "leafmap-master", "context": "import subprocess\nimport sys\n\n\ndef install(package):\n    subprocess.check_call([sys.executable, '-m', 'pip', 'install', package])\n", "functions": ["install"], "external_vars": ["sys", "install"], "defined_vars": ["pkg", "pkgs"], "parameters": ["pkg"], "libraries": ["import subprocess", "import sys"]}
{"code": "\n# Load an image.\nimage = ee.Image(\"LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318\")\n#\n", "task": "Using the Earth Engine library (`ee`), define a variable named `image` and assign it to an image object representing the Landsat 8 Collection 1 Tier 1 TOA image with ID `LC08_044034_20140318`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap import geojson_to_ee, ee_to_geojson\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["image"], "parameters": ["LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318"], "libraries": ["from geemap import geojson_to_ee, ee_to_geojson", "import ee", "import geemap"]}
{"code": "\ncountries = ee.FeatureCollection(geemap.examples.get_ee_path(\"countries\"))\n\n#\n", "task": "Using the `ee` and `geemap` libraries, define a variable named `countries` that represents a FeatureCollection of countries. The data should be obtained using the `get_ee_path` function within `geemap.examples`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.FeatureCollection", "geemap.examples.get_ee_path"], "external_vars": ["ee", "geemap"], "defined_vars": ["countries"], "parameters": ["countries", "geemap.examples.get_ee_path('countries')"], "libraries": ["import ee", "import geemap"]}
{"code": "\nm = geemap.Map()\ndata = \"https://github.com/opengeos/datasets/releases/download/world/countries.gpkg\"\nm.add_vector(data, layer_name=\"Countries\")\nm\n\n#\n", "task": "Using the geemap library, create a Map object named \"m\" and add a vector layer from the provided data URL to the map. The data URL is stored in the variable \"data\". Name the layer \"Countries\".", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nfrom geemap.datasets import get_metadata\n", "functions": ["geemap.Map", "m.add_vector"], "external_vars": ["geemap"], "defined_vars": ["m", "data"], "parameters": ["data"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata"]}
{"code": "\nstrikes = gpd.read_file(file_path + 'strikes27.shp')\nstrikes\n\n#\n", "task": "Read the shapefile \"strikes27.shp\" located at the path defined by \"file_path\" using the geopandas library \"gpd\" and store the resulting GeoDataFrame in a variable called \"strikes\".", "exec_path": "gemgis-main", "context": "import geopandas as gpd\nfile_path = 'data/example27/'\n", "functions": ["gpd.read_file"], "external_vars": ["file_path", "gpd"], "defined_vars": ["strikes"], "parameters": ["file_path + 'strikes27.shp'"], "libraries": ["import geopandas as gpd"]}
{"code": "\nm = leafmap.Map()\nin_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\"\nm.add_heatmap(\n    in_csv,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    value=\"pop_max\",\n    name=\"Heat map\",\n    radius=20,\n)\n\n#\n", "task": "Using the `leafmap` library, create a map object named `m`.  Define a variable `in_csv` to store the URL of the world cities CSV file. Then, add a heatmap to the map using the data from `in_csv`, mapping `latitude` and `longitude` columns and using the `pop_max` column for heat intensity. Set the name of the heatmap to \"Heat map\" and the radius to 20.", "exec_path": "leafmap-master", "context": "import leafmap\nimport leafmap.colormaps as cm\nimport leafmap.foliumap as leafmap\n", "functions": ["leafmap.Map", "m.add_heatmap"], "external_vars": ["leafmap"], "defined_vars": ["m", "in_csv"], "parameters": ["in_csv"], "libraries": ["import leafmap.foliumap as leafmap", "import leafmap.colormaps as cm", "import leafmap"]}
{"code": "\n# In[ ]:\n\n#\n# generate some fake\nn = 2000\nx = np.linspace(0.0, 10.0, n)\nnp.random.seed(0)\ny = np.cumsum(np.random.randn(n) * 10).astype(int)\n\n#\n", "task": "Using the numpy library (imported as `np`) define three variables: `n` (an integer), `x` (an array of evenly spaced values), and `y` (an array of cumulative sums of random values), following these steps:\\n\\n1. Set `n` to 2000.\\n2. Create an array `x` containing 2000 evenly spaced values from 0.0 to 10.0 using `np.linspace`.\\n3. Seed the random number generator with 0 using `np.random.seed(0)`.\\n4. Create an array `y` containing the cumulative sum of 2000 random numbers drawn from a standard normal distribution (using `np.random.randn`), multiplied by 10, and cast the result to integers using `.astype(int)`.", "exec_path": "geemap-master", "context": "import numpy as np\n", "functions": ["np.linspace", "np.random.seed", "unknown_function.astype", "np.cumsum", "np.random.randn"], "external_vars": ["int", "np"], "defined_vars": ["y", "n", "x"], "parameters": [0.0, 10.0, "n", 0, "int", "n", "np.random.randn(n) * 10"], "libraries": ["import numpy as np"]}
{"code": "\nfig, (ax1, ax2) = plt.subplots(1,2)\n\ngdf.plot(ax=ax1, aspect='equal')\nax1.grid()\nax1.set_xlim(-500, 1300)\nax1.set_ylim(-250, 1400)\n", "task": "Using the matplotlib library (`plt`) and the geodataframe `gdf`, create a figure with two subplots. Plot the geodataframe on the first subplot (`ax1`), ensuring equal aspect ratio and setting the limits of the x-axis to -500 to 1300 and the y-axis to -250 to 1400. Add a grid to the first subplot.  Define the following variables: `fig`, `ax1`, and `ax2`.", "exec_path": "gemgis-main", "context": "import geopandas as gpd\nimport matplotlib.pyplot as plt\nfile_path = 'data/04_clipping_data/'\ngdf = gpd.read_file(file_path + 'randompoints.shp')\n", "functions": ["plt.subplots", "gdf.plot", "ax1.grid", "ax1.set_xlim", "ax1.set_ylim"], "external_vars": ["plt", "gdf"], "defined_vars": ["ax1", "fig", "ax2"], "parameters": [1, 2, 1300, 1400, "-500", "-250"], "libraries": ["import geopandas as gpd", "import matplotlib.pyplot as plt"]}
{"code": "\n# ## Time Series By Regions\n# Let's get the L8 time series for our buffer. Checklist:\n# - Image Collection: The Landsat 8 collection.\n# - Bands to use for the time series: GNDVI and EVI.\n# - Feature Collection: Our center-pivot crops.\n# - Statistics to compute: Mean and Median.\n# - Scale: 30 m.\nts = L8.getTimeSeriesByRegions(collection = pivots,\n                               bands = ['EVI','GNDVI'],\n                               reducer = [ee.Reducer.mean(),ee.Reducer.median()],\n                               scale = 30)\n", "task": "Using the Earth Engine library (`ee`), Landsat 8 collection (`L8`), and a collection of regions (`pivots`), calculate the mean and median values of the EVI and GNDVI bands for each region over time. Store the resulting time series in a variable called `ts`. Use a scale of 30 meters.", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\npivots = ee.FeatureCollection([ee.Feature(ee.Geometry.Point([27.724856, 26.48504]).buffer(400), {'pivot': 0}), ee.Feature(ee.Geometry.Point(\n    [27.719427, 26.478505]).buffer(400), {'pivot': 1}), ee.Feature(ee.Geometry.Point([27.714185, 26.471802]).buffer(400), {'pivot': 2})])\nL8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(\n    pivots).maskClouds().scaleAndOffset().spectralIndices(['EVI', 'GNDVI'])\n", "functions": ["L8.getTimeSeriesByRegions", "ee.Reducer.mean", "ee.Reducer.median"], "external_vars": ["pivots", "L8", "ee"], "defined_vars": ["ts"], "parameters": [], "libraries": ["import eemont", "import ee", "import geemap"]}
{"code": "\nMap = geemap.Map(center=[40, -100], zoom=4)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states, {}, \"US States\")\nMap\n\n#\n", "task": "Using the `geemap` and `ee` libraries, create a map centered at coordinates [40, -100] with a zoom level of 4. Load the US States feature collection from the `TIGER/2018/States` dataset and add it to the map. Define the variables `states` and `Map` to store the respective objects.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\n", "functions": ["geemap.Map", "ee.FeatureCollection", "Map.addLayer"], "external_vars": ["ee", "geemap"], "defined_vars": ["Map", "states"], "parameters": ["TIGER/2018/States", "states", "US States", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "import geemap", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nkeys = [str(x).zfill(2) + \"_ppt\" for x in range(1, 13)]\nvalues = [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\",\n]\n\n#\n", "task": "Create a list named \"keys\" containing strings formatted as \"XX_ppt\" where XX represents month numbers from 1 to 12 with leading zeros. Also, define a list named \"values\" containing the names of months in a year. Use the \"range\" and \"str\" functions for this task. Define variables \"keys\", \"values\", and \"x\" for use in this code.", "exec_path": "geemap-master", "context": "", "functions": ["unknown_function.zfill", "str", "range"], "external_vars": ["range", "str"], "defined_vars": ["keys", "x", "values"], "parameters": [2, "x", 1, 13], "libraries": []}
{"code": "\ngeemap.ee_initialize()\n\n#\n", "task": "Initialize the Earth Engine API using the geemap library. Ensure that you have imported geemap as `geemap` before running this code. The following variables need to be defined: [].", "exec_path": "geemap-master", "context": "import geemap\n", "functions": ["geemap.ee_initialize"], "external_vars": ["geemap"], "defined_vars": [], "parameters": [], "libraries": ["import geemap"]}
{"code": "\npoint_x = [100, 200, 300, 400 ,500]\npoint_y = [100, 200, 300, 400 ,500]\n\ngdf = gg.raster.sample_orientations(raster=raster.read(1), \n                                    point_x=point_x,\n                                    point_y=point_y,\n                                    extent=[0, 972, 0 ,1069],\n                                    formation='Test',\n                                    crs='EPSG:4326')\n\ngdf\n\n#\n", "task": "Using the external variables `raster` and `gg`, sample orientations from the raster at the specified points. Define the variables `point_x`, `point_y`, and `gdf` to store the point coordinates and the sampled orientations. Set the extent of the sampling area to [0, 972, 0, 1069], use the formation name \"Test\", and use the coordinate reference system \"EPSG:4326\".", "exec_path": "gemgis-main", "context": "import gemgis as gg\nimport rasterio\nfile_path = 'data/08_sampling_interfaces_orientations_from_raster/'\nraster = rasterio.open(file_path + 'raster.tif')\n", "functions": ["gg.raster.sample_orientations", "raster.read"], "external_vars": ["raster", "gg"], "defined_vars": ["gdf", "point_x", "point_y"], "parameters": [1], "libraries": ["import gemgis as gg", "import rasterio"]}
{"code": "\ngeemap.show_image(out_gif)\n", "task": "Display the GIF image stored in the `out_gif` variable using the `geemap` library. Make sure the `geemap` library and the `out_gif` variable are defined and accessible in your code.", "exec_path": "geemap-master", "context": "import geemap\nout_gif = 'output.gif'\n", "functions": ["geemap.show_image"], "external_vars": ["geemap", "out_gif"], "defined_vars": [], "parameters": ["out_gif"], "libraries": ["import geemap"]}
{"code": "\nm = geemap.Map(center=[40, -100], zoom=4)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nm.add_layer(states, {}, \"US States\")\nm\n\n#\n", "task": "Using the `geemap` and `ee` libraries, create a map object named `m` centered at coordinates [40, -100] with a zoom level of 4. Then, define a variable named `states` as an Earth Engine FeatureCollection representing US states from the \"TIGER/2018/States\" dataset. Finally, add the `states` layer to the `m` map with an empty dictionary for visualization parameters and a label \"US States\".", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nimport ee\nee.Initialize()\nfrom geemap.datasets import get_metadata\n", "functions": ["geemap.Map", "ee.FeatureCollection", "m.add_layer"], "external_vars": ["geemap", "ee"], "defined_vars": ["states", "m"], "parameters": ["TIGER/2018/States", "states", "US States", "{}"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import get_metadata"]}
{"code": "\nrandom.seed(9)  # set a seed for reproducibility\n#\n", "task": "Set the random number generator seed to 9 using the `random` module.", "exec_path": "PlanetaryComputerExamples-main", "context": "import random\n", "functions": ["random.seed"], "external_vars": ["random"], "defined_vars": [], "parameters": [9], "libraries": ["import random"]}
{"code": "\ngeemap.stac_stats(\n    collection=collection,\n    items=items,\n    expression=\"(SR_B5-SR_B4)/(SR_B5+SR_B4)\",\n)\n\n#\n", "task": "Calculate the normalized difference vegetation index (NDVI) for each item in the STAC collection using the `geemap.stac_stats` function. Use the provided `collection` and `items` variables. The expression for NDVI calculation is \"(SR_B5-SR_B4)/(SR_B5+SR_B4)\". Ensure that the variables `SR_B5` and `SR_B4` are defined and represent the relevant spectral bands within the STAC collection.", "exec_path": "geemap-master", "context": "import geemap\ncollection = 'landsat-8-c2-l2'\nitems = 'LC08_L2SP_047027_20201204_02_T1'\n", "functions": ["geemap.stac_stats"], "external_vars": ["collection", "items", "geemap"], "defined_vars": [], "parameters": [], "libraries": ["import geemap"]}
{"code": "\n###############################################################################\n# Here the parameter ``h`` stands for the normalized range ``r / len_scale``.\n# Now we can instantiate this model:\n\nmodel = Gau(dim=2, var=2.0, len_scale=10)\n#\n", "task": "Define a variable named `model` using the class `Gau` with the following parameters: `dim=2`, `var=2.0`, and `len_scale=10`.", "exec_path": "GSTools", "context": "import gstools as gs\nimport numpy as np\n# use CovModel as the base-class\n\n\nclass Gau(gs.CovModel):\n\n    def cor(self, h):\n        return np.exp(-h ** 2)\n", "functions": ["Gau"], "external_vars": ["Gau"], "defined_vars": ["model"], "parameters": [], "libraries": ["import numpy as np", "import gstools as gs"]}
{"code": "\nwbt.fill_depressions(\"smoothed.tif\", \"filled.tif\")\n\n#\n", "task": "Using the `wbt` library, fill depressions in the image `smoothed.tif` and save the result to `filled.tif`.  Make sure to define the `wbt` variable before running this instruction.", "exec_path": "leafmap-master", "context": "import leafmap\nwbt = leafmap.WhiteboxTools()\n", "functions": ["wbt.fill_depressions"], "external_vars": ["wbt"], "defined_vars": [], "parameters": ["smoothed.tif", "filled.tif"], "libraries": ["import leafmap"]}
{"code": "\norientations = gpd.read_file(file_path + 'bottom_cret_orient.shp')\norientations.head()\n\n#\n", "task": "Read the shapefile \"bottom_cret_orient.shp\" from the specified file path using the GeoPandas library and assign it to the variable \"orientations\". Then, display the first few rows of the resulting GeoDataFrame.", "exec_path": "gemgis-main", "context": "import geopandas as gpd\nfile_path = 'data/25_creating_orientations_from_isolines_on_maps/'\n", "functions": ["gpd.read_file", "orientations.head"], "external_vars": ["file_path", "gpd"], "defined_vars": ["orientations"], "parameters": ["file_path + 'bottom_cret_orient.shp'"], "libraries": ["import geopandas as gpd"]}
{"code": "\nMap = geemap.Map()\nMap\n\n#\n", "task": "Using the geemap library, create a new map object and assign it to the variable \"Map\".", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nimport geemap.colormaps as cm\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import geemap.colormaps as cm", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\n# Add Earth Engine dataset\ndem = ee.Image(\"USGS/SRTMGL1_003\")\n#\n", "task": "Load the SRTMGL1_003 elevation data from Google Earth Engine and assign it to the variable **dem**. This requires you to have already imported the ee library.", "exec_path": "geemap-master", "context": "import geemap\nimport ee\nee.Initialize()\nfrom geemap.datasets import DATA\nimport geemap.colormaps as cm\ncentroid = ee.Geometry.Point([-122.4439, 37.7538])\nimage = ee.ImageCollection(\n    'LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["dem"], "parameters": ["USGS/SRTMGL1_003"], "libraries": ["import geemap.colormaps as cm", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\n# Like with MODIS, we'll have to convert mask codes to a binary fire mask. For GOES, we'll use the codes 10, 11, 30, and 31.\ndef fire_mask(img):\n    mask = ee.Image(0).rename(\"fire\")\n    mask = (mask\n        .where(img.eq(10), 1)\n        .where(img.eq(11), 1)\n        .where(img.eq(30), 1)\n        .where(img.eq(31), 1)\n    )\n    # Copy the properties from the original images to avoid losing time data.\n    return mask.copyProperties(img, img.propertyNames())\n", "task": "Define a function called `fire_mask` that takes an Earth Engine image (`img`) as input. Within the function, create an Earth Engine image (`mask`) initialized with a value of 0 and renamed to \"fire\". Then, use `where` conditions to set pixels in the `mask` to 1 where the corresponding pixel values in `img` are equal to 10, 11, 30, or 31. Finally, copy the properties of the input image (`img`) to the `mask` and return the `mask` image. The function requires the use of the `ee` module for Earth Engine operations.", "exec_path": "wxee-main", "context": "import ee\nee.Initialize()\nimport wxee\nwxee.Initialize()\n", "functions": ["unknown_function.rename", "ee.Image", "unknown_function.where", "unknown_function.where", "unknown_function.where", "mask.where", "img.eq", "img.eq", "img.eq", "img.eq", "mask.copyProperties", "img.propertyNames"], "external_vars": ["ee"], "defined_vars": ["mask", "img"], "parameters": ["fire", 0, 1, 1, 1, 1, 10, 11, 30, 31, "img", "img.eq(31)", "img.eq(30)", "img.eq(11)", "img.eq(10)", "img.propertyNames()"], "libraries": ["import wxee", "import ee"]}
{"code": "\npoint = ee.Geometry.Point(-99.2222, 46.7816)\ncollection = (\n    ee.ImageCollection(\"USDA/NAIP/DOQQ\")\n    .filterBounds(point)\n    .filterDate(\"2008-01-01\", \"2018-01-01\")\n    .filter(ee.Filter.listContains(\"system:band_names\", \"N\"))\n)\n\n#\n", "task": "Using the Earth Engine library (ee), define a point geometry with coordinates -99.2222, 46.7816 and store it in the variable `point`. Then, load the USDA/NAIP/DOQQ image collection and filter it to include only images that intersect the defined point, fall within the date range of 2008-01-01 to 2018-01-01, and contain the band \"N\". Store the resulting filtered image collection in the variable `collection`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Geometry.Point", "unknown_function.filter", "unknown_function.filterDate", "unknown_function.filterBounds", "ee.ImageCollection", "ee.Filter.listContains"], "external_vars": ["ee"], "defined_vars": ["collection", "point"], "parameters": [46.7816, "2008-01-01", "2018-01-01", "point", "USDA/NAIP/DOQQ", "system:band_names", "N", "-99.2222", "ee.Filter.listContains('system:band_names', 'N')"], "libraries": ["import ee", "import geemap"]}
{"code": "\nMap.add_colorbar(\n    vis_params,\n    label=\"Elevation (m)\",\n    layer_name=\"SRTM DEM\",\n    orientation=\"vertical\",\n    transparent_bg=True,\n)\n\n#\n", "task": "Using the provided `Map` object and `vis_params` dictionary, add a colorbar to the map.  The colorbar should be labeled \"Elevation (m)\", associated with the layer named \"SRTM DEM\", oriented vertically, and have a transparent background.  Ensure that the following variables are defined: `Map` and `vis_params`.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\n#\nMap = geemap.Map()\nvis_params = {'min': 0, 'max': 4000, 'palette': [\n    '006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']}\n", "functions": ["Map.add_colorbar"], "external_vars": ["Map", "vis_params"], "defined_vars": [], "parameters": ["vis_params"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nwell2 = pv.Line((1000,3250,1200), (1000, 3250, 200))\nwell2_tube = well2.tube(radius=50)\nwell2_tube\n\n#\n", "task": "Using the external variable `pv`, define a line object named `well2` with start coordinates (1000, 3250, 1200) and end coordinates (1000, 3250, 200). Then, create a tube object named `well2_tube` from the `well2` line with a radius of 50.", "exec_path": "gemgis_data-main", "context": "import pyvista as pv\n", "functions": ["pv.Line", "well2.tube"], "external_vars": ["pv"], "defined_vars": ["well2_tube", "well2"], "parameters": ["(1000, 3250, 1200)", "(1000, 3250, 200)"], "libraries": ["import pyvista as pv"]}
{"code": "\nstyle = {\"color\": \"0000FFFF\", \"fillColor\": \"00000000\"}\nm.add_layer(counties, {}, \"Counties Vector\", False)\nm.add_layer(counties.style(**style), {}, \"Counties Raster\")\nm\n\n#\n", "task": "Add a vector layer named \"Counties Vector\" to the map `m` using the `counties` data. Then, add a raster layer named \"Counties Raster\" using the `counties` data styled with the predefined `style` dictionary. The `style` dictionary should be defined beforehand.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nimport ee\nee.Initialize()\nfrom geemap.datasets import get_metadata\ndata = 'GOES-17'\nm = geemap.Map(center=[64.864983, -147.840441], zoom=4)\ncounties = ee.FeatureCollection(\n    'TIGER/2018/Counties').filter(ee.Filter.eq('STATEFP', '02'))\n", "functions": ["m.add_layer", "m.add_layer", "counties.style"], "external_vars": ["counties", "m"], "defined_vars": ["style"], "parameters": ["counties", "Counties Vector", false, "Counties Raster", "{}", "counties.style(**style)", "{}"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import get_metadata"]}
{"code": "\nm = geemap.Map()\nm\n\n#\n", "task": "Create a new map object using the geemap library and assign it to the variable `m`.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["m"], "parameters": [], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\n# Let's define a point of interest:\npoi = ee.Geometry.BBoxFromQuery(\"Salvajina, Colombia\",user_agent = \"eemont-tutorial-035\")\n", "task": "Using the Earth Engine library (ee), define a variable named `poi` that represents the bounding box of the location \"Salvajina, Colombia\".", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\nimport geemap.colormaps as cm\n", "functions": ["ee.Geometry.BBoxFromQuery"], "external_vars": ["ee"], "defined_vars": ["poi"], "parameters": ["Salvajina, Colombia"], "libraries": ["import eemont", "import geemap.colormaps as cm", "import ee", "import geemap"]}
{"code": "\ngdf.to_crs(4647).loc[0].geometry.length\n", "task": "Calculate the length of the geometry for the first row of the GeoDataFrame `gdf` after projecting it to the coordinate reference system (CRS) 4647.", "exec_path": "gemgis-main", "context": "import gemgis as gg\nimport geopandas as gpd\nfile_path = 'data/40_working_with_gpx_data_in_gemgis/'\ngpx = gg.vector.load_gpx(path=file_path + 'Run.gpx', layer='tracks')\nshape = gg.vector.load_gpx_as_geometry(\n    path=file_path + 'Run.gpx', layer='tracks')\ngdf = gpd.GeoDataFrame(geometry=[shape], crs=gpx.crs)\n", "functions": ["gdf.to_crs"], "external_vars": ["gdf"], "defined_vars": [], "parameters": [4647], "libraries": ["import gemgis as gg", "import geopandas as gpd"]}
{"code": "\nimage = ee.Image(\"USGS/SRTMGL1_003\")\n\n#\n", "task": "Using the Earth Engine library (ee), load the SRTMGL1_003 dataset into an Image object called \"image\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nimport geemap.colormaps as cm\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["image"], "parameters": ["USGS/SRTMGL1_003"], "libraries": ["import geemap.colormaps as cm", "import ee", "import geemap"]}
{"code": "\nmissing_month = ee.Image(\"ECMWF/ERA5_LAND/MONTHLY/200507\").select(\"temperature_2m\").rename(\"actual\")\n\n#\n", "task": "Using the Earth Engine library (`ee`), define a variable named `missing_month` by loading the image \"ECMWF/ERA5_LAND/MONTHLY/200507\" and selecting the \"temperature_2m\" band. Rename the selected band to \"actual\".", "exec_path": "wxee-main", "context": "import ee\nee.Initialize()\nimport wxee\nwxee.Initialize()\n", "functions": ["unknown_function.rename", "unknown_function.select", "ee.Image"], "external_vars": ["ee"], "defined_vars": ["missing_month"], "parameters": ["actual", "temperature_2m", "ECMWF/ERA5_LAND/MONTHLY/200507"], "libraries": ["import wxee", "import ee"]}
{"code": "\ngeemap.ee_to_geojson(fc, filename=\"TN.geojson\")\n\n#\n", "task": "Convert the Earth Engine FeatureCollection `fc` to a GeoJSON file named `TN.geojson` using the `geemap.ee_to_geojson` function.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nstates = ee.FeatureCollection('TIGER/2018/States')\nfc = states.filter(ee.Filter.eq('NAME', 'Tennessee'))\n", "functions": ["geemap.ee_to_geojson"], "external_vars": ["geemap", "fc"], "defined_vars": [], "parameters": ["fc"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nm = leafmap.Map()\n\n#\n", "task": "Create a new Leaflet map object using the `leafmap` library and assign it to the variable `m`.", "exec_path": "leafmap-master", "context": "import leafmap\nimport leafmap.colormaps as cm\nimport leafmap.foliumap as leafmap\n", "functions": ["leafmap.Map"], "external_vars": ["leafmap"], "defined_vars": ["m"], "parameters": [], "libraries": ["import leafmap.foliumap as leafmap", "import leafmap.colormaps as cm", "import leafmap"]}
{"code": "\nwms_array = gg.web.load_as_array(url=wms.url,\n                                 layer='nw_dop_rgb', \n                                 style='default', \n                                 crs='EPSG:4647', \n                                 bbox=[32286000,32328000, 5620000,5648000],\n                                 size=[4200, 2800], \n                                 filetype='image/png')\n\nwms_array[:1]\n\n#\n", "task": "Using the `gg` and `wms` objects, load a WMS image as an array from the URL specified in `wms.url`. Use the layer \"nw_dop_rgb\", style \"default\", and coordinate reference system \"EPSG:4647\". Set the bounding box to [32286000, 32328000, 5620000, 5648000], the image size to [4200, 2800], and the file type to \"image/png\". Save the resulting array as `wms_array` and then extract the first element of the array. ", "exec_path": "gemgis-main", "context": "import gemgis as gg\nwms = gg.web.load_wms('https://www.wms.nrw.de/geobasis/wms_nw_dop')\n", "functions": ["gg.web.load_as_array"], "external_vars": ["wms", "gg"], "defined_vars": ["wms_array"], "parameters": [], "libraries": ["import gemgis as gg"]}
{"code": "\n# In[ ]:\n\n#\n# Test with two variables\nimg2 = geemap.netcdf_to_ee(nc_file=nc_file, var_names=[\"u_wind\", \"v_wind\"])\nMap2 = geemap.Map()\nMap2.addLayer(\n    img2,\n    {\"bands\": [\"u_wind\"], \"min\": -20, \"max\": 25, \"palette\": palette, \"opacity\": 0.6},\n    \"uv_wind\",\n)\nMap2\n", "task": "Using the geemap library, convert the NetCDF file specified by the `nc_file` variable into an Earth Engine image object named `img2`. Extract the variables \"u_wind\" and \"v_wind\" from the file. Then, create a geemap Map object named `Map2` and add the `img2` image as a layer to the map. Set the layer's bands to \"u_wind\", the minimum and maximum values to -20 and 25 respectively, use the `palette` variable for color mapping, and set the layer's opacity to 0.6. Name the layer \"uv_wind\".", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.colormaps as cm\nnc_file = '../data/wind_global.nc'\npalette = cm.palettes.YlOrRd\nMap = geemap.Map()\n", "functions": ["geemap.netcdf_to_ee", "geemap.Map", "Map2.addLayer"], "external_vars": ["palette", "nc_file", "geemap"], "defined_vars": ["Map2", "img2"], "parameters": ["img2", "uv_wind", "{'bands': ['u_wind'], 'min': -20, 'max': 25, 'palette': palette, 'opacity': 0.6}"], "libraries": ["import geemap.colormaps as cm", "import geemap"]}
{"code": "\ngeemap.csv_to_shp(in_csv, out_shp)\n\n#\n", "task": "Convert the CSV file located at `in_csv` to a shapefile and save it to `out_shp`. Make sure you have the `geemap` library installed and imported.", "exec_path": "geemap-master", "context": "import os\nimport geemap\nin_csv = 'https://raw.githubusercontent.com/giswqs/data/main/world/world_cities.csv'\nout_dir = os.path.expanduser('~/Downloads')\nout_shp = os.path.join(out_dir, 'world_cities.shp')\n", "functions": ["geemap.csv_to_shp"], "external_vars": ["in_csv", "out_shp", "geemap"], "defined_vars": [], "parameters": ["in_csv", "out_shp"], "libraries": ["import os", "import geemap"]}
{"code": "\nMap = geemap.Map()\n\nimage = ee.Image(\"LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318\").select(\n    [\"B5\", \"B4\", \"B3\"]\n)\n\nvis_params = {\"min\": 0, \"max\": 0.5, \"gamma\": [0.95, 1.1, 1]}\n\nMap.centerObject(image)\nMap.addLayer(image, vis_params, \"Landsat\")\nMap\n\n#\n", "task": "Using the `ee` and `geemap` libraries, create a map centered on a Landsat 8 image. Define variables `image`, `vis_params`, and `Map` for the image, visualization parameters, and map object, respectively.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\npoint = ee.Geometry.Point(-99.2222, 46.7816)\ncollection = ee.ImageCollection('USDA/NAIP/DOQQ').filterBounds(point).filterDate(\n    '2008-01-01', '2018-01-01').filter(ee.Filter.listContains('system:band_names', 'N'))\nimage = collection.first()\n", "functions": ["geemap.Map", "unknown_function.select", "ee.Image", "Map.centerObject", "Map.addLayer"], "external_vars": ["ee", "geemap"], "defined_vars": ["image", "Map", "vis_params"], "parameters": ["LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318", "image", "image", "vis_params", "Landsat", "['B5', 'B4', 'B3']"], "libraries": ["import ee", "import geemap"]}
{"code": "\nwork_dir = os.path.expanduser(\"~/Downloads\")\nin_shp = os.path.join(work_dir, \"us_cities.shp\")\nif not os.path.exists(in_shp):\n    data_url = \"https://github.com/giswqs/data/raw/main/us/us_cities.zip\"\n    geemap.download_from_url(data_url, out_dir=work_dir)\n\n#\n", "task": "Using the external variables `os` and `geemap`, define the variables `work_dir`, `data_url`, and `in_shp`. Download the file from the provided URL if the file does not exist. ", "exec_path": "geemap-master", "context": "import os\nimport geemap\n", "functions": ["os.path.expanduser", "os.path.join", "os.path.exists", "geemap.download_from_url"], "external_vars": ["geemap", "os"], "defined_vars": ["data_url", "work_dir", "in_shp"], "parameters": ["~/Downloads", "work_dir", "us_cities.shp", "in_shp", "data_url"], "libraries": ["import os", "import geemap"]}
{"code": "\ngeemap.bar_chart(\n    \"treeloss.csv\",\n    x=\"NAME\",\n    y=\"sum\",\n    max_rows=20,\n    x_label=\"Country\",\n    y_label=\"Forest loss area (km2)\",\n)\n\n#\n", "task": "Using the geemap library, create a bar chart visualization from the \"treeloss.csv\" dataset. Set the x-axis to the \"NAME\" column and the y-axis to the \"sum\" column. Limit the chart to a maximum of 20 rows. Label the x-axis as \"Country\" and the y-axis as \"Forest loss area (km2)\".", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.bar_chart"], "external_vars": ["geemap"], "defined_vars": [], "parameters": ["treeloss.csv"], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nMap = geemap.Map()\n\nfc = ee.FeatureCollection(\"users/giswqs/public/countries\")\nMap.addLayer(fc, {}, \"Countries\")\nMap\n\n#\n", "task": "Using the `geemap` and `ee` libraries, create a map object called `Map` and add a layer of countries from the `users/giswqs/public/countries` FeatureCollection. Ensure that the layer is named \"Countries\". You need to define the variables `Map` and `fc` before executing the code.", "exec_path": "geemap-master", "context": "import geemap\nimport ee\nee.Initialize()\nfrom geemap.datasets import DATA\nimport geemap.colormaps as cm\n", "functions": ["geemap.Map", "ee.FeatureCollection", "Map.addLayer"], "external_vars": ["ee", "geemap"], "defined_vars": ["Map", "fc"], "parameters": ["users/giswqs/public/countries", "fc", "Countries", "{}"], "libraries": ["import geemap.colormaps as cm", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\n# ## Plotting an image on a map\n# \n# Here we are going to show another example of creating a map with EE results. We will use global sea surface temperature data for Jan-Mar 2018.\n#\n# In[ ]:\n\n#\n# get an earth engine image of ocean data for Jan-Mar 2018\nocean = (\n    ee.ImageCollection(\"NASA/OCEANDATA/MODIS-Terra/L3SMI\")\n    .filter(ee.Filter.date(\"2018-01-01\", \"2018-03-01\"))\n    .median()\n    .select([\"sst\"], [\"SST\"])\n)\n\n#\n", "task": "Using the Earth Engine library (ee), load the MODIS Terra Level 3 Sea Surface Temperature (SST) data for the period between January 1st and March 1st, 2018. Calculate the median SST value for the period and rename the \"sst\" band to \"SST\". Define the resulting image as \"ocean\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap import cartoee\n", "functions": ["unknown_function.select", "unknown_function.median", "unknown_function.filter", "ee.ImageCollection", "ee.Filter.date"], "external_vars": ["ee"], "defined_vars": ["ocean"], "parameters": ["NASA/OCEANDATA/MODIS-Terra/L3SMI", "2018-01-01", "2018-03-01", "['sst']", "['SST']", "ee.Filter.date('2018-01-01', '2018-03-01')"], "libraries": ["from geemap import cartoee", "import ee", "import geemap"]}
{"code": "\ntopo_raster = rasterio.open(file_path + 'raster1.tif')\n\n#\n", "task": "Using the `rasterio` library, open the raster file located at `file_path + \"raster1.tif\"` and assign the resulting raster object to the variable `topo_raster`.", "exec_path": "gemgis-main", "context": "import rasterio\n#\nfile_path = 'data/55_extracting_well_tops_from_pyvista_meshes/'\n", "functions": ["rasterio.open"], "external_vars": ["file_path", "rasterio"], "defined_vars": ["topo_raster"], "parameters": ["file_path + 'raster1.tif'"], "libraries": ["import rasterio"]}
{"code": "\ncanopy_sphere = ertsc.biosphere.DiscreteCanopy(\n    instanced_canopy_elements=ertsc.biosphere.InstancedCanopyElement(\n        id=\"sphere\",\n        canopy_element=spherical_leaf_cloud, \n        instance_positions=[(0, 0, 5.0)] * ureg.m\n    ),\n    size=[10.0, 10.0, 10.0] * ureg.m,\n)\n", "task": "Define a variable named `canopy_sphere` using the `ertsc.biosphere.DiscreteCanopy` function.  Set the `instanced_canopy_elements` to a new `ertsc.biosphere.InstancedCanopyElement` with the following parameters: `id='sphere'`, `canopy_element=spherical_leaf_cloud`, and `instance_positions` equal to a list containing a single tuple `(0, 0, 5.0)` multiplied by the unit `ureg.m`. Finally, set the `size` of the canopy to `[10.0, 10.0, 10.0]` multiplied by `ureg.m`.", "exec_path": "eradiate-tutorials-main", "context": "import eradiate.scenes as ertsc\nfrom eradiate import unit_registry as ureg\nspherical_leaf_cloud = ertsc.biosphere.LeafCloud.sphere(\n    radius=5.0 * ureg.m, n_leaves=10000, leaf_radius=10.0 * ureg.cm, leaf_reflectance=0.5, leaf_transmittance=0.5)\n", "functions": ["ertsc.biosphere.DiscreteCanopy", "ertsc.biosphere.InstancedCanopyElement"], "external_vars": ["spherical_leaf_cloud", "ertsc", "ureg"], "defined_vars": ["canopy_sphere"], "parameters": [], "libraries": ["import eradiate.scenes as ertsc", "from eradiate import unit_registry as ureg"]}
{"code": "\nsargs = dict(fmt=\"%.0f\", color='black')\n\np = pv.Plotter(notebook=True)\np.camera_position = [(161.91360339500804, -56.76742646880152, 61.85062200360107), (24.5, 24.5, 24.5), (-0.16718411386271567, 0.1641218812347994, 0.9721694709112653)]\n\np.add_mesh(slices, scalar_bar_args=sargs, nan_opacity=0)\n\np.show_grid(color='black')\np.set_background(color='white')\np.show()\n\n#\n", "task": "Using the pv library, create a plotter object named \"p\" in notebook mode.  Define a dictionary \"sargs\" with format string \"%.0f\" and color \"black\". Set the camera position of the plotter and add a mesh using the \"slices\" variable with the defined \"sargs\" dictionary and a nan opacity of 0.  Show the grid in black, set the background color to white, and display the plot.", "exec_path": "gemgis-main", "context": "import pyvista as pv\nimport numpy as np\nfile_path = 'data/49_slicing_gempy_lith_blocks_in_pyvista_with_gemgis/'\nlith_block = np.load(file_path + 'lith_block.npy').reshape(50, 50, 50)\nvolume = pv.wrap(lith_block)\nslices = volume.slice_orthogonal()\n", "functions": ["dict", "pv.Plotter", "p.add_mesh", "p.show_grid", "p.set_background", "p.show"], "external_vars": ["dict", "pv", "slices"], "defined_vars": ["p", "sargs"], "parameters": ["slices"], "libraries": ["import pyvista as pv", "import numpy as np"]}
{"code": "\ngeemap.ee_initialize()\n\n#\n", "task": "Initialize the Earth Engine API using the `geemap` library. This assumes you have already imported `geemap` and have the necessary Earth Engine credentials set up. ", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\n", "functions": ["geemap.ee_initialize"], "external_vars": ["geemap"], "defined_vars": [], "parameters": [], "libraries": ["from geemap import cartoee", "import geemap"]}
{"code": "\ninterfaces = gpd.read_file(file_path + 'interfaces21.shp')\ninterfaces.head()\n\n#\n", "task": "Read a shapefile named \"interfaces21.shp\" from the path specified by the \"file_path\" variable using the \"gpd\" library and store the resulting GeoDataFrame in a variable called \"interfaces\". Display the first few rows of the \"interfaces\" DataFrame.", "exec_path": "gemgis_data-main", "context": "import geopandas as gpd\nfile_path = 'data/example21_coal_seam_mining/'\n", "functions": ["gpd.read_file", "interfaces.head"], "external_vars": ["file_path", "gpd"], "defined_vars": ["interfaces"], "parameters": ["file_path + 'interfaces21.shp'"], "libraries": ["import geopandas as gpd"]}
{"code": "\ngeemap.csv_to_df(nlcd_stats)\n\n#\n", "task": "Using the `geemap` library, convert the `nlcd_stats` data into a Pandas DataFrame.  Make sure the `geemap` library is imported and that the `nlcd_stats` variable is defined.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nnlcd_stats = 'nlcd_stats_pct.csv'\n", "functions": ["geemap.csv_to_df"], "external_vars": ["geemap", "nlcd_stats"], "defined_vars": [], "parameters": ["nlcd_stats"], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nm = leafmap.Map(center=[0, 0], zoom=2)\nin_shp = \"https://github.com/opengeos/leafmap/raw/master/examples/data/countries.zip\"\nm.add_shp(in_shp, layer_name=\"Countries\")\nm\n\n#\n", "task": "Using the `leafmap` library, create a map centered at coordinates [0, 0] with zoom level 2. Define a variable `in_shp` to store the URL for a shapefile of countries. Add this shapefile to the map as a layer named \"Countries\".", "exec_path": "leafmap-master", "context": "import leafmap\nimport leafmap.colormaps as cm\nimport leafmap.foliumap as leafmap\n", "functions": ["leafmap.Map", "m.add_shp"], "external_vars": ["leafmap"], "defined_vars": ["m", "in_shp"], "parameters": ["in_shp"], "libraries": ["import leafmap.foliumap as leafmap", "import leafmap.colormaps as cm", "import leafmap"]}
{"code": "\nm = geemap.Map()\n\ncollection = (\n    ee.ImageCollection(\"MODIS/MCD43A4_006_NDVI\")\n    .filter(ee.Filter.date(\"2018-06-01\", \"2018-07-01\"))\n    .select(\"NDVI\")\n)\nvis_params = {\n    \"min\": 0.0,\n    \"max\": 1.0,\n    \"palette\": \"ndvi\",\n}\n\nm.add_time_slider(collection, vis_params, time_interval=2)\nm\n\n#\n", "task": "Using the geemap and ee libraries, create a map object called \"m\". Define a variable \"collection\" containing an ImageCollection of MODIS NDVI data from June 1st to July 1st, 2018, selecting the \"NDVI\" band. Define \"vis_params\" as a dictionary with minimum, maximum, and palette values for visualizing NDVI. Add a time slider to the map \"m\" using the \"collection\", \"vis_params\", and a time interval of 2.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nimport ee\nee.Initialize()\nfrom geemap.datasets import get_metadata\n", "functions": ["geemap.Map", "unknown_function.select", "unknown_function.filter", "ee.ImageCollection", "ee.Filter.date", "m.add_time_slider"], "external_vars": ["geemap", "ee"], "defined_vars": ["vis_params", "collection", "m"], "parameters": ["NDVI", "MODIS/MCD43A4_006_NDVI", "2018-06-01", "2018-07-01", "collection", "vis_params", "ee.Filter.date('2018-06-01', '2018-07-01')"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import get_metadata"]}
{"code": "\nMap = geemap.Map()\n\nfeatures = ee.FeatureCollection(DATA.users_giswqs_public_countries)\n\nstyle = {\"color\": \"000000ff\", \"width\": 1, \"lineType\": \"solid\", \"fillColor\": \"0000ff40\"}\n\nMap.addLayer(features.style(**style), {}, \"Polygons\")\nMap.setCenter(-14.77, 34.70, 2)\nMap\n\n#\n", "task": "Using the `geemap` library, create an interactive map named `Map`. Load the `users_giswqs_public_countries` feature collection from the `DATA` object using the `ee` library. Style the features with the provided `style` dictionary and add them to the map as a layer named \"Polygons\". Finally, center the map at coordinates -14.77, 34.7 with a zoom level of 2. Define the following variables: `Map`, `features`, and `style`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nimport geemap.colormaps as cmap\n", "functions": ["geemap.Map", "ee.FeatureCollection", "Map.addLayer", "features.style", "Map.setCenter"], "external_vars": ["ee", "DATA", "geemap"], "defined_vars": ["features", "style", "Map"], "parameters": ["Polygons", 34.7, 2, "DATA.users_giswqs_public_countries", "features.style(**style)", "{}", "-14.77"], "libraries": ["from geemap import cartoee", "import geemap", "import ee", "import geemap.colormaps as cmap", "from geemap.datasets import DATA"]}
{"code": "\nregion = m.user_roi_bounds()\nif region is None:\n    region = [-115.9689, 35.9758, -115.3619, 36.4721]\n\n#\n", "task": "Get the user-defined region of interest (ROI) bounds from the `m` object. If the bounds are not defined, set the `region` variable to the default bounds: [-115.9689, 35.9758, -115.3619, 36.4721].", "exec_path": "leafmap-master", "context": "import leafmap\nm = leafmap.Map(center=[40, -100], zoom=4)\n", "functions": ["m.user_roi_bounds"], "external_vars": ["m"], "defined_vars": ["region"], "parameters": [], "libraries": ["import leafmap"]}
{"code": "\nm = geemap.Map()\nm\n\n#\n", "task": "Create a new geemap Map object and assign it to the variable `m`.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["m"], "parameters": [], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nm.add_osm_from_view(tags={\"amenity\": \"bar\", \"building\": True}, layer_name=\"New York\")\n\n#\n", "task": "Using the map object `m`, add OpenStreetMap features from the current view that have the tags \"amenity: bar\" and \"building: True\" to a new layer named \"New York\".", "exec_path": "leafmap-master", "context": "import leafmap\nimport leafmap.colormaps as cm\nimport leafmap.foliumap as leafmap\nm = leafmap.Map(toolbar_control=False, layers_control=True)\n", "functions": ["m.add_osm_from_view"], "external_vars": ["m"], "defined_vars": [], "parameters": [], "libraries": ["import leafmap.foliumap as leafmap", "import leafmap.colormaps as cm", "import leafmap"]}
{"code": "\nL8.getCitation()\n", "task": "Retrieve the citation from the object stored in the variable L8.  The variable L8 must be defined and should be an object with a method called getCitation().", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\nL8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')\n", "functions": ["L8.getCitation"], "external_vars": ["L8"], "defined_vars": [], "parameters": [], "libraries": ["import eemont", "import ee", "import geemap"]}
{"code": "\n# Each Item contains a single \"data\" asset with a URL to the location of the Asset data on [Azure Blob Storage](https://azure.microsoft.com/en-us/services/storage/blobs/). \nasset_href = items[0].assets[\"data\"].href\nprint(asset_href.split(\"?\")[0])\n", "task": "Given a list of items, each with a dictionary of assets containing a data field with an href, extract the first item\\'s href, remove the query parameters, and print the result. Define a variable called `asset_href` for the href value. Use the following variables: `items`, `print`.", "exec_path": "PlanetaryComputerExamples-main", "context": "import pystac_client\nimport planetary_computer\ncatalog = pystac_client.Client.open(\n    'https://planetarycomputer.microsoft.com/api/stac/v1', modifier=planetary_computer.sign_inplace)\nlatitude = 39.55\nlongitude = -105.78\ndatetimes = ['2018']\nbuffer = 0.6\nbbox = [longitude - buffer, latitude - buffer,\n        longitude + buffer, latitude + buffer]\nfor datetime in datetimes:\n    print(f'Fetching {datetime}')\n    search = catalog.search(\n        collections=['drcog-lulc'], bbox=bbox, datetime=datetime)\nitems = list(search.get_items())\n", "functions": ["print", "asset_href.split"], "external_vars": ["items", "print"], "defined_vars": ["asset_href"], "parameters": ["?", "asset_href.split('?')[0]"], "libraries": ["import planetary_computer", "import pystac_client"]}
{"code": "\ntopo = gpd.read_file(file_path + 'topo5.shp')\ntopo.head()\n\n#\n", "task": "Using the geopandas library (`gpd`) and the provided `file_path`, read the shapefile \"topo5.shp\" and store it in a variable named `topo`. Then, display the first few rows of the data using the `.head()` method.", "exec_path": "gemgis-main", "context": "import geopandas as gpd\nfile_path = 'data/example05/'\n", "functions": ["gpd.read_file", "topo.head"], "external_vars": ["file_path", "gpd"], "defined_vars": ["topo"], "parameters": ["file_path + 'topo5.shp'"], "libraries": ["import geopandas as gpd"]}
{"code": "\n# In[ ]:\n\n#\n# Add Earth Engine dataset\nimage = ee.Image(\"USGS/SRTMGL1_003\")\n#\n", "task": "Using the Earth Engine library (ee), load the SRTMGL1_003 dataset as an image and assign it to the variable \"image\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Image"], "external_vars": ["ee"], "defined_vars": ["image"], "parameters": ["USGS/SRTMGL1_003"], "libraries": ["import ee", "import geemap"]}
{"code": "\nprint(training.first().getInfo())\n\n#\n", "task": "Print the information of the first element in the `training` variable using the `print` function and the `getInfo()` method.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\npoint = ee.Geometry.Point([-122.4439, 37.7538])\n# point = ee.Geometry.Point([-87.7719, 41.8799])\nimage = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(point).filterDate(\n    '2016-01-01', '2016-12-31').sort('CLOUD_COVER').first().select('B[1-7]')\nnlcd = ee.Image(\n    'USGS/NLCD/NLCD2016').select('landcover').clip(image.geometry())\n# Make the training dataset.\npoints = nlcd.sample(**{'region': image.geometry(), 'scale': 30,\n                     'numPixels': 5000, 'seed': 0, 'geometries': True})\n# Use these bands for prediction.\nbands = ['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7']\n# This property of the table stores the land cover labels.\nlabel = 'landcover'\n# Overlay the points on the imagery to get training.\ntraining = image.select(bands).sampleRegions(\n    **{'collection': points, 'properties': [label], 'scale': 30})\n", "functions": ["print", "unknown_function.getInfo", "training.first"], "external_vars": ["print", "training"], "defined_vars": [], "parameters": ["training.first().getInfo()"], "libraries": ["import ee", "import geemap"]}
{"code": "\nurl = \"https://github.com/opengeos/datasets/releases/download/world/countries.zip\"\ngeemap.download_file(url, overwrite=True)\n\n#\n", "task": "Download the countries.zip file from the given URL using the geemap library. The URL variable should be defined beforehand.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nfrom geemap.datasets import get_metadata\n", "functions": ["geemap.download_file"], "external_vars": ["geemap"], "defined_vars": ["url"], "parameters": ["url"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata"]}
{"code": "\nMap = geemap.Map()\nMap\n\n#\n", "task": "Using the geemap library, create a new map object called `Map`.", "exec_path": "geemap-master", "context": "import geemap\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import geemap"]}
{"code": "\n# Let's visualize our point (color red):\nMap.addLayer(pointFromQuery,{'color':'red'},'Arcgis')\nMap.centerObject(pointFromQuery,10)\nMap\n", "task": "Add a red point layer to the map using the `pointFromQuery` object, and center the map on this point with a zoom level of 10.  You will need to define the following variables: `pointFromQuery`, `Map`.", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\n# Authenticate and Initialize Earth Engine and geemap.\nMap = geemap.Map()\n# A query is a string representing a place that is geocoded in order to get its coordinates.\nquery = 'Santa Marta, Magdalena, Colombia'\npointFromQuery = ee.Geometry.PointFromQuery(\n    query, geocoder='arcgis', user_agent='eemont-tutorial-010')\n", "functions": ["Map.addLayer", "Map.centerObject"], "external_vars": ["Map", "pointFromQuery"], "defined_vars": [], "parameters": ["pointFromQuery", "Arcgis", "pointFromQuery", 10, "{'color': 'red'}"], "libraries": ["import eemont", "import ee", "import geemap"]}
{"code": "\n# Now, in order to use the token, you have to intialize the module!\npc.Initialize()\n", "task": "Initialize the `pc` object.  Make sure the following variables are defined: [].", "exec_path": "easystac-main", "context": "import easystac.planetary as pc\n", "functions": ["pc.Initialize"], "external_vars": ["pc"], "defined_vars": [], "parameters": [], "libraries": ["import easystac.planetary as pc"]}
{"code": "\ndata.keys()\n\n#\n", "task": "Retrieve the keys of the dictionary stored in the variable `data`. **Note: You must define the `data` variable before running this instruction.**", "exec_path": "gemgis-main", "context": "import gemgis as gg\nfile_path = 'data/15_opening_leapfrog_meshes_and_gocad_tsurfaces/'\ndata = gg.raster.read_msh(file_path + 'GM_Granodiorite.msh')\n", "functions": ["data.keys"], "external_vars": ["data"], "defined_vars": [], "parameters": [], "libraries": ["import gemgis as gg"]}
{"code": "\nbbox = [-118.35, 36.5, -118, 36.75]\nsearch = catalog.search(collections=\"gap\", bbox=bbox)\nitems = search.get_all_items()\nprint(f\"{len(items)} items found\")\n\n#\n", "task": "Use the `catalog` object to search for items within the bounding box defined by `bbox`.  Store the results in a variable called `search`. Then, retrieve all items from the search results and store them in a variable called `items`. Finally, print the number of items found using the `len` and `print` functions.", "exec_path": "PlanetaryComputerExamples-main", "context": "import planetary_computer\nimport pystac_client\n#\ncatalog = pystac_client.Client.open(\n    'https://planetarycomputer.microsoft.com/api/stac/v1', modifier=planetary_computer.sign_inplace)\n", "functions": ["catalog.search", "search.get_all_items", "print", "len"], "external_vars": ["catalog", "len", "print"], "defined_vars": ["bbox", "search", "items"], "parameters": ["items", "f'{len(items)} items found'"], "libraries": ["import planetary_computer", "import pystac_client"]}
{"code": "\nMap.addLayerControl()\nMap\n\n#\n\n\n", "task": "Add a layer control to the map. **[You need to define the following variables: Map]**", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.foliumap as emap\nimport geemap as emap\nMap = geemap.Map(center=[40, -100], zoom=4)\n", "functions": ["Map.addLayerControl"], "external_vars": ["Map"], "defined_vars": [], "parameters": [], "libraries": ["import geemap.foliumap as emap", "import geemap as emap", "import geemap"]}
{"code": "\nyears = [str(year) for year in range(2017, 2022)]\nyears\n\n#\n", "task": "Define a list called `years` containing strings representing the years from 2017 to 2022 using `str` and `range`.  You will need to define a variable named `year` within the list comprehension.", "exec_path": "geemap-master", "context": "", "functions": ["str", "range"], "external_vars": ["range", "str"], "defined_vars": ["years", "year"], "parameters": ["year", 2017, 2022], "libraries": []}
{"code": "\ncountries_shp = \"../data/countries.shp\"\ncountries = geemap.shp_to_ee(countries_shp)\nMap.addLayer(countries, {}, \"Countries\")\n\n#\n", "task": "Using the provided variables `Map` and `geemap`, define a variable named `countries_shp` that points to the path of a shapefile. Then, use the `geemap.shp_to_ee` function to convert this shapefile into an Earth Engine feature collection and store it in a variable named `countries`. Finally, add this feature collection to the map using the `Map.addLayer` function, providing an empty dictionary for styling and setting the layer name to \"Countries\".", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import geojson_to_ee, ee_to_geojson\nMap = geemap.Map()\n", "functions": ["geemap.shp_to_ee", "Map.addLayer"], "external_vars": ["Map", "geemap"], "defined_vars": ["countries", "countries_shp"], "parameters": ["countries_shp", "countries", "Countries", "{}"], "libraries": ["from geemap import geojson_to_ee, ee_to_geojson", "import geemap"]}
{"code": "\nMap = geemap.Map()\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\nvis_params = {\n    \"color\": \"000000\",\n    \"colorOpacity\": 1,\n    \"pointSize\": 3,\n    \"pointShape\": \"circle\",\n    \"width\": 2,\n    \"lineType\": \"solid\",\n    \"fillColorOpacity\": 0.66,\n}\n\npalette = [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"]\n\nMap.add_styled_vector(\n    states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params\n)\nMap\n\n#\n", "task": "Using the geemap and ee libraries, create a map object called \"Map\". Load the US States FeatureCollection from the TIGER database. Define a dictionary \"vis_params\" for styling, containing color, opacity, point size, shape, width, line type, and fill opacity. Define a list \"palette\" with colors for the map. Using the \"Map\" object, add a styled vector layer using the \"states\" FeatureCollection, specifying the \"NAME\" column, the \"palette\" list, and applying the \"vis_params\" dictionary. The resulting map should display the US States with different colors based on their names.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nimport geemap.colormaps as cm\n", "functions": ["geemap.Map", "ee.FeatureCollection", "Map.add_styled_vector"], "external_vars": ["ee", "geemap"], "defined_vars": ["palette", "Map", "vis_params", "states"], "parameters": ["TIGER/2018/States", "states"], "libraries": ["import geemap.colormaps as cm", "import ee", "import geemap"]}
{"code": "\norientations2 = gpd.read_file(file_path + 'interfaces15.shp')\norientations2 = orientations2[orientations2['formation']=='Shale']\norientations2\n\n#\n", "task": "Read the shapefile \"interfaces15.shp\" located at the path `file_path` using the `gpd.read_file` function and store the result in a variable called `orientations2`. Then, filter `orientations2` to only include entries where the \"formation\" column is equal to \"Shale\" and overwrite `orientations2` with the filtered result.", "exec_path": "gemgis-main", "context": "import geopandas as gpd\nfile_path = 'data/example15/'\n", "functions": ["gpd.read_file"], "external_vars": ["file_path", "gpd"], "defined_vars": ["orientations2"], "parameters": ["file_path + 'interfaces15.shp'"], "libraries": ["import geopandas as gpd"]}
{"code": "\nm = leafmap.Map(center=[0, 0], zoom=2)\nin_geojson = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cable_geo.geojson\"\nm.add_geojson(in_geojson, layer_name=\"Cable lines\")\nm\n\n#\n", "task": "Using the `leafmap` library, create a map centered at coordinates [0, 0] with a zoom level of 2. Define a variable `in_geojson` to store the URL of a GeoJSON file containing cable line data. Add this GeoJSON data to the map as a layer named \"Cable lines\".", "exec_path": "leafmap-master", "context": "import leafmap\n", "functions": ["leafmap.Map", "m.add_geojson"], "external_vars": ["leafmap"], "defined_vars": ["m", "in_geojson"], "parameters": ["in_geojson"], "libraries": ["import leafmap"]}
{"code": "\n# Fetch the collection of interest and print available items\nfor name, number in months.items():\n    datetime = f\"{year}-{number}\"\n    search = catalog.search(\n        collections=[\"modis-11A1-061\"],\n        bbox=bbox,\n        datetime=datetime,\n    )\n    items[name] = search.get_all_items()[0]\n\nprint(items)\n\n#\n", "task": "For each month (name, number) in the `months` dictionary, construct a datetime string by concatenating the `year` and `number` variables. Use the `catalog.search` function to search for data in the `modis-11A1-061` collection within the specified bounding box (`bbox`) and the constructed datetime. Assign the first item from the search results to the `items` dictionary using the month name as the key. After processing all months, print the `items` dictionary. **You will need to define the following variables:** `name`, `number`, `search`, and `datetime`.", "exec_path": "PlanetaryComputerExamples-main", "context": "import planetary_computer\nimport pystac_client\n#\ncatalog = pystac_client.Client.open(\n    'https://planetarycomputer.microsoft.com/api/stac/v1', modifier=planetary_computer.sign_inplace)\n# Boise, Idaho\nlatitude = 43.6\nlongitude = -116.2\nbuffer = 1\nbbox = [longitude - buffer, latitude - buffer,\n        longitude + buffer, latitude + buffer]\nyear = '2021'\nmonths = {'March': '03', 'June': '06', 'September': '09', 'December': '12'}\nitems = dict()\n", "functions": ["months.items", "catalog.search", "search.get_all_items", "print"], "external_vars": ["print", "catalog", "bbox", "months", "year", "items"], "defined_vars": ["number", "name", "datetime", "search"], "parameters": ["items"], "libraries": ["import planetary_computer", "import pystac_client"]}
{"code": "\nm = geemap.Map()\nroi = ee.Geometry.BBox(113.8252, 22.1988, 114.0851, 22.3497)\nm.add_layer(roi)\nm.center_object(roi)\nm\n\n#\n", "task": "Using the geemap and ee libraries, define a variable named \"m\" as a geemap.Map object. Then, define a variable named \"roi\" as an ee.Geometry.BBox object with coordinates (113.8252, 22.1988, 114.0851, 22.3497). Add the \"roi\" to the map \"m\" as a layer and center the map on \"roi\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map", "ee.Geometry.BBox", "m.add_layer", "m.center_object"], "external_vars": ["ee", "geemap"], "defined_vars": ["m", "roi"], "parameters": [113.8252, 22.1988, 114.0851, 22.3497, "roi", "roi"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nm = geemap.Map()\nm.add_basemap(\"Esri.WorldImagery\")\nvis_params = {\"min\": 0, \"max\": 0.3, \"bands\": [\"NIR\", \"Red\", \"Green\"]}\nm.add_layer(image, vis_params, \"Image\")\nm.add_layer(landcover.clip(region), {}, \"NALCMS land cover\", False)\n# m.add_legend(title='Land Cover Type', legend_dict=legend_dict, layer_name='NALCMS land cover')\nm.center_object(region, 9)\nm\n\n#\n", "task": "Using the geemap library, create a map object named \"m\" and add the \"Esri.WorldImagery\" basemap. Define a dictionary called \"vis_params\" with values for \"min\", \"max\", and \"bands\" as specified. Add the \"image\" layer to the map with the defined \"vis_params\" and label it \"Image\".  Add the \"landcover\" layer, clipped to the \"region\", as a layer labelled \"NALCMS land cover\", but do not display it. Finally, center the map on the \"region\" with a zoom level of 9.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap import cartoee\nlandcover = ee.Image('USGS/NLCD_RELEASES/2020_REL/NALCMS')\nregion = ee.Geometry.BBox(-149.352, 64.5532, -147.0976, 65.1277)\ncollection = geemap.landsat_timeseries(\n    region, start_year=2021, end_year=2021, start_date='06-01', end_date='09-01')\nimage = collection.first()\n", "functions": ["geemap.Map", "m.add_basemap", "m.add_layer", "m.add_layer", "landcover.clip", "m.center_object"], "external_vars": ["image", "region", "geemap", "landcover"], "defined_vars": ["m", "vis_params"], "parameters": ["Esri.WorldImagery", "image", "vis_params", "Image", "NALCMS land cover", false, "region", "region", 9, "landcover.clip(region)", "{}"], "libraries": ["from geemap import cartoee", "import ee", "import geemap"]}
{"code": "\ngeemap.ee_export_image_to_drive(\n    image, description=\"landsat\", folder=\"export\", region=region, scale=30\n)\n\n#\n", "task": "Export the image to Google Drive using geemap. The image should be named \"landsat\" and placed in the \"export\" folder. The region of interest should be defined by the `region` variable, and the scale of the exported image should be set to 30 meters. You need to define the `image` and `region` variables before running this code.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\nimage = ee.Image(\n    'LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318').select(['B5', 'B4', 'B3'])\nregion = ee.Geometry.BBox(-122.5955, 37.5339, -122.0982, 37.8252)\n", "functions": ["geemap.ee_export_image_to_drive"], "external_vars": ["image", "geemap", "region"], "defined_vars": [], "parameters": ["image"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "import geemap", "import ee", "from geemap.datasets import DATA"]}
{"code": "\n# Instantiate the data generator class and fit it to set the data region.\nsynth = vd.synthetic.CheckerBoard()\n#\n", "task": "Using the `vd` library, create a new CheckerBoard object and assign it to the variable `synth`.", "exec_path": "verde-main", "context": "import verde as vd\n", "functions": ["vd.synthetic.CheckerBoard"], "external_vars": ["vd"], "defined_vars": ["synth"], "parameters": [], "libraries": ["import verde as vd"]}
{"code": "\n# In[ ]:\n\n#\n# Use the drawing tool to draw any line on the map.\nline = Map.user_roi\nif line is None:\n    line = ee.Geometry.LineString(\n        [[-120.223279, 36.314849], [-118.926969, 36.712192], [-117.202217, 36.756215]]\n    )\n    Map.addLayer(line, {}, \"ROI\")\nMap.centerObject(line)\n\n#\n", "task": "Using the provided `Map` and `ee` objects, define a variable named `line`.  If `line` is `None`, create a new `ee.Geometry.LineString` object using the provided coordinates and add it as a layer to the `Map` with the label \"ROI\". Finally, center the `Map` on the `line` object.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\n#\nMap = geemap.Map()\n", "functions": ["ee.Geometry.LineString", "Map.addLayer", "Map.centerObject"], "external_vars": ["ee", "Map"], "defined_vars": ["line"], "parameters": ["line", "ROI", "line", "[[-120.223279, 36.314849], [-118.926969, 36.712192], [-117.202217, 36.756215]]", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "\ntopo.plot(column='Z', aspect=1, legend=True, cmap='gist_earth')\n\n#\n", "task": "Using the \"topo\" object, create a plot where the \"Z\" column is used for the visualization. Set the plot aspect ratio to 1, include a legend, and use the \"gist_earth\" colormap. **[Make sure the \"topo\" object is defined before running this instruction.]**", "exec_path": "gemgis_data-main", "context": "import geopandas as gpd\n#\nfile_path = 'data/example16_all_features/'\ntopo = gpd.read_file(file_path + 'topo16.shp')\n", "functions": ["topo.plot"], "external_vars": ["topo"], "defined_vars": [], "parameters": [], "libraries": ["import geopandas as gpd"]}
{"code": "\n# For one-line function, you can also use a [lambda function](https://www.w3schools.com/python/python_lambda.asp), which is a small anonymous function. \n#\n# In[ ]:\n\n#\n# Load a Landsat 8 collection for a single path-row.\ncollection = (\n    ee.ImageCollection(\"LANDSAT/LC08/C01/T1_TOA\")\n    .filter(ee.Filter.eq(\"WRS_PATH\", 44))\n    .filter(ee.Filter.eq(\"WRS_ROW\", 34))\n)\n\nfirst = collection.map(\n    lambda image: image.addBands(image.metadata(\"system:time_start\"))\n).first()\n#\n", "task": "Using the ee library, define a variable called `collection` to contain an image collection of Landsat 8 data (collection ID: `LANDSAT/LC08/C01/T1_TOA`). Filter the collection for path 44 and row 34. Then, define a variable called `first` that represents the first image in the collection after mapping a function to add the system start time as a band.  Use `image` as the input to the mapping function.", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.foliumap as emap\nimport geemap as emap\nimport ee\nee.Initialize()\nMap = geemap.Map(center=[40, -100], zoom=4)\n", "functions": ["unknown_function.filter", "unknown_function.filter", "ee.ImageCollection", "ee.Filter.eq", "ee.Filter.eq", "unknown_function.first", "collection.map", "image.addBands", "image.metadata"], "external_vars": ["ee", "image"], "defined_vars": ["collection", "first"], "parameters": ["LANDSAT/LC08/C01/T1_TOA", "WRS_PATH", 44, "WRS_ROW", 34, "system:time_start", "ee.Filter.eq('WRS_ROW', 34)", "ee.Filter.eq('WRS_PATH', 44)", "lambda image: image.addBands(image.metadata('system:time_start'))", "image.metadata('system:time_start')"], "libraries": ["import geemap.foliumap as emap", "import geemap as emap", "import ee", "import geemap"]}
{"code": "\nlen(geemap.basemaps)\n\n#\n", "task": "Get the number of basemaps available in the geemap library.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\n", "functions": ["len"], "external_vars": ["len", "geemap"], "defined_vars": [], "parameters": ["geemap.basemaps"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\n# Zoom to an area of interest.\nMap.setCenter(-121.069, 50.709, 6)\n#\n", "task": "Center the map on the coordinates -121.069 longitude and 50.709 latitude with a zoom level of 6. You will need to define the following variables: [Map].", "exec_path": "geemap-master", "context": "import geemap.foliumap as geemap\n# Create a map centered at (lat, lon).\nMap = geemap.Map(center=[40, -100], zoom=4)\n", "functions": ["Map.setCenter"], "external_vars": ["Map"], "defined_vars": [], "parameters": [50.709, 6, "-121.069"], "libraries": ["import geemap.foliumap as geemap"]}
{"code": "\nsample = gg.raster.sample_randomly(raster=raster,\n                                   n=1)\n\nsample\n\n#\n", "task": "Using the `gg` library, randomly sample one pixel from the `raster` and assign it to the variable `sample`.", "exec_path": "gemgis-main", "context": "import gemgis as gg\nimport rasterio\nfile_path = 'data/06_sampling_from_rasters/'\nraster = rasterio.open(file_path + 'raster.tif')\n", "functions": ["gg.raster.sample_randomly"], "external_vars": ["raster", "gg"], "defined_vars": ["sample"], "parameters": [], "libraries": ["import gemgis as gg", "import rasterio"]}
{"code": "\nMap = geemap.Map(center=[40, -100], zoom=4)\ndem = ee.Image(\"USGS/3DEP/10m\")\nvis = {\"min\": 0, \"max\": 4000, \"palette\": \"terrain\"}\nMap.addLayer(dem, vis, \"DEM\")\nMap\n\n#\n", "task": "Using the geemap and ee libraries, create a map centered at coordinates [40, -100] with a zoom level of 4. Define variables named `dem`, `Map`, and `vis` to represent an Earth Engine image, the map object, and visualization parameters, respectively.  Load the `USGS/3DEP/10m` digital elevation model (DEM) into the `dem` variable. Set the visualization parameters for the DEM to have a minimum value of 0, a maximum value of 4000, and use the \"terrain\" color palette. Add the DEM to the map with the specified visualization parameters and label it \"DEM\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimage = ee.ImageCollection('COPERNICUS/S2').filterDate('2018-09-01',\n                                                       '2018-09-30').map(lambda img: img.divide(10000)).median()\n", "functions": ["geemap.Map", "ee.Image", "Map.addLayer"], "external_vars": ["ee", "geemap"], "defined_vars": ["dem", "Map", "vis"], "parameters": ["USGS/3DEP/10m", "dem", "vis", "DEM"], "libraries": ["from geemap.datasets import get_metadata", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nm = geemap.Map()\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nfc = states.filter(ee.Filter.inList(\"NAME\", [\"California\", \"Oregon\", \"Washington\"]))\nm.add_layer(fc, {}, \"West Coast\")\nm.center_object(fc, 5)\nm\n\n#\n", "task": "Using the ee and geemap libraries, create a map object named \"m\". Define a variable \"states\" as an ee.FeatureCollection representing US states from the \"TIGER/2018/States\" dataset. Then, filter \"states\" to create a new FeatureCollection \"fc\" containing only California, Oregon, and Washington. Finally, add \"fc\" as a layer to \"m\" with the label \"West Coast\" and center the map on \"fc\" with a zoom level of 5.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map", "ee.FeatureCollection", "states.filter", "ee.Filter.inList", "m.add_layer", "m.center_object"], "external_vars": ["ee", "geemap"], "defined_vars": ["m", "fc", "states"], "parameters": ["TIGER/2018/States", "NAME", "fc", "West Coast", "fc", 5, "ee.Filter.inList('NAME', ['California', 'Oregon', 'Washington'])", "['California', 'Oregon', 'Washington']", "{}"], "libraries": ["from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nm = geemap.Map()\n\n#\n", "task": "Create a new Geemap map object and assign it to the variable `m`.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["m"], "parameters": [], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nlayers = [\"ROADMAP\", \"HYBRID\"]\nleafmap.linked_maps(rows=1, cols=2, height=\"400px\", layers=layers)\n\n#\n", "task": "Using the `leafmap` library, create a linked map display with two maps arranged in a single row. Each map should have a height of 400 pixels. Ensure that the `layers` variable is defined before executing this code.  ", "exec_path": "leafmap-master", "context": "import leafmap.leafmap as leafmap\n", "functions": ["leafmap.linked_maps"], "external_vars": ["leafmap"], "defined_vars": ["layers"], "parameters": [], "libraries": ["import leafmap.leafmap as leafmap"]}
{"code": "\nMap = geemap.Map()\n\nee_class_table = \"\"\"\n\nValue\tColor\tDescription\n0\t1c0dff\tWater\n1\t05450a\tEvergreen needleleaf forest\n2\t086a10\tEvergreen broadleaf forest\n3\t54a708\tDeciduous needleleaf forest\n4\t78d203\tDeciduous broadleaf forest\n5\t009900\tMixed forest\n6\tc6b044\tClosed shrublands\n7\tdcd159\tOpen shrublands\n8\tdade48\tWoody savannas\n9\tfbff13\tSavannas\n10\tb6ff05\tGrasslands\n11\t27ff87\tPermanent wetlands\n12\tc24f44\tCroplands\n13\ta5a5a5\tUrban and built-up\n14\tff6d4c\tCropland/natural vegetation mosaic\n15\t69fff8\tSnow and ice\n16\tf9ffa4\tBarren or sparsely vegetated\n254\tffffff\tUnclassified\n\n\"\"\"\n\nlandcover = ee.Image(\"MODIS/006/MCD12Q1/2013_01_01\").select(\"LC_Type1\")\nigbpLandCoverVis = {\n    \"min\": 1.0,\n    \"max\": 17.0,\n    \"palette\": [\n        \"05450a\",\n        \"086a10\",\n        \"54a708\",\n        \"78d203\",\n        \"009900\",\n        \"c6b044\",\n        \"dcd159\",\n        \"dade48\",\n        \"fbff13\",\n        \"b6ff05\",\n        \"27ff87\",\n        \"c24f44\",\n        \"a5a5a5\",\n        \"ff6d4c\",\n        \"69fff8\",\n        \"f9ffa4\",\n        \"1c0dff\",\n    ],\n}\n\nMap.setCenter(6.746, 46.529, 2)\nMap.addLayer(landcover, igbpLandCoverVis, \"MODIS Land Cover\")\n\nlegend_dict = geemap.legend_from_ee(ee_class_table)\nMap.add_legend(title=\"MODIS Global Land Cover\", legend_dict=legend_dict)\n\nMap.addLayerControl()\n\nMap\n", "task": "Using the `ee` and `geemap` libraries, create a map centered at coordinates (6.746, 46.529) with a zoom level of 2. Display the MODIS Land Cover for 2013-01-01 using the `landcover` variable, which should be defined as an `ee.Image` object representing the MODIS/006/MCD12Q1 dataset. Utilize the `igbpLandCoverVis` dictionary (predefined) for visualization. Add a legend using `geemap.legend_from_ee()` and the `ee_class_table` variable (also predefined). Finally, add a layer control to the map. Note that you need to define the `igbpLandCoverVis`, `Map`, `landcover`, `legend_dict`, and `ee_class_table` variables before executing the code.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap.foliumap as geemap\n", "functions": ["geemap.Map", "unknown_function.select", "ee.Image", "Map.setCenter", "Map.addLayer", "geemap.legend_from_ee", "Map.add_legend", "Map.addLayerControl"], "external_vars": ["ee", "geemap"], "defined_vars": ["Map", "legend_dict", "ee_class_table", "landcover", "igbpLandCoverVis"], "parameters": ["LC_Type1", "MODIS/006/MCD12Q1/2013_01_01", 6.746, 46.529, 2, "landcover", "igbpLandCoverVis", "MODIS Land Cover", "ee_class_table"], "libraries": ["import geemap.foliumap as geemap", "import ee"]}
{"code": "\n# %%\n# We can plot the vector in its new projection.\n\nvect_reproj.plot(ax=\"new\", fc=\"none\", ec=\"tab:purple\", lw=3)\n#\n", "task": "Plot the reprojected vector `vect_reproj` on a new axes with no fill, a purple outline, and a line width of 3. **Make sure to define the following variables:** []", "exec_path": "geoutils-main", "context": "import geoutils as gu\n# sphinx_gallery_thumbnail_number = 3\nfilename_rast = gu.examples.get_path('everest_landsat_b4_cropped')\nfilename_vect = gu.examples.get_path('everest_rgi_outlines')\nrast = gu.Raster(filename_rast)\nvect = gu.Vector(filename_vect)\n# to :func:`~geoutils.Vector.reproject`. See :ref:`core-match-ref` for more details.\nvect_reproj = vect.reproject(rast)\n", "functions": ["vect_reproj.plot"], "external_vars": ["vect_reproj"], "defined_vars": [], "parameters": [], "libraries": ["import geoutils as gu"]}
{"code": "\n# add scale bar\ncartoee.add_scale_bar_lite(\n    ax, length=10, xy=(0.1, 0.05), fontsize=20, color=\"white\", unit=\"km\"\n)\n\nax.set_title(label=\"Landsat False Color Composite (Band 5/4/3)\", fontsize=15)\n#\n", "task": "Using the `cartoee` library, add a scale bar to the axes object `ax` with a length of 10 km, positioned at (0.1, 0.05), a font size of 20, white color, and \"km\" as the unit. Then set the title of the plot to \"Landsat False Color Composite (Band 5/4/3)\" with a font size of 15. You will need to define the following variables: `ax` (matplotlib axes object), `cartoee` (CartoEE library).", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nimport ee\nee.Initialize()\nvis_params = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}\n# This property of the table stores the land cover labels.\nlabel = 'landcover'\nregion = [-180, -60, 180, 85]\n# get a landsat image to visualize\nimage = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')\n# define the visualization parameters to view\nvis = {'bands': ['B5', 'B4', 'B3'], 'min': 0, 'max': 5000, 'gamma': 1.3}\n# formatted a [W,S,E,N]\nzoom_region = [-122.6265, 37.3458, -121.8025, 37.9178]\n# plot the map over the region of interest\nax = cartoee.get_map(image, vis_params=vis, region=zoom_region)\n", "functions": ["cartoee.add_scale_bar_lite", "ax.set_title"], "external_vars": ["ax", "cartoee"], "defined_vars": [], "parameters": ["ax"], "libraries": ["import ee", "import geemap", "from geemap import cartoee", "from geemap.datasets import DATA"]}
{"code": "\npath_raster = \"data/01_machine_learning/LC08_232066_20190727_SR.tif\"\nimg = rasterio.open(path_raster)\n#\n", "task": "Using the rasterio library, open the raster image located at the path specified by the variable `path_raster` and store the resulting rasterio dataset object in the variable `img`.", "exec_path": "scikit-eo-main", "context": "import rasterio\n", "functions": ["rasterio.open"], "external_vars": ["rasterio"], "defined_vars": ["img", "path_raster"], "parameters": ["path_raster"], "libraries": ["import rasterio"]}
{"code": "\n# ## Download a sample image\nbbox = m.user_roi_bounds()\nif bbox is None:\n    bbox = [-118.4932, 34.0404, -118.4903, 34.0417]\n", "task": "Using the variable `m`, get the user-defined region of interest (ROI) bounds and store them in the variable `bbox`. If the bounds are not defined, set `bbox` to the default coordinates [-118.4932, 34.0404, -118.4903, 34.0417].", "exec_path": "segment-geospatial-main", "context": "import leafmap\nm = leafmap.Map(center=[34.040984, -118.491668], zoom=19, height='600px')\n", "functions": ["m.user_roi_bounds"], "external_vars": ["m"], "defined_vars": ["bbox"], "parameters": [], "libraries": ["import leafmap"]}
{"code": "\nMap = geemap.Map()\nMap\n\n#\n", "task": "Using the geemap library, create a new Map object and assign it to the variable Map.", "exec_path": "geemap-master", "context": "import geemap\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import geemap"]}
{"code": "\nm = leafmap.Map(center=[20, 0], zoom=2, height=\"800px\")\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_basemap(\"Esri.WorldImagery\", show=False)\n\nstyle = {\n    \"version\": 8,\n    \"sources\": {\n        \"example_source\": {\n            \"type\": \"vector\",\n            \"url\": \"pmtiles://\" + url,\n            \"attribution\": \"PMTiles\",\n        }\n    },\n    \"layers\": [\n        {\n            \"id\": \"buildings\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"building_footprints\",\n            \"type\": \"fill\",\n            \"paint\": {\"fill-color\": \"#3388ff\", \"fill-opacity\": 0.5},\n        },\n    ],\n}\n#\n", "task": "Using the leafmap library, create a map centered at coordinates [20, 0] with a zoom level of 2 and a height of 800 pixels. Add the CartoDB.DarkMatter basemap. Also, add the Esri.WorldImagery basemap but hide it.  Define a style dictionary containing the following properties: \\n version: 8 \\n sources: \\n  example_source: \\n    type: vector \\n    url: pmtiles:// plus the url variable \\n    attribution: PMTiles  \\n layers: \\n  id: buildings \\n  source: example_source \\n  source-layer: building_footprints \\n  type: fill \\n  paint: \\n    fill-color: #3388ff \\n    fill-opacity: 0.5 \\n Define the variables \"m\" and \"style\" to store the map object and style dictionary respectively.", "exec_path": "leafmap-master", "context": "import leafmap.foliumap as leafmap\nurl = 'https://data.source.coop/vida/google-microsoft-open-buildings/pmtiles/go_ms_building_footprints.pmtiles'\n", "functions": ["leafmap.Map", "m.add_basemap", "m.add_basemap"], "external_vars": ["leafmap", "url"], "defined_vars": ["m", "style"], "parameters": ["CartoDB.DarkMatter", "Esri.WorldImagery"], "libraries": ["import leafmap.foliumap as leafmap"]}
{"code": "\n# create a new equal Earth projection focused on the Pacific\nprojection = ccrs.EqualEarth(central_longitude=-180)\n#\n", "task": "Using the `ccrs` library, define a variable named `projection` as a cartopy EqualEarth projection with a central longitude of -180 degrees.", "exec_path": "geemap-master", "context": "import cartopy.crs as ccrs\n", "functions": ["ccrs.EqualEarth"], "external_vars": ["ccrs"], "defined_vars": ["projection"], "parameters": [], "libraries": ["import cartopy.crs as ccrs"]}
{"code": "\n# Specify region by GeoJSON, define palette, set size of the larger aspect dimension.\nthumbnail2 = image.getThumbURL(\n    {\n        \"min\": 0,\n        \"max\": 3000,\n        \"palette\": [\n            \"00A600\",\n            \"63C600\",\n            \"E6E600\",\n            \"E9BD3A\",\n            \"ECB176\",\n            \"EFC2B3\",\n            \"F2F2F2\",\n        ],\n        \"dimensions\": 500,\n        \"region\": ee.Geometry.Rectangle([-84.6, -55.9, -32.9, 15.7]),\n    }\n)\nprint(\"GeoJSON region, palette, and max dimension:\", thumbnail2)\n", "task": "Using the \"image\" object, obtain the thumbnail URL with a specified color palette, region, and maximum dimension. Define a variable named \"thumbnail2\" to store the resulting URL. Utilize the \"ee\" module to define the region as a rectangle with the provided coordinates. Finally, use the \"print\" function to output the \"thumbnail2\" URL along with a descriptive message.", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.foliumap as emap\nimport geemap as emap\nimport ee\nee.Initialize()\n# Fetch a digital elevation model.\nimage = ee.Image('CGIAR/SRTM90_V4')\n", "functions": ["image.getThumbURL", "ee.Geometry.Rectangle", "print"], "external_vars": ["ee", "image", "print"], "defined_vars": ["thumbnail2"], "parameters": ["GeoJSON region, palette, and max dimension:", "thumbnail2", "{'min': 0, 'max': 3000, 'palette': ['00A600', '63C600', 'E6E600', 'E9BD3A', 'ECB176', 'EFC2B3', 'F2F2F2'], 'dimensions': 500, 'region': ee.Geometry.Rectangle([-84.6, -55.9, -32.9, 15.7])}", "[-84.6, -55.9, -32.9, 15.7]"], "libraries": ["import geemap.foliumap as emap", "import geemap as emap", "import ee", "import geemap"]}
{"code": "\n# Exemplary variogram data (e.g. estimated from field observations)\nbins = [1.0, 3.0, 5.0, 7.0, 9.0, 11.0]\nest_vario = [0.2, 0.5, 0.6, 0.8, 0.8, 0.9]\n# fitting model\nmodel = Stab(dim=2)\n# we have to provide boundaries for the parameters\nmodel.set_arg_bounds(alpha=[0, 3])\nresults, pcov = model.fit_variogram(bins, est_vario, nugget=False)\nprint(\"Results:\", results)\n#\n", "task": "Define the variables `bins`, `est_vario`, and `model` with `model` instantiated as a `Stab` object with a dimension of 2. Then, set the alpha argument bounds of `model` to [0, 3]. Finally, use the `model.fit_variogram` method to fit a variogram to the provided data, then store the results in the `results` and `pcov` variables and print the `results`. You will need the `Stab` class and the `print` function for this task.", "exec_path": "GSTools", "context": "import gstools as gs\nimport numpy as np\n\n\nclass Stab(gs.CovModel):\n\n    def default_opt_arg(self):\n        return {'alpha': 1.5}\n\n    def cor(self, h):\n        return np.exp(-h ** self.alpha)\n", "functions": ["Stab", "model.set_arg_bounds", "model.fit_variogram", "print"], "external_vars": ["print", "Stab"], "defined_vars": ["model", "est_vario", "bins", "results", "pcov"], "parameters": ["bins", "est_vario", "Results:", "results"], "libraries": ["import numpy as np", "import gstools as gs"]}
{"code": "\ngeemap.ee_to_shp(fc, filename=\"Germany.shp\", selectors=None)\n\n#\n", "task": "Using the geemap library, convert the Earth Engine FeatureCollection `fc` to a shapefile named \"Germany.shp\".  You may need to define `fc` as an Earth Engine FeatureCollection.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nfc = ee.FeatureCollection(\n    'USDOS/LSIB_SIMPLE/2017').filter(ee.Filter.eq('country_na', 'Germany'))\n", "functions": ["geemap.ee_to_shp"], "external_vars": ["geemap", "fc"], "defined_vars": [], "parameters": ["fc"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nm = geemap.Map(basemap=\"Esri.WorldImagery\")\nm\n\n#\n", "task": "Using the `geemap` library, create a map object named `m` with the basemap set to \"Esri.WorldImagery\".", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["m"], "parameters": [], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nlat_grid = geemap.latitude_grid(step=5.0, west=-180, east=180, south=-85, north=85)\n\n#\n", "task": "Using the geemap library, define a variable called lat_grid that represents a latitude grid with a step size of 5.0 degrees, spanning from -180 degrees west to 180 degrees east, and from -85 degrees south to 85 degrees north.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.latitude_grid"], "external_vars": ["geemap"], "defined_vars": ["lat_grid"], "parameters": [], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nout_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\n\n#\n", "task": "Using the `os` library, define a variable named `out_dir` that represents the path to the \"Downloads\" directory in the user's home directory.  If the `out_dir` directory does not exist, create it.", "exec_path": "geemap-master", "context": "import os\n", "functions": ["os.path.join", "os.path.expanduser", "os.path.exists", "os.makedirs"], "external_vars": ["os"], "defined_vars": ["out_dir"], "parameters": ["Downloads", "~", "out_dir", "out_dir", "os.path.expanduser('~')"], "libraries": ["import os"]}
{"code": "\nwms_map = gg.web.load_as_map(url=wms.url,\n                             layer='OSM-WMS', \n                             style='default', \n                             crs='EPSG:4647', \n                             bbox=[32286000,32328000, 5620000,5648000],\n                             size=[4200, 2800], \n                             filetype='image/png')\n\n#\n", "task": "Using the `gg` and `wms` variables, load a WMS map from the provided URL and define a variable called `wms_map` to store the loaded map.", "exec_path": "gemgis-main", "context": "import gemgis as gg\n#\nwms = gg.web.load_wms(url='https://ows.terrestris.de/osm/service?')\n", "functions": ["gg.web.load_as_map"], "external_vars": ["wms", "gg"], "defined_vars": ["wms_map"], "parameters": [], "libraries": ["import gemgis as gg"]}
{"code": "\nm = leafmap.Map()\n\n#\n", "task": "Create a new map object using the `leafmap` library and assign it to the variable `m`.", "exec_path": "leafmap-master", "context": "import leafmap.plotlymap as leafmap\n", "functions": ["leafmap.Map"], "external_vars": ["leafmap"], "defined_vars": ["m"], "parameters": [], "libraries": ["import leafmap.plotlymap as leafmap"]}
{"code": "\n# Split the data into a training and testing set. We'll use the training set to\n# grid the data and the testing set to validate our spline model. Weights need\n# to 1/uncertainty**2 for the error propagation in BlockMean to work.\ntrain, test = vd.train_test_split(\n    projection(*coordinates),\n    data.velocity_up,\n    weights=1 / data.std_up**2,\n    random_state=0,\n)\n# Fit the model on the training set\nchain.fit(*train)\n# And calculate an R^2 score coefficient on the testing set. The best possible\n# score (perfect prediction) is 1. This can tell us how good our spline is at\n# predicting data that was not in the input dataset.\nscore = chain.score(*test)\nprint(\"\\nScore: {:.3f}\".format(score))\n#\n", "task": "Using the provided variables: `data`, `vd`, `projection`, `chain`, `print`, and `coordinates`, split the data into training and testing sets using `vd.train_test_split`. The data to be split is the result of applying `projection` to `coordinates`, with targets being `data.velocity_up` and weights set to `1 / data.std_up ** 2`. Use a random state of 0. Fit the `chain` model on the training data and calculate the score on the testing data. Finally, print the score formatted to three decimal places.", "exec_path": "verde-main", "context": "import pyproj\nimport verde as vd\n# with the uncertainties\ndata = vd.datasets.fetch_california_gps()\ncoordinates = (data.longitude.values, data.latitude.values)\n# Use a Mercator projection for our Cartesian gridder\nprojection = pyproj.Proj(proj='merc', lat_ts=data.latitude.mean())\n# because our data vary smoothly but have different uncertainties.\nspacing = 5 / 60\nchain = vd.Chain([('mean', vd.BlockMean(spacing=spacing * 111000.0,\n                 uncertainty=True)), ('spline', vd.Spline(damping=1e-10))])\n", "functions": ["vd.train_test_split", "projection", "chain.fit", "chain.score", "print", "unknown_function.format"], "external_vars": ["coordinates", "print", "vd", "data", "projection", "chain"], "defined_vars": ["test", "train", "score"], "parameters": ["score", "projection(*coordinates)", "data.velocity_up", "*coordinates", "*train", "*test", "'\\nScore: {:.3f}'.format(score)"], "libraries": ["import pyproj", "import verde as vd"]}
{"code": "\n# Visualize everything with `geemap`:\nMap.addLayer(L8full.select(\"SAVI\"),vis,\"SAVI\")\nMap.addLayer(L8full.select(\"GNDVI\"),vis,\"GNDVI\")\nMap.centerObject(poi.centroid(1),8)\nMap\n\n\n", "task": "Add the \"SAVI\" and \"GNDVI\" bands from the `L8full` image to the `Map` using the visualization parameters defined in `vis`. Then center the map on the centroid of the `poi` feature at zoom level 8. \\n\\n**Required variables:**\\n\\n* `poi` (a feature or geometry object)\\n* `L8full` (an image object)\\n* `vis` (visualization parameters)\\n* `Map` (the Google Earth Engine Map object)", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\nimport geemap.colormaps as cm\n# Authenticate and Initialize Earth Engine and geemap.\nMap = geemap.Map()\npoi = ee.Geometry.BBoxFromQuery(\n    'Puerto Rico', user_agent='eemont-tutorial-017')\nL8 = ee.ImageCollection(\n    'LANDSAT/LC08/C01/T1_SR').filterBounds(poi).filterDate('2020-01-01', '2021-01-01')\n# The `preprocess` method automatically masks clouds and shadows and scales and offsets the image or image collection.\nL8pre = L8.preprocess(maskShadows=False)\n# After preprocessing, you can process your ee.Image or ee.ImageCollection as you want!\nL8full = L8pre.spectralIndices(['SAVI', 'GNDVI'], L=0.5).median()\n# Visualization parameters:\nvis = {'min': 0, 'max': 1, 'palette': cm.palettes.ndvi}\n", "functions": ["Map.addLayer", "L8full.select", "Map.addLayer", "L8full.select", "Map.centerObject", "poi.centroid"], "external_vars": ["vis", "poi", "Map", "L8full"], "defined_vars": [], "parameters": ["vis", "SAVI", "SAVI", "vis", "GNDVI", "GNDVI", 8, 1, "L8full.select('SAVI')", "L8full.select('GNDVI')", "poi.centroid(1)"], "libraries": ["import eemont", "import geemap.colormaps as cm", "import ee", "import geemap"]}
{"code": "\nprint('Landsat on Google cloud:')\nprint('=========================')\nfilepath = \"https://storage.googleapis.com/gcp-public-data-landsat/LC08/01/\"+ \"042/034/LC08_L1TP_042034_20170616_20170629_01_T1/LC08_L1TP_042034_20170616_20170629_01_T1_B4.TIF\"\n\nwith rasterio.open(filepath) as src:\n    print(src.profile)\n\n#\n", "task": "Print a title, \"Landsat on Google cloud:\", and a line of equals signs. Then, define a variable named \"filepath\" with the URL provided.  After that, using the \"rasterio\" library, open the file at the specified path and assign the result to a variable called \"src\". Finally, print the profile of the opened file using the \"src\" variable.", "exec_path": "pylandtemp-master", "context": "import rasterio.plot\n", "functions": ["print", "print", "rasterio.open", "print"], "external_vars": ["print", "rasterio"], "defined_vars": ["src", "filepath"], "parameters": ["Landsat on Google cloud:", "=========================", "filepath", "src.profile"], "libraries": ["import rasterio.plot"]}
{"code": "\nMap = geemap.Map(basemap=\"HYBRID\")\nMap\n\n#\n", "task": "Using the geemap library, create a new Map object named \"Map\" with the basemap set to \"HYBRID\".", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nsearch = leafmap.stac_search(\n    url=url,\n    max_items=10,\n    collections=[collection],\n    bbox=bbox,\n    datetime=time_range,\n    get_collection=True,\n)\n# search\n\n#\n", "task": "Using the `leafmap` library, perform a STAC search with the following parameters: \\n\\n* `url`:  `url` \\n* `max_items`: 10 \\n* `collections`:  `[collection]` \\n* `bbox`: `bbox`\\n* `datetime`: `time_range` \\n* `get_collection`: True \\n\\nStore the search results in a variable named `search`.", "exec_path": "leafmap-master", "context": "import leafmap\n#\nurl = 'https://earth-search.aws.element84.com/v1/'\ncollection = 'sentinel-2-l2a'\ntime_range = '2020-12-01/2020-12-31'\nbbox = [-122.2751, 47.5469, -121.9613, 47.7458]\n", "functions": ["leafmap.stac_search"], "external_vars": ["collection", "bbox", "time_range", "leafmap", "url"], "defined_vars": ["search"], "parameters": [], "libraries": ["import leafmap"]}
{"code": "\n# reversing the original colormap using reversed() function\nreversed_map_1 = col_map_1.reversed()\nreversed_map_2 = col_map_2.reversed()\n#\n", "task": "Reverse the order of the elements in `col_map_1` and store the result in a new variable called `reversed_map_1`. Similarly, reverse the order of the elements in `col_map_2` and store the result in a new variable called `reversed_map_2`.", "exec_path": "scikit-eo-main", "context": "import matplotlib as mpl\n# colormap\ncol_map_1 = mpl.colormaps['Spectral']\ncol_map_2 = mpl.colormaps['RdYlGn']\n", "functions": ["col_map_1.reversed", "col_map_2.reversed"], "external_vars": ["col_map_1", "col_map_2"], "defined_vars": ["reversed_map_1", "reversed_map_2"], "parameters": [], "libraries": ["import matplotlib as mpl"]}
{"code": "\nroi = m.user_roi\nif roi is None:\n    roi = ee.Geometry.BBox(-74.7222, -8.5867, -74.1596, -8.2824)\n    m.add_layer(roi)\n    m.center_object(roi)\n\n#\n", "task": "Define a variable named `roi` using the `m.user_roi` variable. If `roi` is `None`, set it to an `ee.Geometry.BBox` object with coordinates (-74.7222, -8.5867, -74.1596, -8.2824). Add this `roi` as a layer to `m` and center `m` on the `roi`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nm = geemap.Map()\n", "functions": ["ee.Geometry.BBox", "m.add_layer", "m.center_object"], "external_vars": ["m", "ee"], "defined_vars": ["roi"], "parameters": ["roi", "roi", "-74.7222", "-8.5867", "-74.1596", "-8.2824"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\n# %%\n# Let's plot the raster and vector. The raster has smaller extent than the vector.\nrast.plot(cmap=\"Greys_r\", alpha=0.7)\nvect.plot(ref_crs=rast, fc=\"none\", ec=\"tab:purple\", lw=3)\n#\n", "task": "Plot the raster data `rast` in grayscale with a transparency of 0.7. Overlay the vector data `vect` on top of the raster, using the raster's coordinate reference system. Style the vector data with no fill color, a purple outline, and a line width of 3 pixels.", "exec_path": "geoutils-main", "context": "import geoutils as gu\n# sphinx_gallery_thumbnail_number = 3\nfilename_rast = gu.examples.get_path('everest_landsat_b4_cropped')\nfilename_vect = gu.examples.get_path('everest_rgi_outlines')\nrast = gu.Raster(filename_rast)\nvect = gu.Vector(filename_vect)\n", "functions": ["rast.plot", "vect.plot"], "external_vars": ["rast", "vect"], "defined_vars": [], "parameters": [], "libraries": ["import geoutils as gu"]}
{"code": "\nm = leafmap.Map()\nimage = \"https://i.imgur.com/LmTETPX.png\"\nm.add_image(image, position=\"bottomright\")\nm\n\n#\n", "task": "Using the `leafmap` library, create a map object named `m`. Then, define a variable `image` with the URL \"https://i.imgur.com/LmTETPX.png\". Finally, add the image to the map at the bottom right corner using the `add_image` method.", "exec_path": "leafmap-master", "context": "import leafmap\n", "functions": ["leafmap.Map", "m.add_image"], "external_vars": ["leafmap"], "defined_vars": ["m", "image"], "parameters": ["image"], "libraries": ["import leafmap"]}
{"code": "\nleafmap.stac_tile(url, bands=[\"B3\", \"B2\", \"B1\"])\n\n#\n", "task": "Using the `leafmap` library and the `url` variable, display a STAC tile with bands B3, B2, and B1.  Make sure to define the `leafmap` and `url` variables before running this code.", "exec_path": "leafmap-master", "context": "import leafmap\nurl = 'https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json'\n", "functions": ["leafmap.stac_tile"], "external_vars": ["leafmap", "url"], "defined_vars": [], "parameters": ["url"], "libraries": ["import leafmap"]}
{"code": "\nregion = ee.Geometry.Polygon(\n    [\n        [\n            [-99.101934, 47.12745],\n            [-99.101934, 47.156232],\n            [-99.033441, 47.156232],\n            [-99.033441, 47.12745],\n            [-99.101934, 47.12745],\n        ]\n    ]\n)\n\n#\n", "task": "Define a variable named `region` using the `ee.Geometry.Polygon` function to create a polygon geometry with the specified coordinates. The variable `ee` is assumed to be defined and refers to the Earth Engine library.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee"], "defined_vars": ["region"], "parameters": ["[[[-99.101934, 47.12745], [-99.101934, 47.156232], [-99.033441, 47.156232], [-99.033441, 47.12745], [-99.101934, 47.12745]]]"], "libraries": ["import ee", "import geemap"]}
{"code": "\nstrikes = gpd.read_file(file_path + 'strikes8.shp')\nstrikes.head()\n\n#\n", "task": "Read the shapefile \"strikes8.shp\" located at the path specified by \"file_path\" using the geopandas library (imported as \"gpd\") and store it in a variable named \"strikes\". Then, display the first few rows of the resulting dataframe.", "exec_path": "gemgis_data-main", "context": "import geopandas as gpd\n#\nfile_path = 'data/example08_faulted_layers/'\n", "functions": ["gpd.read_file", "strikes.head"], "external_vars": ["file_path", "gpd"], "defined_vars": ["strikes"], "parameters": ["file_path + 'strikes8.shp'"], "libraries": ["import geopandas as gpd"]}
{"code": "\n# Display the uniquely ID'ed objects to the Map.\nMap.addLayer(objectId.randomVisualizer(), {}, \"Objects\")\n\n#\n", "task": "Add a layer to the Map called \"Objects\" using the random visualizer from the objectId object.  You will need to define the following variables: [objectId, Map].", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.foliumap as emap\nimport geemap as emap\nimport ee\nee.Initialize()\nMap = geemap.Map(center=[40, -100], zoom=4)\n# Make an area of interest geometry centered on San Francisco.\npoint = ee.Geometry.Point(-122.1899, 37.501)\naoi = point.buffer(10000)\n# area of interest.\nkelvin = ee.Image(\n    'LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318').select(['B10'], ['kelvin']).clip(aoi)\n# Threshold the thermal band to set hot pixels as value 1 and not as 0.\nhotspots = kelvin.gt(303).selfMask().rename('hotspots')\n# Uniquely label the hotspot image objects.\nobjectId = hotspots.connectedComponents(\n    **{'connectedness': ee.Kernel.plus(1), 'maxSize': 128})\n", "functions": ["Map.addLayer", "objectId.randomVisualizer"], "external_vars": ["Map", "objectId"], "defined_vars": [], "parameters": ["Objects", "objectId.randomVisualizer()", "{}"], "libraries": ["import geemap.foliumap as emap", "import geemap as emap", "import ee", "import geemap"]}
{"code": "\nfig = plt.figure(figsize=(15, 10))\n#\n", "task": "Using the matplotlib library (`plt`), create a new figure object named `fig` with a size of 15 inches by 10 inches.", "exec_path": "geemap-master", "context": "import matplotlib.pyplot as plt\n", "functions": ["plt.figure"], "external_vars": ["plt"], "defined_vars": ["fig"], "parameters": [], "libraries": ["import matplotlib.pyplot as plt"]}
{"code": "\nstates = ee.FeatureCollection(\"TIGER/2018/States\").sort(\"ALAND\", False)\nnames = states.aggregate_array(\"STUSPS\").getInfo()\nprint(names)\n\n#\n", "task": "Using the Earth Engine library (ee), retrieve the US states by area (largest to smallest) and print their postal abbreviations. Define the variables \"states\" and \"names\" in your code.", "exec_path": "geemap-master", "context": "import geemap\nimport ee\nee.Initialize()\n", "functions": ["unknown_function.sort", "ee.FeatureCollection", "unknown_function.getInfo", "states.aggregate_array", "print"], "external_vars": ["ee", "print"], "defined_vars": ["names", "states"], "parameters": ["ALAND", false, "TIGER/2018/States", "STUSPS", "names"], "libraries": ["import ee", "import geemap"]}
{"code": "\nif os.environ.get(\"PLANET_API_KEY\") is None:\n    os.environ[\"PLANET_API_KEY\"] = \"your-api-key\"\n\n#\n", "task": "Using the `os` module, check if the environment variable `PLANET_API_KEY` is set. If not, set it to the value \"your-api-key\".", "exec_path": "leafmap-master", "context": "import os\n", "functions": ["os.environ.get"], "external_vars": ["os"], "defined_vars": [], "parameters": ["PLANET_API_KEY"], "libraries": ["import os"]}
{"code": "\ngeemap.cog_tile(url)\n\n#\n", "task": "Use the `geemap` library to create a COG tile from the URL provided. The `url` variable holds the URL of the image data.", "exec_path": "geemap-master", "context": "import geemap\nurl = 'https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif'\n", "functions": ["geemap.cog_tile"], "external_vars": ["geemap", "url"], "defined_vars": [], "parameters": ["url"], "libraries": ["import geemap"]}
{"code": "\nregion = ee.Geometry.BBox(-122.5955, 37.5339, -122.0982, 37.8252)\nfc = ee.FeatureCollection(region)\nstyle = {\"color\": \"ffff00ff\", \"fillColor\": \"00000000\"}\nm.add_layer(fc.style(**style), {}, \"ROI\")\n\n#\n", "task": "Using the Earth Engine library (`ee`) and map object (`m`), create a feature collection (`fc`) from a bounding box (`region`) defined by coordinates. Style the feature collection with a yellow outline and transparent fill, and add it to the map as a layer labeled \"ROI\".  You will need to define the variables `region`, `fc`, and `style` before running this code.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nm = geemap.Map()\n", "functions": ["ee.Geometry.BBox", "ee.FeatureCollection", "m.add_layer", "fc.style"], "external_vars": ["ee", "m"], "defined_vars": ["style", "fc", "region"], "parameters": [37.5339, 37.8252, "region", "ROI", "-122.5955", "-122.0982", "fc.style(**style)", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\ntopo = gpd.read_file(file_path + 'topo23.shp')\ntopo.head()\n\n#\n", "task": "Read the shapefile \"topo23.shp\" from the directory specified by the \"file_path\" variable using the \"gpd.read_file\" function and store the resulting GeoDataFrame in a variable named \"topo\". Then, display the first few rows of the GeoDataFrame using the \"topo.head()\" method.", "exec_path": "gemgis-main", "context": "import geopandas as gpd\nfile_path = 'data/example23/'\n", "functions": ["gpd.read_file", "topo.head"], "external_vars": ["file_path", "gpd"], "defined_vars": ["topo"], "parameters": ["file_path + 'topo23.shp'"], "libraries": ["import geopandas as gpd"]}
{"code": "\n# Note that the visualization image doesn't require visualization parameters.\nMap.addLayer(visualized, {}, \"elev palette\", False)\n#\n", "task": "Add the layer \"visualized\" to the map \"Map\" with the name \"elev palette\" and set it to be visible as False. Make sure \"visualized\" and \"Map\" are defined external variables. You will need to define the following variable: []", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap.foliumap as geemap\n# Create a map centered at (lat, lon).\nMap = geemap.Map(center=[40, -100], zoom=4)\n# Load a global elevation image.\nelev = ee.Image('USGS/GMTED2010')\n# Create a \"sea\" variable to be used for cartographic purposes\nsea = elev.lte(0)\n# Create a custom elevation palette from hex strings.\nelevationPalette = ['006600', '002200', 'fff700', 'ab7634', 'c4d0ff', 'ffffff']\n# Use these visualization parameters, customized by location.\nvisParams = {'min': 1, 'max': 3000, 'palette': elevationPalette}\n# Create a mosaic of the sea and the elevation data\nvisualized = ee.ImageCollection([elev.mask(sea.Not()).visualize(\n    **visParams), sea.mask(sea).visualize(**{'palette': '000022'})]).mosaic()\n", "functions": ["Map.addLayer"], "external_vars": ["Map", "visualized"], "defined_vars": [], "parameters": ["visualized", "elev palette", false, "{}"], "libraries": ["import geemap.foliumap as geemap", "import ee"]}
{"code": "\ngeemap.show_youtube(\"https://youtu.be/nsIjfD83ggA\")\n", "task": "Use the geemap library to display the YouTube video at the specified URL. Make sure to define the `geemap` variable before running this code.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\n", "functions": ["geemap.show_youtube"], "external_vars": ["geemap"], "defined_vars": [], "parameters": ["https://youtu.be/nsIjfD83ggA"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA"]}
{"code": "\nm = geemap.Map()\nm.split_map(left_layer=\"Esri.WorldTopoMap\", right_layer=\"OpenTopoMap\")\nm\n\n#\n", "task": "Using the geemap library, create a split map object named \"m\" where the left layer is \"Esri.WorldTopoMap\" and the right layer is \"OpenTopoMap\".", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map", "m.split_map"], "external_vars": ["geemap"], "defined_vars": ["m"], "parameters": [], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\noutput_widget = widgets.Output(layout={\"border\": \"1px solid black\"})\noutput_control = ipyleaflet.WidgetControl(widget=output_widget, position=\"bottomright\")\nMap.add_control(output_control)\n\n#\n", "task": "Using the `widgets`, `ipyleaflet`, and `Map` libraries, create an output widget with a black border. Then, create a control widget using `ipyleaflet.WidgetControl` to display the output widget in the bottom-right corner of the map. Define the variables `output_widget` and `output_control` for these widgets. Finally, add the control widget to the map using `Map.add_control()`.", "exec_path": "geemap-master", "context": "import geemap\nimport ipyleaflet\nimport ipywidgets as widgets\n#\nMap = geemap.Map(center=[37.71, 105.47], zoom=4)\n", "functions": ["widgets.Output", "ipyleaflet.WidgetControl", "Map.add_control"], "external_vars": ["Map", "widgets", "ipyleaflet"], "defined_vars": ["output_widget", "output_control"], "parameters": ["output_control"], "libraries": ["import ipyleaflet", "import ipywidgets as widgets", "import geemap"]}
{"code": "\nm.add_basemap(\"Esri.WorldTopoMap\")\n\n#\n", "task": "Add the \"Esri.WorldTopoMap\" basemap to the map object `m`.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nm = geemap.Map(basemap='Esri.WorldImagery')\n", "functions": ["m.add_basemap"], "external_vars": ["m"], "defined_vars": [], "parameters": ["Esri.WorldTopoMap"], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nfig = plt.figure(figsize=(15, 10))\n\ncmap = \"gist_earth\"  # colormap we want to use\n# cmap = \"terrain\"\n#\n", "task": "Using the imported library \"plt\", create a figure named \"fig\" with dimensions 15x10 and define a variable \"cmap\" to hold the colormap \"gist_earth\".", "exec_path": "geemap-master", "context": "import matplotlib.pyplot as plt\n", "functions": ["plt.figure"], "external_vars": ["plt"], "defined_vars": ["fig", "cmap"], "parameters": [], "libraries": ["import matplotlib.pyplot as plt"]}
{"code": "\ntimelapse = geemap.goes_timelapse(\n    roi, \"hurricane.gif\", start_date, end_date, data, scan, framesPerSecond=5\n)\ngeemap.show_image(timelapse)\n\n#\n", "task": "Using the geemap library, create a timelapse animation of GOES satellite data within the specified region of interest (roi). The animation should be saved as \"hurricane.gif\", covering the period from start_date to end_date.  The timelapse should utilize the provided data and scan information, with a frame rate of 5 frames per second. Define a variable called \"timelapse\" to store the resulting animation and then display it using geemap.show_image().", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\ndata = 'GOES-17'\nscan = 'full_disk'\nroi = ee.Geometry.BBox(-159.5954, 24.5178, -114.2438, 60.4088)\nstart_date = '2021-10-24T14:00:00'\nend_date = '2021-10-25T01:00:00'\n", "functions": ["geemap.goes_timelapse", "geemap.show_image"], "external_vars": ["roi", "scan", "data", "end_date", "geemap", "start_date"], "defined_vars": ["timelapse"], "parameters": ["roi", "hurricane.gif", "start_date", "end_date", "data", "scan", "timelapse"], "libraries": ["import ee", "import geemap"]}
{"code": "\n# The BlockKFold is compatible with scikit-learn, so instead of giving it a\n# coordinates tuple (like we use in Verde), we have to put the coordinates in a\n# feature matrix (X in scikit-learn jargon). Each column will have one of the\n# coordinate values. This is usually not required if using this cross-validator\n# with Verde functions and classes. You can pass it to verde.cross_val_score,\n# for example.\nfeature_matrix = np.transpose(coordinates)\n#\n", "task": "Using the NumPy library (`np`), transpose the `coordinates` array and store the result in a new variable called `feature_matrix`.", "exec_path": "verde-main", "context": "import numpy as np\nimport verde as vd\ndata = vd.datasets.fetch_baja_bathymetry()\ncoordinates = (data.longitude, data.latitude)\n", "functions": ["np.transpose"], "external_vars": ["coordinates", "np"], "defined_vars": ["feature_matrix"], "parameters": ["coordinates"], "libraries": ["import verde as vd", "import numpy as np"]}
{"code": "\ngeemap.ee_initialize()\n\n#\n", "task": "Initialize the Earth Engine API using the `geemap` library. Make sure to define the `geemap` variable before running this instruction.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.ee_initialize"], "external_vars": ["geemap"], "defined_vars": [], "parameters": [], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nxProperty = \"label\"\nyProperties = [str(x).zfill(2) + \"_tmean\" for x in range(1, 13)]\n\nlabels = [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\",\n]\ncolors = [\n    \"#604791\",\n    \"#1d6b99\",\n    \"#39a8a7\",\n    \"#0f8755\",\n    \"#76b349\",\n    \"#f0af07\",\n    \"#e37d05\",\n    \"#cf513e\",\n    \"#96356f\",\n    \"#724173\",\n    \"#9c4f97\",\n    \"#696969\",\n]\ntitle = \"Average Monthly Temperature by Ecoregion\"\nxlabel = \"Ecoregion\"\nylabel = \"Temperature\"\n\n#\n", "task": "Define the following variables: labels, xProperty, xlabel, x, ylabel, title, yProperties, colors. Use the external variables range and str to create a list of month names and corresponding temperature properties. The list should be formatted as \"01_tmean\", \"02_tmean\", etc. for months 1 through 12.", "exec_path": "geemap-master", "context": "", "functions": ["unknown_function.zfill", "str", "range"], "external_vars": ["range", "str"], "defined_vars": ["colors", "title", "ylabel", "yProperties", "xProperty", "x", "labels", "xlabel"], "parameters": [2, "x", 1, 13], "libraries": []}
{"code": "\n# Add US Census States\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nstyle = {\"fillColor\": \"00000000\"}\nMap.addLayer(states.style(**style), {}, \"US States\")\nMap\n\n#\n", "task": "Using the provided `ee` and `Map` objects, define a variable named `states` to represent a FeatureCollection of US States from the TIGER/2018/States dataset. Additionally, define a variable named `style` as a dictionary with a `fillColor` property set to '00000000'. Finally, add the states layer to the map with the specified style, labeled \"US States\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\nMap = geemap.Map(center=[40, -100], zoom=4)\n", "functions": ["ee.FeatureCollection", "Map.addLayer", "states.style"], "external_vars": ["ee", "Map"], "defined_vars": ["style", "states"], "parameters": ["TIGER/2018/States", "US States", "states.style(**style)", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "import geemap", "import ee", "from geemap.datasets import DATA"]}
{"code": "\n# request list of mapsets in selected location\nmapsets = actinia_mundialis.locations[\"latlong_wgs84\"].get_mapsets()\nprint_dict_keys(mapsets, \"Mapsets in latlong_wgs84:\")\n\n#\n", "task": "Use the actinia_mundialis object to get a list of mapsets from the \"latlong_wgs84\" location and store it in a variable called \"mapsets\". Then, print the keys of the mapsets dictionary using the print_dict_keys function with the message \"Mapsets in latlong_wgs84:\"", "exec_path": "leafmap-master", "context": "def print_dict_keys(input_dict, text=None):\n    if text:\n        print(text)\n    print(', '.join(input_dict.keys()))\n\n\n# connect to default actinia server (https://actinia.mundialis.de)\nactinia_mundialis = Actinia()\n# obtain the list of projects (called \"locations\") which are accessible to current user\nlocations = actinia_mundialis.get_locations()\n", "functions": ["unknown_function.get_mapsets", "print_dict_keys"], "external_vars": ["actinia_mundialis", "print_dict_keys"], "defined_vars": ["mapsets"], "parameters": ["mapsets", "Mapsets in latlong_wgs84:"], "libraries": []}
{"code": "\nm = leafmap.Map(basemap=\"stamen-toner\")\nm\n\n#\n", "task": "Using the `leafmap` library, create a new map object named `m` with the basemap set to \"stamen-toner\".", "exec_path": "leafmap-master", "context": "import leafmap.plotlymap as leafmap\n", "functions": ["leafmap.Map"], "external_vars": ["leafmap"], "defined_vars": ["m"], "parameters": [], "libraries": ["import leafmap.plotlymap as leafmap"]}
{"code": "\nroi = m.user_roi\nif roi is None:\n    roi = ee.Geometry.BBox(-74.7222, -8.5867, -74.1596, -8.2824)\n    m.add_layer(roi)\n    m.center_object(roi)\n\n#\n", "task": "If the variable `roi` is not defined, define it as a bounding box using the `ee.Geometry.BBox` function with coordinates (-74.7222, -8.5867, -74.1596, -8.2824). Then add this `roi` to the map `m` and center the map on this `roi`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nm = geemap.Map()\n", "functions": ["ee.Geometry.BBox", "m.add_layer", "m.center_object"], "external_vars": ["m", "ee"], "defined_vars": ["roi"], "parameters": ["roi", "roi", "-74.7222", "-8.5867", "-74.1596", "-8.2824"], "libraries": ["from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nm = leafmap.Map()\nin_kml = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_states.kml\"\nm.add_kml(in_kml, layer_name=\"US States KML\")\nm\n\n#\n", "task": "Using the `leafmap` library, create a map object named `m`. Then, define a variable `in_kml` with the URL to a KML file containing US states data. Finally, add the KML data to the map as a layer named \"US States KML\".", "exec_path": "leafmap-master", "context": "import leafmap\nimport leafmap.colormaps as cm\nimport leafmap.foliumap as leafmap\n", "functions": ["leafmap.Map", "m.add_kml"], "external_vars": ["leafmap"], "defined_vars": ["m", "in_kml"], "parameters": ["in_kml"], "libraries": ["import leafmap.foliumap as leafmap", "import leafmap.colormaps as cm", "import leafmap"]}
{"code": "\nroi = m.user_roi\nif roi is None:\n    roi = ee.Geometry.BBox(-99.1019, 47.1274, -99.0334, 47.1562)\n    m.add_layer(roi, {}, \"ROI\")\n    m.center_object(roi)\n\n#\n", "task": "Define a variable called `roi`. If `roi` is not defined, set it to an `ee.Geometry.BBox` object with coordinates (-99.1019, 47.1274, -99.0334, 47.1562). Then, add the `roi` as a layer to the map `m` with the label \"ROI\". Finally, center the map `m` on the `roi`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nm = geemap.Map(center=[40, -100], zoom=4)\n", "functions": ["ee.Geometry.BBox", "m.add_layer", "m.center_object"], "external_vars": ["m", "ee"], "defined_vars": ["roi"], "parameters": [47.1274, 47.1562, "roi", "ROI", "roi", "-99.1019", "-99.0334", "{}"], "libraries": ["from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nchange = gsw.select(\"change_abs\")\n\n#\n", "task": "Using the `gsw` object, select the element with the id `change_abs` and assign it to the variable `change`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nimage = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_039035_20150724')\ngsw = ee.Image('JRC/GSW1_1/GlobalSurfaceWater')\n", "functions": ["gsw.select"], "external_vars": ["gsw"], "defined_vars": ["change"], "parameters": ["change_abs"], "libraries": ["import ee", "import geemap"]}
{"code": "\nurl = \"https://github.com/opengeos/NASA-Earth-Data/raw/main/nasa_earth_data.tsv\"\ndf = pd.read_csv(url, sep=\"\\t\")\ndf\n\n#\n", "task": "Read the NASA Earth Data CSV file into a Pandas DataFrame called \"df\". Use the `pd.read_csv` function with the url variable and a tab separator.  Define the following variables: `df` and `url`.", "exec_path": "leafmap-master", "context": "import pandas as pd\n", "functions": ["pd.read_csv"], "external_vars": ["pd"], "defined_vars": ["url", "df"], "parameters": ["url"], "libraries": ["import pandas as pd"]}
{"code": "\ncatalog = pystac_client.Client.open(\n    \"https://planetarycomputer.microsoft.com/api/stac/v1\",\n    modifier=planetary_computer.sign_inplace,\n)\n\n#\n", "task": "Using the `pystac_client` and `planetary_computer` libraries, open a STAC catalog from the Planetary Computer API and store it in a variable called `catalog`.", "exec_path": "PlanetaryComputerExamples-main", "context": "import pystac_client\nimport planetary_computer\n", "functions": ["pystac_client.Client.open"], "external_vars": ["planetary_computer", "pystac_client"], "defined_vars": ["catalog"], "parameters": ["https://planetarycomputer.microsoft.com/api/stac/v1"], "libraries": ["import planetary_computer", "import pystac_client"]}
{"code": "\nm = geemap.Map()\ncollection = (\n    ee.ImageCollection(\"COPERNICUS/S2_SR\")\n    .filterDate(\"2021-01-01\", \"2022-01-01\")\n    .filter(ee.Filter.lt(\"CLOUDY_PIXEL_PERCENTAGE\", 5))\n)\nimage = collection.median()\n\nvis = {\n    \"min\": 0.0,\n    \"max\": 3000,\n    \"bands\": [\"B4\", \"B3\", \"B2\"],\n}\n\nm.set_center(83.277, 17.7009, 12)\nm.add_layer(image, vis, \"Sentinel-2\")\nm\n\n#\n", "task": "Using the ee and geemap libraries, create an interactive map (m) centered at coordinates (83.277, 17.7009) with a zoom level of 12.  Load a Sentinel-2 image collection (collection) for the year 2021, filter for images with less than 5% cloudy pixels, calculate the median image (image), and then add it to the map with the provided visualization parameters (vis).  Make sure to define the variables: m, vis, collection, and image.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map", "unknown_function.filter", "unknown_function.filterDate", "ee.ImageCollection", "ee.Filter.lt", "collection.median", "m.set_center", "m.add_layer"], "external_vars": ["ee", "geemap"], "defined_vars": ["m", "image", "vis", "collection"], "parameters": ["2021-01-01", "2022-01-01", "COPERNICUS/S2_SR", "CLOUDY_PIXEL_PERCENTAGE", 5, 83.277, 17.7009, 12, "image", "vis", "Sentinel-2", "ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 5)"], "libraries": ["from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\ninterfaces = gpd.read_file(file_path + 'interfaces10.shp')\ninterfaces.head()\n\n#\n", "task": "Using the geopandas library (`gpd`) and the provided `file_path`, read the shapefile named \"interfaces10.shp\" and store the resulting geodataframe in a variable called `interfaces`. Then, display the first few rows of the geodataframe using the `.head()` method.", "exec_path": "gemgis-main", "context": "import geopandas as gpd\nfile_path = 'data/example10/'\n", "functions": ["gpd.read_file", "interfaces.head"], "external_vars": ["file_path", "gpd"], "defined_vars": ["interfaces"], "parameters": ["file_path + 'interfaces10.shp'"], "libraries": ["import geopandas as gpd"]}
{"code": "\nintersection_gdf.plot()\nplt.grid()\n\n#\n", "task": "Plot the intersection geodataframe `intersection_gdf` and add a grid using `plt`. Make sure the variables `intersection_gdf` and `plt` are defined beforehand.", "exec_path": "gemgis-main", "context": "import gemgis as gg\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nfile_path = 'data/16_extracting_interfaces_from_geological_maps/'\ngmap = gpd.read_file(file_path + 'interfaces_polygons.shp')\nstratigraphy = ['Sand2', 'Ton', 'Sand1']\ngmap_sorted = gg.vector.sort_by_stratigraphy(\n    gdf=gmap, stratigraphy=stratigraphy)\npoly_list = [gmap_sorted.loc[1].geometry, gmap_sorted.loc[0].geometry]\nintersection = gg.vector.intersections_polygon_polygons(\n    polygon1=gmap_sorted.loc[2].geometry, polygons2=poly_list)\nintersection_gdf = gpd.GeoDataFrame(geometry=intersection)\n", "functions": ["intersection_gdf.plot", "plt.grid"], "external_vars": ["intersection_gdf", "plt"], "defined_vars": [], "parameters": [], "libraries": ["import gemgis as gg", "import geopandas as gpd", "import matplotlib.pyplot as plt"]}
{"code": "\n# Filter the LE7 collection to a single date.\ncollection = ee.ImageCollection('LANDSAT/LE07/C02/T1').filterDate(\n    datetime.datetime(2002, 11, 8), datetime.datetime(2002, 11, 9)\n)\nimage = collection.mosaic().select('B3', 'B2', 'B1')\n", "task": "Using the Earth Engine library (`ee`) and the `datetime` module, create an `ImageCollection` named `collection` containing Landsat 7 imagery from November 8th to 9th, 2002. Then, create a single `Image` named `image` by mosaicking the collection and selecting bands B3, B2, and B1.", "exec_path": "earthengine-api-master", "context": "import datetime\nimport ee\nee.Initialize()\nimport ee.mapclient\n", "functions": ["unknown_function.filterDate", "ee.ImageCollection", "datetime.datetime", "datetime.datetime", "unknown_function.select", "collection.mosaic"], "external_vars": ["ee", "datetime"], "defined_vars": ["collection", "image"], "parameters": ["LANDSAT/LE07/C02/T1", 2002, 11, 8, 2002, 11, 9, "B3", "B2", "B1", "datetime.datetime(2002, 11, 8)", "datetime.datetime(2002, 11, 9)"], "libraries": ["import datetime", "import ee.mapclient", "import ee"]}
{"code": "\nleafmap.whiteboxgui(tree=True)\n\n#\n", "task": "Use the `leafmap` library to create a whitebox GUI with a tree view.", "exec_path": "leafmap-master", "context": "import leafmap\nimport leafmap.colormaps as cm\nimport leafmap.foliumap as leafmap\n", "functions": ["leafmap.whiteboxgui"], "external_vars": ["leafmap"], "defined_vars": [], "parameters": [], "libraries": ["import leafmap.foliumap as leafmap", "import leafmap.colormaps as cm", "import leafmap"]}
{"code": "\n# Center the map and display the image.\nMap.setCenter(-122.1899, 37.5010, 10)\n# San Francisco Bay\nMap.addLayer(image, vizParams, \"False color composite\")\n\n#\n", "task": "Center the map on coordinates (-122.1899, 37.501) with a zoom level of 10. Then, add the image layer to the map using the provided vizParams and name it \"False color composite\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nMap = geemap.Map()\n# Load an image.\nimage = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318')\n# Define the visualization parameters.\nvizParams = {'bands': ['B5', 'B4', 'B3'],\n             'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}\n", "functions": ["Map.setCenter", "Map.addLayer"], "external_vars": ["image", "Map", "vizParams"], "defined_vars": [], "parameters": [37.501, 10, "image", "vizParams", "False color composite", "-122.1899"], "libraries": ["from geemap.datasets import get_metadata", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nvolume = pv.wrap(lith_block)\nvolume\n\n#\n", "task": "Using the provided `pv` function and the `lith_block` variable, calculate the volume of the lithographic block and assign it to the variable `volume`.", "exec_path": "gemgis-main", "context": "import pyvista as pv\nimport numpy as np\nfile_path = 'data/49_slicing_gempy_lith_blocks_in_pyvista_with_gemgis/'\nlith_block = np.load(file_path + 'lith_block.npy').reshape(50, 50, 50)\n", "functions": ["pv.wrap"], "external_vars": ["pv", "lith_block"], "defined_vars": ["volume"], "parameters": ["lith_block"], "libraries": ["import pyvista as pv", "import numpy as np"]}
{"code": "\nclass MLHubSession(requests.Session):\n    def __init__(self, *args, api_key=None, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.params.update({\"key\": api_key})\n\n    def request(self, method, url, *args, **kwargs):\n        url_prefix = MLHUB_ROOT_URL.rstrip(\"/\") + \"/\"\n        url = urljoin(url_prefix, url)\n        return super().request(method, url, *args, **kwargs)\n", "task": "Define a class called `MLHubSession` that inherits from `requests.Session`. It should have an `__init__` method that takes `*args`, `api_key=None`, and `**kwargs` as arguments. The `__init__` method should call the parent class's `__init__` method with `*args` and `**kwargs`, and then update the `self.params` dictionary with a key-value pair of `'key': api_key`. Additionally, define a `request` method that takes `method`, `url`, `*args`, and `**kwargs` as arguments. This method should construct a `url_prefix` by taking `MLHUB_ROOT_URL`, stripping its trailing slash, and appending `/`. It then joins the `url_prefix` with the `url` using the `urljoin` function. Finally, it returns the result of calling the parent class's `request` method with `method`, the newly constructed `url`, `*args`, and `**kwargs`.  Make sure to define the following variables: `url`, `url_prefix`, `self`, `method`, and `MLHubSession`.", "exec_path": "PlanetaryComputerExamples-main", "context": "import requests\nMLHUB_ROOT_URL = 'https://api.radiant.earth/mlhub/v1'\n", "functions": ["unknown_function.__init__", "super", "self.params.update", "MLHUB_ROOT_URL.rstrip", "urljoin", "unknown_function.request", "super"], "external_vars": ["urljoin", "MLHUB_ROOT_URL", "kwargs", "args", "super", "api_key", "requests"], "defined_vars": ["self", "url_prefix", "MLHubSession", "url", "method"], "parameters": ["/", "url_prefix", "url", "method", "url", "*args", "{'key': api_key}", "*args"], "libraries": ["import requests"]}
{"code": "\n# Authenticate and Initialize Earth Engine and geemap.\nMap = geemap.Map()\n", "task": "Using the `geemap` library, create a new map object and assign it to the variable `Map`.", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import eemont", "import ee", "import geemap"]}
{"code": "\ngeemap.image_mean_value(image).getInfo()\n\n#\n", "task": "Using the geemap library, calculate the mean value of the image and store it in a variable. You will need to define the variables `geemap` and `image` before running this instruction.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\nimage = ee.Image('LANDSAT/LC09/C02/T1_L2/LC09_044034_20220503')\n", "functions": ["unknown_function.getInfo", "geemap.image_mean_value"], "external_vars": ["image", "geemap"], "defined_vars": [], "parameters": ["image"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "import geemap", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nm.add_basemap(\"Esri.WorldTopoMap\")\n\n#\n", "task": "Add a basemap to the map object \"m\" using the \"Esri.WorldTopoMap\" basemap. You need to define the variable \"m\" before executing this instruction.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nfrom geemap.datasets import get_metadata\nm = geemap.Map(basemap='Esri.WorldImagery')\n", "functions": ["m.add_basemap"], "external_vars": ["m"], "defined_vars": [], "parameters": ["Esri.WorldTopoMap"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata"]}
{"code": "\nMap.add_legend(builtin_legend=\"MODIS/006/MCD12Q1\")\n\n#\n", "task": "Add a legend to the Map object using the MODIS/006/MCD12Q1 builtin legend.", "exec_path": "geemap-master", "context": "import geemap\n#\nMap = geemap.Map()\n", "functions": ["Map.add_legend"], "external_vars": ["Map"], "defined_vars": [], "parameters": [], "libraries": ["import geemap"]}
{"code": "\ndef computeSquares(number):\n    return ee.Number(number).pow(2)\n", "task": "Given an Earth Engine number variable called `number`, compute the square of that number using the `ee.Number` object and return the result.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["unknown_function.pow", "ee.Number"], "external_vars": ["ee"], "defined_vars": ["number"], "parameters": [2, "number"], "libraries": ["import ee", "import geemap"]}
{"code": "\nm = leafmap.Map(center=[40, -100], zoom=4)\nm\n\n#\n", "task": "Using the **leafmap** library, create a map object named **m** centered at latitude 40 and longitude -100 with a zoom level of 4.", "exec_path": "leafmap-master", "context": "import leafmap\n", "functions": ["leafmap.Map"], "external_vars": ["leafmap"], "defined_vars": ["m"], "parameters": [], "libraries": ["import leafmap"]}
{"code": "\n# Authenticate and Initialize Earth Engine and geemap.\nMap = geemap.Map()\n", "task": "Using the geemap library, create a new map object and assign it to the variable `Map`.", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import eemont", "import ee", "import geemap"]}
{"code": "\nMap = geemap.Map()\nMap\n\n#\n", "task": "Using the geemap library, create a new map object and assign it to the variable `Map`.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\ngdf = gpd.read_file(url)\nprint(f\"Total number of images: {len(gdf)}\")\ngdf.head()\n\n#\n", "task": "Read a geospatial file from the provided URL using the `gpd.read_file` function and store it in a variable named `gdf`. Print the total number of images in the file using the `len` function. Display the first few rows of the geospatial dataframe using the `gdf.head()` function.", "exec_path": "leafmap-master", "context": "import leafmap\nimport geopandas as gpd\nimport leafmap.foliumap as leafmap\ncollection = 'Kahramanmaras-turkey-earthquake-23'\nurl = leafmap.maxar_collection_url(collection, dtype='geojson')\n", "functions": ["gpd.read_file", "print", "len", "gdf.head"], "external_vars": ["len", "print", "gpd", "url"], "defined_vars": ["gdf"], "parameters": ["url", "gdf", "f'Total number of images: {len(gdf)}'"], "libraries": ["import leafmap.foliumap as leafmap", "import geopandas as gpd", "import leafmap"]}
{"code": "\ndates = geemap.image_dates(collection).getInfo()\ndates\n\n#\n", "task": "Using the `geemap` library, extract the dates of the images within the `collection` and store them in a variable called `dates`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\ncollection = ee.ImageCollection(\n    'MODIS/061/MOD13A2').filterDate('2015-01-01', '2019-12-31').select('NDVI')\n", "functions": ["unknown_function.getInfo", "geemap.image_dates"], "external_vars": ["collection", "geemap"], "defined_vars": ["dates"], "parameters": ["collection"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "import geemap", "import ee", "from geemap.datasets import DATA"]}
{"code": "\ntopo_raster = rasterio.open(file_path + 'raster28.tif')\n\n#\n", "task": "Using the `rasterio` library, open the raster file located at `file_path + 'raster28.tif'` and assign the resulting raster object to the variable `topo_raster`.", "exec_path": "gemgis-main", "context": "import rasterio\nfile_path = 'data/example28/'\n", "functions": ["rasterio.open"], "external_vars": ["file_path", "rasterio"], "defined_vars": ["topo_raster"], "parameters": ["file_path + 'raster28.tif'"], "libraries": ["import rasterio"]}
{"code": "\ntimelapse = geemap.landsat_timelapse(\n    roi,\n    out_gif=\"hong_kong.gif\",\n    start_year=1990,\n    end_year=2023,\n    start_date=\"01-01\",\n    end_date=\"12-31\",\n    bands=[\"SWIR1\", \"NIR\", \"Red\"],\n    frames_per_second=3,\n    title=\"Hong Kong\",\n)\ngeemap.show_image(timelapse)\n\n#\n", "task": "Using the geemap library, generate a Landsat timelapse animation for the region defined by the variable `roi`. The animation should cover the years 1990 to 2023, using the specified bands, and save the output as `hong_kong.gif`.  Set the frame rate to 3 frames per second and include the title \"Hong Kong\". Define a variable named `timelapse` to store the resulting animation, and then use geemap to display the animation.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nstart_date = '2016-01-01'\nend_date = '2022-12-31'\nroi = ee.Geometry.BBox(113.8252, 22.1988, 114.0851, 22.3497)\n", "functions": ["geemap.landsat_timelapse", "geemap.show_image"], "external_vars": ["roi", "geemap"], "defined_vars": ["timelapse"], "parameters": ["roi", "timelapse"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nstates_shp = \"../data/us_states.shp\"\nstates = geemap.shp_to_ee(states_shp)\nMap.addLayer(states, {}, \"US States\")\n\n#\n", "task": "Define the variables `states_shp` and `states`. Then, use the `geemap` library to convert the shapefile at `states_shp` to an Earth Engine feature collection and assign it to `states`. Finally, add this feature collection as a layer to the `Map` object with the label \"US States\".", "exec_path": "geemap-master", "context": "import geemap\nMap = geemap.Map()\n", "functions": ["geemap.shp_to_ee", "Map.addLayer"], "external_vars": ["Map", "geemap"], "defined_vars": ["states_shp", "states"], "parameters": ["states_shp", "states", "US States", "{}"], "libraries": ["import geemap"]}
{"code": "\nwbt.lidar_elevation_slice(\"madison.las\", \"madison_rm.las\", minz=0, maxz=450)\n\n#\n", "task": "Using the `wbt` library, slice the lidar elevation data from the file \"madison.las\" and save the result to \"madison_rm.las\".  The slice should include elevations between 0 and 450 meters. The variables `wbt`, `minz`, and `maxz` need to be defined.", "exec_path": "leafmap-master", "context": "import whitebox\n#\nwbt = whitebox.WhiteboxTools()\n", "functions": ["wbt.lidar_elevation_slice"], "external_vars": ["wbt"], "defined_vars": [], "parameters": ["madison.las", "madison_rm.las"], "libraries": ["import whitebox"]}
{"code": "\nstart_year = widgets.IntSlider(\n    description=\"Start Year:\", value=1984, min=1984, max=2020, style=style\n)\nend_year = widgets.IntSlider(\n    description=\"End Year:\", value=2020, min=1984, max=2020, style=style\n)\nstart_month = widgets.IntSlider(\n    description=\"Start Month:\", value=5, min=1, max=12, style=style\n)\nend_month = widgets.IntSlider(\n    description=\"End Month:\", value=10, min=1, max=12, style=style\n)\nhbox3 = widgets.HBox([start_year, end_year, start_month, end_month])\nhbox3\n\n#\n", "task": "Using the widgets library, create four IntSlider widgets for selecting start and end years and start and end months. The start year should be initialized to 1984, the end year to 2020, the start month to 5, and the end month to 10. Set the minimum and maximum values for the year sliders to 1984 and 2020 respectively, and the minimum and maximum values for the month sliders to 1 and 12 respectively. Apply the style variable to all the sliders. Finally, arrange the sliders in a horizontal box using widgets.HBox and assign it to the variable hbox3.", "exec_path": "geemap-master", "context": "import ipywidgets as widgets\nstyle = {'description_width': 'initial'}\n", "functions": ["widgets.IntSlider", "widgets.IntSlider", "widgets.IntSlider", "widgets.IntSlider", "widgets.HBox"], "external_vars": ["style", "widgets"], "defined_vars": ["hbox3", "start_month", "end_year", "start_year", "end_month"], "parameters": ["[start_year, end_year, start_month, end_month]"], "libraries": ["import ipywidgets as widgets"]}
{"code": "\nm = geemap.Map()\nfc = ee.FeatureCollection(\"USDOS/LSIB_SIMPLE/2017\").filter(\n    ee.Filter.eq(\"country_na\", \"Germany\")\n)\nm.add_layer(fc, {}, \"Germany\")\nm.center_object(fc)\nm\n\n#\n", "task": "Using the geemap and ee libraries, create a map object named \"m\" and a feature collection named \"fc\" representing the country of Germany from the \"USDOS/LSIB_SIMPLE/2017\" dataset. Add the feature collection to the map with the label \"Germany\" and center the map on the feature collection.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map", "unknown_function.filter", "ee.FeatureCollection", "ee.Filter.eq", "m.add_layer", "m.center_object"], "external_vars": ["ee", "geemap"], "defined_vars": ["m", "fc"], "parameters": ["USDOS/LSIB_SIMPLE/2017", "country_na", "Germany", "fc", "Germany", "fc", "ee.Filter.eq('country_na', 'Germany')", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nMap = geemap.Map()\nMap\n\n#\n", "task": "Using the geemap library, create a new map object and assign it to the variable \"Map\".", "exec_path": "geemap-master", "context": "import geemap\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import geemap"]}
{"code": "\ngeemap.ee_to_shp(fc, filename=\"Alaska.shp\")\n\n#\n", "task": "Convert the Earth Engine FeatureCollection `fc` to a Shapefile named `Alaska.shp` using the `geemap` library. Make sure to define `fc` and `geemap` before running this code.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nimport ee\nee.Initialize()\nfrom geemap.datasets import get_metadata\nstates = ee.FeatureCollection('TIGER/2018/States')\nfilename = 'cog.tif'\ndata = 'https://github.com/gee-community/geemap/blob/master/examples/data/us_cities.csv'\nfc = states.filter(ee.Filter.eq('NAME', 'Alaska'))\n", "functions": ["geemap.ee_to_shp"], "external_vars": ["geemap", "fc"], "defined_vars": [], "parameters": ["fc"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import get_metadata"]}
{"code": "\n###############################################################################\n# Here we will use Simple kriging (`unbiased=False`) to interpolate the given\n# conditions.\n\nkrig = gs.Krige(\n    model=model,\n    cond_pos=cond_pos,\n    cond_val=cond_val,\n    mean=1,\n    unbiased=False,\n    exact=False,\n    cond_err=cond_err,\n)\nkrig(gridx)\n#\n", "task": "Define a variable named `krig` as a `gs.Krige` object using the provided `model`, `cond_pos`, `cond_val`, `cond_err`, setting `mean` to 1, `unbiased` to False, and `exact` to False. Then, call the `krig` object with the input `gridx`.", "exec_path": "GSTools", "context": "import gstools as gs\nimport numpy as np\n# condtions\ncond_pos = [0.3, 1.1, 1.9, 3.3, 4.7]\ncond_val = [0.47, 0.74, 0.56, 1.47, 1.74]\ncond_err = [0.01, 0.0, 0.1, 0.05, 0]\n# resulting grid\ngridx = np.linspace(0.0, 15.0, 151)\n# spatial random field class\nmodel = gs.Gaussian(dim=1, var=0.9, len_scale=1, nugget=0.1)\n", "functions": ["gs.Krige", "krig"], "external_vars": ["model", "cond_val", "cond_err", "gridx", "gs", "cond_pos"], "defined_vars": ["krig"], "parameters": ["gridx"], "libraries": ["import numpy as np", "import gstools as gs"]}
{"code": "\ngeemap.bar_chart(\n    \"treeloss.csv\",\n    x=\"NAME\",\n    y=\"sum\",\n    max_rows=20,\n    x_label=\"Country\",\n    y_label=\"Forest loss area (km2)\",\n)\n\n#\n", "task": "Using the geemap library, create a bar chart visualization from the \"treeloss.csv\" data. Set the x-axis to \"NAME\", the y-axis to \"sum\", limit the chart to the top 20 rows, label the x-axis as \"Country\", and label the y-axis as \"Forest loss area (km2)\".", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.bar_chart"], "external_vars": ["geemap"], "defined_vars": [], "parameters": ["treeloss.csv"], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")\n#\n", "task": "Using the cartoee library, add gridlines to the plot represented by the ax object. Set the interval between gridlines to 0.5, rotate the x-axis tick labels by 0 degrees, and use a dotted line style for the gridlines.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap import cartoee\nimport cartopy.io.img_tiles as cimgt\n# get a landsat image to visualize\nimage = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')\n# define the visualization parameters to view\nvis = {'bands': ['B5', 'B4', 'B3'], 'min': 0, 'max': 5000, 'gamma': 1.3}\nbasemap = cimgt.OSM()\nax = cartoee.get_map(image, vis_params=vis, basemap='SATELLITE', zoom_level=8)\n", "functions": ["cartoee.add_gridlines"], "external_vars": ["cartoee", "ax"], "defined_vars": [], "parameters": ["ax"], "libraries": ["from geemap import cartoee", "import ee", "import cartopy.io.img_tiles as cimgt", "import geemap"]}
{"code": "\nMap = geemap.Map()\n\ncollection = ee.ImageCollection(\"LANDSAT/LC08/C02/T1\").filterDate(\n    \"2021-01-01\", \"2022-01-01\"\n)\n\ncomposite = ee.Algorithms.Landsat.simpleComposite(collection)\n\nvis_params = {\"bands\": [\"B5\", \"B4\", \"B3\"], \"max\": 128}\n\nMap.setCenter(-122.3578, 37.7726, 10)\nMap.addLayer(composite, vis_params, \"TOA composite\")\nMap\n\n#\n", "task": "Using the ee and geemap libraries, create a map centered at coordinates (-122.3578, 37.7726) with a zoom level of 10. Load a Landsat 8 image collection from January 1st, 2021 to January 1st, 2022, create a simple composite of the collection, and display it on the map using the bands B5, B4, B3 with a maximum value of 128. Define the following variables: `Map`, `collection`, `composite`, `vis_params`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\n# Add 5-year Landsat TOA composite\nlandsat = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\ncollection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\nimage = geemap.image_count(\n    collection, region=None, start_date='2021-01-01', end_date='2022-01-01', clip=False)\n", "functions": ["geemap.Map", "unknown_function.filterDate", "ee.ImageCollection", "ee.Algorithms.Landsat.simpleComposite", "Map.setCenter", "Map.addLayer"], "external_vars": ["ee", "geemap"], "defined_vars": ["collection", "composite", "Map", "vis_params"], "parameters": ["2021-01-01", "2022-01-01", "LANDSAT/LC08/C02/T1", "collection", 37.7726, 10, "composite", "vis_params", "TOA composite", "-122.3578"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "import geemap", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nMap = geemap.Map()\n\ncentroid = ee.Geometry.Point([-122.4439, 37.7538])\nimage = ee.ImageCollection(\"LANDSAT/LC08/C01/T1_SR\").filterBounds(centroid).first()\nvis = {\"min\": 0, \"max\": 3000, \"bands\": [\"B5\", \"B4\", \"B3\"]}\n\nMap.centerObject(centroid, 8)\nMap.addLayer(image, vis, \"Landsat-8\")\nMap.addLayer(centroid, {}, \"Centroid\")\nMap\n\n#\n", "task": "Using the **ee** and **geemap** libraries, define the variables **image**, **Map**, **vis**, and **centroid**. **image** should represent the first image in the Landsat-8 collection filtered by the **centroid** coordinates. **Map** should be initialized as a geemap map object. **centroid** should be a point geometry located at -122.4439, 37.7538. **vis** should be a dictionary defining the visualization parameters for the image, with a minimum of 0, maximum of 3000, and bands B5, B4, B3.  Center the map on the **centroid** at zoom level 8. Add the **image** to the **Map** with the specified visualization parameters and label it \"Landsat-8\". Also, add the **centroid** to the **Map** as a point and label it \"Centroid\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map", "ee.Geometry.Point", "unknown_function.first", "unknown_function.filterBounds", "ee.ImageCollection", "Map.centerObject", "Map.addLayer", "Map.addLayer"], "external_vars": ["ee", "geemap"], "defined_vars": ["centroid", "image", "vis", "Map"], "parameters": ["centroid", "LANDSAT/LC08/C01/T1_SR", "centroid", 8, "image", "vis", "Landsat-8", "centroid", "Centroid", "[-122.4439, 37.7538]", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nwbt = whitebox.WhiteboxTools()\nwbt.verbose = False\n\n#\n", "task": "Import the WhiteboxTools class from the `whitebox` library and create an instance named `wbt`. Set the `verbose` attribute of `wbt` to `False`.", "exec_path": "leafmap-master", "context": "import whitebox\n", "functions": ["whitebox.WhiteboxTools"], "external_vars": ["whitebox"], "defined_vars": ["wbt"], "parameters": [], "libraries": ["import whitebox"]}
{"code": "\nprops = geemap.image_props(image)\nprops\n\n#\n", "task": "Using the `geemap` library, get the image properties of the `image` variable and store them in a variable called `props`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\ncentroid = ee.Geometry.Point([-122.4439, 37.7538])\nimage = ee.ImageCollection(\n    'LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()\n", "functions": ["geemap.image_props"], "external_vars": ["image", "geemap"], "defined_vars": ["props"], "parameters": ["image"], "libraries": ["from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\ncat.to_dict(include_self_link=False)\n\n#\n", "task": "Convert the `cat` object into a dictionary representation without including the self-link. **You need to define the following variable:** `cat`.", "exec_path": "pystac-main", "context": "import pystac\n#\ncat = pystac.Catalog.from_file('./example-catalog/catalog.json')\n", "functions": ["cat.to_dict"], "external_vars": ["cat"], "defined_vars": [], "parameters": [], "libraries": ["import pystac"]}
{"code": "\nMap = geemap.Map(center=[40, -100], zoom=4)\n\n#\n", "task": "Using the geemap library, create a new map object called \"Map\" centered at coordinates [40, -100] with a zoom level of 4.", "exec_path": "geemap-master", "context": "import geemap.foliumap as geemap\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import geemap.foliumap as geemap"]}
{"code": "\nstats.to_csv(\"mean.csv\", index=False)\n\n#\n", "task": "Save the statistics stored in the `stats` variable to a CSV file named \"mean.csv\". Do not include an index column.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nimage = ee.Image('USGS/SRTMGL1_003')\nreducer = 'mean'\ndem = ee.Image('USGS/3DEP/10m')\nlandcover = ee.Image(\n    'USGS/NLCD_RELEASES/2019_REL/NLCD/2019').select('landcover')\nstats = geemap.image_stats_by_zone(dem, landcover, reducer='MEAN')\n", "functions": ["stats.to_csv"], "external_vars": ["stats"], "defined_vars": [], "parameters": ["mean.csv"], "libraries": ["import ee", "import geemap"]}
{"code": "\nMap = geemap.Map()\n\ndem = ee.Image(\"USGS/SRTMGL1_003\")\nvis_params = {\n    \"min\": 0,\n    \"max\": 4000,\n    \"palette\": [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"],\n}\n\nMap.addLayer(dem, vis_params, \"SRTM DEM\")\nMap\n\n#\n", "task": "Using the `ee` and `geemap` libraries, define variables named `dem`, `Map`, and `vis_params`. Then, load the SRTM DEM data into the map using the `addLayer` function. Set the visualization parameters using the `vis_params` variable.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\n# Load an image.\nimage = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318')\n", "functions": ["geemap.Map", "ee.Image", "Map.addLayer"], "external_vars": ["ee", "geemap"], "defined_vars": ["dem", "Map", "vis_params"], "parameters": ["USGS/SRTMGL1_003", "dem", "vis_params", "SRTM DEM"], "libraries": ["from geemap.datasets import get_metadata", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nfile_path = 'data/example19/'\ngg.download_gemgis_data.download_tutorial_data(filename=\"example19_faulted_folded_layers.zip\", dirpath=file_path)\n\n#\n", "task": "Using the `gg` object, download the tutorial data file \"example19_faulted_folded_layers.zip\" into the directory specified by the variable `file_path`.", "exec_path": "gemgis-main", "context": "import gemgis as gg\n", "functions": ["gg.download_gemgis_data.download_tutorial_data"], "external_vars": ["gg"], "defined_vars": ["file_path"], "parameters": [], "libraries": ["import gemgis as gg"]}
{"code": "\nraw_class_values = nlcd_raw.get(\"landcover_class_values\").getInfo()\nprint(raw_class_values)\n\n#\n", "task": "Using the variable `nlcd_raw`, retrieve the landcover class values and store them in a variable called `raw_class_values`. Then, use the `print` function to display the contents of `raw_class_values`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nNLCD2016 = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\nNLCD_metadata = ee.FeatureCollection(\n    'users/giswqs/landcover/NLCD2016_metadata')\n# In[ ]:\npoint = ee.Geometry.Point([-88.307, 41.7471])\nmetadata = NLCD_metadata.filterBounds(point).first()\nregion = metadata.geometry()\ndoy = metadata.get('2016on_bas').getInfo().replace('LC08_', '')\nstart_date = ee.Date.parse('YYYYDDD', doy)\nend_date = start_date.advance(1, 'day')\nimage = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(\n    point).filterDate(start_date, end_date).first().select('B[1-7]').clip(region)\nnlcd_raw = NLCD2016.clip(region)\n", "functions": ["unknown_function.getInfo", "nlcd_raw.get", "print"], "external_vars": ["nlcd_raw", "print"], "defined_vars": ["raw_class_values"], "parameters": ["landcover_class_values", "raw_class_values"], "libraries": ["import ee", "import geemap"]}
{"code": "\ngeemap.ee_to_df(training.limit(5))\n\n#\n", "task": "Use the geemap library to convert the first 5 features of the `training` Earth Engine FeatureCollection to a Pandas DataFrame.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap import cartoee\nregion = ee.Geometry.BBox(-149.352, 64.5532, -147.0976, 65.1277)\ncollection = geemap.landsat_timeseries(\n    region, start_year=2021, end_year=2021, start_date='06-01', end_date='09-01')\nimage = collection.first()\ntraining = image.sample(**{'region': region, 'scale': 150,\n                        'numPixels': 5000, 'seed': 1, 'geometries': True})\n", "functions": ["geemap.ee_to_df", "training.limit"], "external_vars": ["geemap", "training"], "defined_vars": [], "parameters": [5, "training.limit(5)"], "libraries": ["from geemap import cartoee", "import ee", "import geemap"]}
{"code": "\nterrain = ee.Algorithms.Terrain(ee.Image('CGIAR/SRTM90_V4'))\nslope_img = Radians(terrain.select('slope'))\naspect_img = Radians(terrain.select('aspect'))\n", "task": "Using the Earth Engine library (ee) and the Radians function, calculate the slope and aspect from the SRTM90_V4 elevation data. Define the variables terrain, aspect_img, and slope_img to store the resulting images.", "exec_path": "earthengine-api-master", "context": "import math\nimport ee\nee.Initialize()\nimport ee.mapclient\n\n\ndef Radians(img):\n    return img.toFloat().multiply(math.pi).divide(180)\n", "functions": ["ee.Algorithms.Terrain", "ee.Image", "Radians", "terrain.select", "Radians", "terrain.select"], "external_vars": ["ee", "Radians"], "defined_vars": ["aspect_img", "terrain", "slope_img"], "parameters": ["CGIAR/SRTM90_V4", "slope", "aspect", "ee.Image('CGIAR/SRTM90_V4')", "terrain.select('slope')", "terrain.select('aspect')"], "libraries": ["import ee.mapclient", "import ee", "import math"]}
{"code": "\nm = geemap.Map(center=[40, -100], zoom=4)\n#\n", "task": "Using the geemap library, create a map object named \"m\" centered at coordinates [40, -100] with a zoom level of 4.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["m"], "parameters": [], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nimage = (\n    ee.ImageCollection(\"COPERNICUS/S2\")\n    .filterDate(\"2018-09-01\", \"2018-09-30\")\n    .map(lambda img: img.divide(10000))\n    .median()\n)\n\nvis_params = [\n    {\"bands\": [\"B4\", \"B3\", \"B2\"], \"min\": 0, \"max\": 0.3, \"gamma\": 1.3},\n    {\"bands\": [\"B8\", \"B11\", \"B4\"], \"min\": 0, \"max\": 0.3, \"gamma\": 1.3},\n    {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": 0, \"max\": 0.3, \"gamma\": 1.3},\n    {\"bands\": [\"B12\", \"B12\", \"B4\"], \"min\": 0, \"max\": 0.3, \"gamma\": 1.3},\n]\n\nlabels = [\n    \"Natural Color (B4/B3/B2)\",\n    \"Land/Water (B8/B11/B4)\",\n    \"Color Infrared (B8/B4/B3)\",\n    \"Vegetation (B12/B11/B4)\",\n]\n\ngeemap.linked_maps(\n    rows=2,\n    cols=2,\n    height=\"400px\",\n    center=[38.4151, 21.2712],\n    zoom=12,\n    ee_objects=[image],\n    vis_params=vis_params,\n    labels=labels,\n    label_position=\"topright\",\n)\n\n#\n", "task": "Using the `ee` and `geemap` libraries, create a linked map visualization of Sentinel-2 imagery for September 2018. First, filter the `COPERNICUS/S2` image collection for the specified date range. Then, divide the image pixel values by 10000 and calculate the median image for the month. Define `vis_params` with a list of dictionaries specifying the bands and visualization parameters for each map. Define `labels` with a list of labels for each map. Finally, use `geemap.linked_maps` to create a 2x2 grid of linked maps with the specified parameters. The `image` variable should contain the median image and `labels` should contain the labels for each map.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nimport ee\nee.Initialize()\n#\nMap = geemap.Map()\n", "functions": ["unknown_function.median", "unknown_function.map", "unknown_function.filterDate", "ee.ImageCollection", "img.divide", "geemap.linked_maps"], "external_vars": ["geemap", "img", "ee"], "defined_vars": ["vis_params", "image", "labels"], "parameters": ["2018-09-01", "2018-09-30", "COPERNICUS/S2", 10000, "lambda img: img.divide(10000)"], "libraries": ["import ee", "import geemap", "from geemap import cartoee", "from geemap.datasets import DATA"]}
{"code": "\npoly = pv.PolyData(np.array([[750,1100,800], [750,700,800]]))\npoly[\"My Labels\"] = [f\"Well {i+1}\" for i in range(poly.n_points)]\npoly\n\n#\n", "task": "Using the libraries `pv` and `np`, create a `PolyData` object named `poly` with two points defined by the array `[[750, 1100, 800], [750, 700, 800]]`. Then, add an array of strings called `'My Labels'` to the `poly` object. Each string should be formatted as `'Well {i + 1}'` where `i` is a counter iterating through the `range` of the number of points in `poly`. Note: You will need to define `poly` and `i` before executing this code.", "exec_path": "gemgis_data-main", "context": "import numpy as np\nimport pyvista as pv\n", "functions": ["pv.PolyData", "np.array", "range"], "external_vars": ["pv", "np", "range"], "defined_vars": ["poly", "i"], "parameters": ["np.array([[750, 1100, 800], [750, 700, 800]])", "[[750, 1100, 800], [750, 700, 800]]", "poly.n_points"], "libraries": ["import pyvista as pv", "import numpy as np"]}
{"code": "\ngeemap.ee_to_geojson(fc, filename=\"Indiana.geojson\")\n\n#\n", "task": "Using the `geemap` library, convert the Earth Engine feature collection `fc` to a GeoJSON file named \"Indiana.geojson\".", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nimport ee\nee.Initialize()\nfrom geemap.datasets import get_metadata\nstates = ee.FeatureCollection('TIGER/2018/States')\nfc = states.filter(ee.Filter.eq('NAME', 'Indiana'))\n", "functions": ["geemap.ee_to_geojson"], "external_vars": ["geemap", "fc"], "defined_vars": [], "parameters": ["fc"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import get_metadata"]}
{"code": "\nnlcd_stats = \"nlcd_stats_pct.csv\"\n\ngeemap.zonal_stats_by_group(\n    landcover,\n    states,\n    nlcd_stats,\n    stat_type=\"PERCENTAGE\",\n    denominator=1e6,\n    decimal_places=2,\n)\n\n#\n", "task": "Calculate zonal statistics for the `landcover` data by state using the `geemap` library. The statistics should be calculated as percentages and are based on the data in the `nlcd_stats` CSV file. The `states` variable defines the boundaries of each state. Before running this code, ensure the `nlcd_stats` variable is defined and points to the correct CSV file. ", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nstates = ee.FeatureCollection('TIGER/2018/States')\ncentroid = ee.Geometry.Point([-122.4439, 37.7538])\nimage = ee.ImageCollection(\n    'LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()\n# Add NLCD data\ndataset = ee.Image('USGS/NLCD_RELEASES/2021_REL/NLCD/2021')\nlandcover = dataset.select('landcover')\n", "functions": ["geemap.zonal_stats_by_group"], "external_vars": ["geemap", "landcover", "states"], "defined_vars": ["nlcd_stats"], "parameters": ["landcover", "states", "nlcd_stats"], "libraries": ["from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\ngg.download_gemgis_data.download_tutorial_data(filename=\"53_adding_anthropogenic_geometries_to_pyvista.zip\", dirpath=file_path)\n\n#\n", "task": "Download the tutorial data for \"53_adding_anthropogenic_geometries_to_pyvista.zip\" using the `gg` object and save it to the directory specified by the `file_path` variable. **Note:** You need to define the `gg` and `file_path` variables before running this code.", "exec_path": "gemgis-main", "context": "import gemgis as gg\nfile_path = 'data/53_adding_anthropogenic_geometries_to_pyvista/'\n", "functions": ["gg.download_gemgis_data.download_tutorial_data"], "external_vars": ["file_path", "gg"], "defined_vars": [], "parameters": [], "libraries": ["import gemgis as gg"]}
{"code": "\n# structured field with a size of 100x100 and a grid-size of 1x1\nx = y = range(100)\nmodel = gs.Gaussian(dim=2, var=1, len_scale=10)\nsrf = gs.SRF(model, seed=20170519)\nsrf.structured([x, y])\nsrf.transform(\"normal_to_lognormal\")  # also \"lognormal\" works\nsrf.plot()\n\n#\n\n\n", "task": "Create two variables, x and y, both set to the range of 0 to 99 using the `range` function. Then, define a Gaussian model named `model` using the `gs` module with a dimension of 2, a variance of 1, and a length scale of 10. Instantiate a `SRF` object named `srf` using the `gs` module, passing the `model` and setting the seed to 20170519.  Structure the `srf` object using the lists x and y. Transform the `srf` using the `normal_to_lognormal` method and then plot it. This code requires the `gs` module to be imported beforehand.", "exec_path": "GSTools", "context": "import gstools as gs\n", "functions": ["range", "gs.Gaussian", "gs.SRF", "srf.structured", "srf.transform", "srf.plot"], "external_vars": ["range", "gs"], "defined_vars": ["model", "srf", "x", "y"], "parameters": [100, "model", "normal_to_lognormal", "[x, y]"], "libraries": ["import gstools as gs"]}
{"code": "\ninterfaces.head()\n\n#\n", "task": "Retrieve the first element of the list \"interfaces\" and assign it to a variable. You need to define the variable [].", "exec_path": "gemgis-main", "context": "import geopandas as gpd\nfile_path = 'data/18_creating_depth_maps_from_gempy_models/'\ninterfaces = gpd.read_file(file_path + 'interfaces.shp')\n", "functions": ["interfaces.head"], "external_vars": ["interfaces"], "defined_vars": [], "parameters": [], "libraries": ["import geopandas as gpd"]}
{"code": "\n# Open the Planetary Computer STAC API\ncatalog = pystac_client.Client.open(\n    \"https://planetarycomputer.microsoft.com/api/stac/v1/\",\n    modifier=planetary_computer.sign_inplace,\n)\n\n#\n", "task": "Using the `pystac_client` library, open the Planetary Computer STAC catalog at the given URL and store the resulting catalog object in a variable named `catalog`. Use the `planetary_computer.sign_inplace` modifier to authenticate with the Planetary Computer.", "exec_path": "PlanetaryComputerExamples-main", "context": "import planetary_computer\nimport pystac_client\n", "functions": ["pystac_client.Client.open"], "external_vars": ["planetary_computer", "pystac_client"], "defined_vars": ["catalog"], "parameters": ["https://planetarycomputer.microsoft.com/api/stac/v1/"], "libraries": ["import planetary_computer", "import pystac_client"]}
{"code": "\nm = geemap.Map()\n\nimage = ee.Image(\"LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318\").select(\n    [\"B5\", \"B4\", \"B3\"]\n)\n\nvis_params = {\"min\": 0, \"max\": 0.5, \"gamma\": [0.95, 1.1, 1]}\n\nm.center_object(image)\nm.add_layer(image, vis_params, \"Landsat\")\nm\n\n#\n", "task": "Using the `ee` and `geemap` libraries, create a map object named `m`.  Define an `image` variable to represent the Landsat 8 image with bands `B5`, `B4`, and `B3`.  Then, define a `vis_params` dictionary with values for minimum, maximum, and gamma.  Finally, center the map on the image and add the image as a layer to the map named \"Landsat\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\ncentroid = ee.Geometry.Point([-122.4439, 37.7538])\nimage = ee.ImageCollection(\n    'LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()\n", "functions": ["geemap.Map", "unknown_function.select", "ee.Image", "m.center_object", "m.add_layer"], "external_vars": ["ee", "geemap"], "defined_vars": ["m", "image", "vis_params"], "parameters": ["LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318", "image", "image", "vis_params", "Landsat", "['B5', 'B4', 'B3']"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nleafmap.image_comparison(\n    img1,\n    img2,\n    label1=\"Satellite Image\",\n    label2=\"Image Segmentation\",\n    starting_position=50,\n    out_html=\"image_comparison.html\",\n)\n\n#\n\n\n", "task": "Using the `leafmap` library, compare the satellite image (`img1`) with the image segmentation (`img2`). Label the images as \"Satellite Image\" and \"Image Segmentation\" respectively. Set the starting position for the comparison to 50 and save the output as an HTML file named \"image_comparison.html\".", "exec_path": "leafmap-master", "context": "import leafmap\n#\nimg1 = 'https://open.gishub.org/data/images/berkeley.jpg'\nimg2 = 'https://open.gishub.org/data/images/berkeley_sam.jpg'\n", "functions": ["leafmap.image_comparison"], "external_vars": ["img1", "img2", "leafmap"], "defined_vars": [], "parameters": ["img1", "img2"], "libraries": ["import leafmap"]}
{"code": "\ngeemap.ee_to_geojson(fc, filename=\"Alaska.geojson\")\n\n#\n", "task": "Convert the Earth Engine feature collection `fc` to a GeoJSON file named \"Alaska.geojson\" using the `geemap` library.  The `geemap` library and the `fc` variable must be defined.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nstates = ee.FeatureCollection('TIGER/2018/States')\nfc = states.filter(ee.Filter.eq('NAME', 'Alaska'))\n", "functions": ["geemap.ee_to_geojson"], "external_vars": ["geemap", "fc"], "defined_vars": [], "parameters": ["fc"], "libraries": ["import ee", "import geemap"]}
{"code": "\nleafmap.view_lidar(filename, backend=\"open3d\")\n\n#\n\n\n", "task": "Use the `leafmap` library to visualize the lidar data stored in the file specified by the `filename` variable. Use the `open3d` backend for rendering.", "exec_path": "leafmap-master", "context": "import leafmap\nfilename = 'madison.las'\n", "functions": ["leafmap.view_lidar"], "external_vars": ["leafmap", "filename"], "defined_vars": [], "parameters": ["filename"], "libraries": ["import leafmap"]}
{"code": "\nfig, ax = plt.subplots(1, figsize=(5,5))\n\nstrikes.plot(ax=ax,column='id', aspect=1)\ninterfaces.plot(ax=ax, column='formation', legend=True, aspect='equal')\nax.set_xlabel('X [m]')\nax.set_ylabel('Y [m]')\n", "task": "Using the matplotlib library (imported as `plt`), create a plot showing both `strikes` and `interfaces` dataframes on the same axes. Define two variables `fig` and `ax` for the figure and axes objects, respectively.  Plot the `strikes` dataframe using the column \"id\" and set the aspect ratio to 1. Plot the `interfaces` dataframe using the column \"formation\", include a legend, and set the aspect ratio to \"equal\". Label the x-axis as \"X [m]\" and the y-axis as \"Y [m]\".", "exec_path": "gemgis_data-main", "context": "import geopandas as gpd\nimport matplotlib.pyplot as plt\n#\nfile_path = 'data/example18_faulted_folded_layers/'\ninterfaces = gpd.read_file(file_path + 'interfaces18.shp')\nfig, ax = plt.subplots(1, figsize=(10, 10))\nstrikes = gpd.read_file(file_path + 'strikes18.shp')\n", "functions": ["plt.subplots", "strikes.plot", "interfaces.plot", "ax.set_xlabel", "ax.set_ylabel"], "external_vars": ["plt", "interfaces", "strikes"], "defined_vars": ["fig", "ax"], "parameters": [1, "X [m]", "Y [m]"], "libraries": ["import geopandas as gpd", "import matplotlib.pyplot as plt"]}
{"code": "\nwell2 = pv.Line((2000,1500,800), (2000,1500, 0))\nwell2_tube = well2.tube(radius=20)\nwell2_tube\n\n#\n", "task": "Using the pv library, define a line object named \"well2\" that extends from the point (2000, 1500, 800) to (2000, 1500, 0). Then, create a tube object named \"well2_tube\" from the \"well2\" line with a radius of 20.", "exec_path": "gemgis_data-main", "context": "import pyvista as pv\n", "functions": ["pv.Line", "well2.tube"], "external_vars": ["pv"], "defined_vars": ["well2_tube", "well2"], "parameters": ["(2000, 1500, 800)", "(2000, 1500, 0)"], "libraries": ["import pyvista as pv"]}
{"code": "\nm = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm.add_colormap(position=(55, 5), **params)\nm\n\n#\n", "task": "Using the `leafmap` library, create a map object named `m`. Add the \"OpenTopoMap\" basemap to the map. Then, add a colormap to the map with the specified `params` at the position (55, 5).", "exec_path": "leafmap-master", "context": "import leafmap.foliumap as leafmap\n#\nparams = {'width': 4.0, 'height': 0.3, 'vmin': 0, 'vmax': 6000, 'cmap': 'terrain',\n          'label': 'Elevation (m)', 'orientation': 'horizontal', 'transparent': False}\n", "functions": ["leafmap.Map", "m.add_basemap", "m.add_colormap"], "external_vars": ["leafmap", "params"], "defined_vars": ["m"], "parameters": ["OpenTopoMap"], "libraries": ["import leafmap.foliumap as leafmap"]}
{"code": "\nMap = geemap.Map()\nMap.add_basemap(\"HYBRID\")\n\nesa = ee.ImageCollection(\"ESA/WorldCover/v100\").first()\nesa_vis = {\"bands\": [\"Map\"]}\n\nMap.addLayer(esa, esa_vis, \"ESA Land Cover\")\nMap.add_legend(title=\"ESA Land Cover\", builtin_legend=\"ESA_WorldCover\")\n\nMap\n\n#\n", "task": "Using the geemap and ee libraries, create a map and add a basemap. Define a variable called \"esa\" and set it to the first image of the ESA WorldCover v100 collection. Define a variable called \"esa_vis\" as a dictionary with the key \"bands\" set to a list containing the string \"Map\". Add a layer to the map using the \"esa\" variable, the \"esa_vis\" variable, and the title \"ESA Land Cover\". Finally, add a legend to the map with the title \"ESA Land Cover\" and using the \"ESA_WorldCover\" builtin legend.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\n", "functions": ["geemap.Map", "Map.add_basemap", "unknown_function.first", "ee.ImageCollection", "Map.addLayer", "Map.add_legend"], "external_vars": ["ee", "geemap"], "defined_vars": ["esa_vis", "esa", "Map"], "parameters": ["HYBRID", "ESA/WorldCover/v100", "esa", "esa_vis", "ESA Land Cover"], "libraries": ["import ee", "import geemap"]}
{"code": "\ntraining = image.sample(\n    **{\n        #     'region': region,\n        \"scale\": 30,\n        \"numPixels\": 5000,\n        \"seed\": 0,\n        \"geometries\": True,  # Set this to False to ignore geometries\n    }\n)\n\nMap.addLayer(training, {}, \"training\", False)\n\n#\n", "task": "Using the `image` object, sample a training dataset with a scale of 30, 5000 pixels, seed 0, and geometries enabled.  Store this in a variable named `training`. Then, use the `Map` object to add this training dataset as a layer named \"training\" with no default visibility.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nimport ee\nee.Initialize()\n#\nMap = geemap.Map()\npoint = ee.Geometry.Point([-87.7719, 41.8799])\nimage = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(point).filterDate(\n    '2019-01-01', '2019-12-31').sort('CLOUD_COVER').first().select('B[1-7]')\n", "functions": ["image.sample", "Map.addLayer"], "external_vars": ["Map", "image"], "defined_vars": ["training"], "parameters": ["training", "training", false, "{}"], "libraries": ["import ee", "import geemap", "from geemap import cartoee", "from geemap.datasets import DATA"]}
{"code": "\n# Add NASA SRTM\ndem = ee.Image(\"USGS/SRTMGL1_003\")\ndem_vis = {\n    \"min\": 0,\n    \"max\": 4000,\n    \"palette\": [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"],\n}\nMap.addLayer(dem, dem_vis, \"SRTM DEM\")\n#\n", "task": "Using the `ee` and `Map` objects, define variables named `dem` and `dem_vis`. Set `dem` to an Earth Engine image representing the SRTM elevation data. Define `dem_vis` as a dictionary containing visualization parameters for the DEM, including minimum and maximum values and a palette.  Add the `dem` image to the `Map` with the specified visualization parameters and label \"SRTM DEM\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nMap = geemap.Map(center=[40, -100], zoom=4)\nimage = ee.ImageCollection('COPERNICUS/S2').filterDate('2018-09-01',\n                                                       '2018-09-30').map(lambda img: img.divide(10000)).median()\n", "functions": ["ee.Image", "Map.addLayer"], "external_vars": ["ee", "Map"], "defined_vars": ["dem_vis", "dem"], "parameters": ["USGS/SRTMGL1_003", "dem", "dem_vis", "SRTM DEM"], "libraries": ["from geemap.datasets import get_metadata", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\n# %%\n# The different functionalities of GeoUtils will respect :class:`~geoutils.Raster.nodata` values, starting with :func:`~geoutils.Raster.show`,\n# which will ignore them during plotting (transparent).\nrast.plot(cmap=\"copper\")\n\n#\n\n\n", "task": "Plot the raster dataset `rast` using a copper colormap.  This requires defining the variable `rast` as a raster object.", "exec_path": "geoutils-main", "context": "import geoutils as gu\nimport numpy as np\nimport rasterio as rio\nimport pyproj\n# A random 3 x 3 masked array\nrng = np.random.default_rng(42)\narr = rng.normal(size=(5, 5))\n# A transform with 3 x 3 pixels in a [0-1, 0-1] bound square\ntransform = rio.transform.from_bounds(0, 0, 1, 1, 3, 3)\n# A CRS, here geographic (latitude/longitude)\ncrs = pyproj.CRS.from_epsg(4326)\n# A random mask, that will mask one out of two values on average\nmask = rng.integers(0, 2, size=(5, 5), dtype='bool')\nma = np.ma.masked_array(data=arr, mask=mask)\n# This time, we pass directly the masked array\nrast = gu.Raster.from_array(data=ma, transform=transform, crs=crs, nodata=255)\n", "functions": ["rast.plot"], "external_vars": ["rast"], "defined_vars": [], "parameters": [], "libraries": ["import pyproj", "import geoutils as gu", "import numpy as np", "import rasterio as rio"]}
{"code": "\ncollections = [\n    \"3dep-lidar-hag\",\n    \"3dep-lidar-dsm\",\n    \"3dep-lidar-pointsourceid\",\n    \"3dep-lidar-intensity\",\n    \"3dep-lidar-dtm\",\n    \"3dep-lidar-dtm-native\",\n    \"3dep-lidar-returns\",\n    \"3dep-lidar-classification\",\n]\n\nsearch = client.search(\n    collections=collections,\n    intersects={\n        \"type\": \"Point\",\n        \"coordinates\": [-77.10058811018344, 38.838335717896314],\n    },\n    datetime=\"2018\",\n)\nitems = {x.collection_id: x for x in search.get_all_items()}\nitems\n\n#\n", "task": "Using the provided client, search for lidar data in the specified collections for the given coordinates and date. Store the results in a dictionary with the collection ID as the key and the corresponding search item as the value.", "exec_path": "PlanetaryComputerExamples-main", "context": "import pystac_client\nimport planetary_computer\n# pc.settings.set_subscription_key(<YOUR API Key>)\nclient = pystac_client.Client.open(\n    'https://planetarycomputer.microsoft.com/api/stac/v1/', modifier=planetary_computer.sign_inplace)\n", "functions": ["client.search", "search.get_all_items"], "external_vars": ["client"], "defined_vars": ["x", "items", "search", "collections"], "parameters": [], "libraries": ["import planetary_computer", "import pystac_client"]}
{"code": "\n# By looking at the band names, we can see that running `tasseledCap` returned our image with brightness (TCB), greenness (TCG), and wetness (TCW) bands added.\nimg.bandNames().getInfo()\n", "task": "Get information about the band names found within the image `img`. You will need to define a function called `bandNames()` that extracts the band names from the image, and a function called `getInfo()` that retrieves information about those band names.", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\n# Tasseled cap brightness, greenness, and wetness components can be calculated in `eemont` using the `tasseledCap` method extended to `ee.Image` and `ee.ImageCollection` objects. Just load imagery from a supported platform and use `tasseledCap` to add the component bands.\nimg = ee.Image(\n    'COPERNICUS/S2/20160111T112432_20160111T113311_T28PDT').tasseledCap()\n", "functions": ["unknown_function.getInfo", "img.bandNames"], "external_vars": ["img"], "defined_vars": [], "parameters": [], "libraries": ["import eemont", "import ee", "import geemap"]}
{"code": "\nimage = ee.Image(\"LANDSAT/LC09/C02/T1_L2/LC09_044034_20220503\")\ngeemap.image_min_value(image).getInfo()\n\n#\n", "task": "Using the **ee** and **geemap** libraries, define an **image** variable as an Earth Engine image object representing the Landsat 9 Collection 2 Tier 1 Level-2 data with ID \"LC09_044034_20220503\". Then, use the **geemap.image_min_value()** function to find the minimum value of the image and print it using **.getInfo()**.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\n", "functions": ["ee.Image", "unknown_function.getInfo", "geemap.image_min_value"], "external_vars": ["ee", "geemap"], "defined_vars": ["image"], "parameters": ["LANDSAT/LC09/C02/T1_L2/LC09_044034_20220503", "image"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "import geemap", "import ee", "from geemap.datasets import DATA"]}
{"code": "\n# create a new Goode homolosine projection centered on the Pacific\nprojection = ccrs.InterruptedGoodeHomolosine(central_longitude=-180)\n#\n", "task": "Using the **ccrs** library, define a projection called **projection** as an Interrupted Goode Homolosine projection with a central longitude of -180 degrees.", "exec_path": "geemap-master", "context": "import cartopy.crs as ccrs\n", "functions": ["ccrs.InterruptedGoodeHomolosine"], "external_vars": ["ccrs"], "defined_vars": ["projection"], "parameters": [], "libraries": ["import cartopy.crs as ccrs"]}
{"code": "\nstyle = {\"description_width\": \"initial\"}\nuploader = widgets.FileUpload(\n    description=\"Upload data\",\n    accept=\".zip, .json, .geojson\",\n    multiple=False,\n    button_style=\"primary\",\n    style=style,\n)\n\nsubmit = widgets.Button(\n    description=\"Display data\", button_style=\"success\", tooltip=\"Click me\", style=style\n)\n\nreset = widgets.Button(\n    description=\"Reset\", button_style=\"warning\", tooltip=\"Click me\", style=style\n)\n\n#\n", "task": "Using the `widgets` library, create three interactive widgets: `uploader`, `submit`, and `reset`. `uploader` should be a file upload widget for `.zip`, `.json`, and `.geojson` files with a primary button style. `submit` should be a button with a success style and a tooltip \"Click me\", while `reset` should be a button with a warning style and a tooltip \"Click me\". All widgets should have the `style` applied with a description width set to `initial`.", "exec_path": "geemap-master", "context": "import ipywidgets as widgets\n", "functions": ["widgets.FileUpload", "widgets.Button", "widgets.Button"], "external_vars": ["widgets"], "defined_vars": ["submit", "reset", "style", "uploader"], "parameters": [], "libraries": ["import ipywidgets as widgets"]}
{"code": "\nwell2 = pv.Line((750,700,800), (750,700, 0))\nwell2_tube = well2.tube(radius=20)\nwell2_tube\n\n#\n", "task": "Using the pv library, create a line object named \"well2\" with the starting point (750, 700, 800) and ending point (750, 700, 0). Then, create a tube object named \"well2_tube\" by applying the tube method to \"well2\" with a radius of 20.", "exec_path": "gemgis_data-main", "context": "import pyvista as pv\n", "functions": ["pv.Line", "well2.tube"], "external_vars": ["pv"], "defined_vars": ["well2_tube", "well2"], "parameters": ["(750, 700, 800)", "(750, 700, 0)"], "libraries": ["import pyvista as pv"]}
{"code": "\n# canvas object to rasterize the houses\ncvs = ds.Canvas(plot_width=W, plot_height=H, x_range=xrange, y_range=yrange)\nraster = cvs.points(df, x='x', y='y', agg=ds.min('id'))\n#\n", "task": "Using the `ds` library, create a canvas object called `cvs` with the specified width (`W`), height (`H`), and ranges for the x-axis (`xrange`) and y-axis (`yrange`). Then, use `cvs.points()` to plot the points from the dataframe `df` with `x` and `y` columns, aggregating them by the minimum value of the `id` column. Store the resulting raster object in a variable called `raster`.", "exec_path": "xarray-spatial-master", "context": "import pandas as pd\nimport datashader as ds\n# assume the data contain lat lon coords with some additional values\ndf = pd.DataFrame({'id': [0, 1, 2, 3, 4], 'x': [0, 1, 2, 0, 4], 'y': [\n                  2, 0, 1, 3, 1], 'column_1': [2, 3, 4, 2, 6], 'price': [1, 3, 4, 3, 7]})\n# bounding box of the raster\nxmin, xmax, ymin, ymax = (df.x.min(), df.x.max(), df.x.min(), df.x.max())\nxrange = (xmin, xmax)\nyrange = (ymin, ymax)\n# width and height of the raster image\nW, H = (800, 600)\n", "functions": ["ds.Canvas", "cvs.points", "ds.min"], "external_vars": ["xrange", "ds", "H", "df", "W", "yrange"], "defined_vars": ["raster", "cvs"], "parameters": ["df", "id"], "libraries": ["import datashader as ds", "import pandas as pd"]}
{"code": "\nstats.to_csv(\"mean.csv\", index=False)\n\n#\n", "task": "Save the statistical data contained in the variable `stats` to a CSV file named `mean.csv`, excluding the index column. You will need to define the variable `stats` before executing this instruction.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\npoint = ee.Geometry.Point([1.5, 1.5])\ncentroid = ee.Geometry.Point([-122.4439, 37.7538])\nimage = ee.ImageCollection(\n    'LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()\ndem = ee.Image('USGS/3DEP/10m')\nlandcover = ee.Image(\n    'USGS/NLCD_RELEASES/2019_REL/NLCD/2019').select('landcover')\nstats = geemap.image_stats_by_zone(dem, landcover, reducer='MEAN')\n", "functions": ["stats.to_csv"], "external_vars": ["stats"], "defined_vars": [], "parameters": ["mean.csv"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "import geemap", "import ee", "from geemap.datasets import DATA"]}
{"code": "\ndataset = ee.ImageCollection(\"JRC/GSW1_4/MonthlyHistory\")\ndataset.size()\n\n#\n", "task": "Using the Earth Engine library (`ee`), define a variable named `dataset` to represent the JRC Global Surface Water monthly history image collection. Then, calculate and display the size of the image collection.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\n", "functions": ["ee.ImageCollection", "dataset.size"], "external_vars": ["ee"], "defined_vars": ["dataset"], "parameters": ["JRC/GSW1_4/MonthlyHistory"], "libraries": ["from geemap.datasets import get_metadata", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nMap = geemap.Map(center=[40, -100], zoom=4)\nMap.add_basemap(\"Google Hybrid\")\n\nlegend_dict = {\n    \"11 Open Water\": \"466b9f\",\n    \"12 Perennial Ice/Snow\": \"d1def8\",\n    \"21 Developed, Open Space\": \"dec5c5\",\n    \"22 Developed, Low Intensity\": \"d99282\",\n    \"23 Developed, Medium Intensity\": \"eb0000\",\n    \"24 Developed High Intensity\": \"ab0000\",\n    \"31 Barren Land (Rock/Sand/Clay)\": \"b3ac9f\",\n    \"41 Deciduous Forest\": \"68ab5f\",\n    \"42 Evergreen Forest\": \"1c5f2c\",\n    \"43 Mixed Forest\": \"b5c58f\",\n    \"51 Dwarf Scrub\": \"af963c\",\n    \"52 Shrub/Scrub\": \"ccb879\",\n    \"71 Grassland/Herbaceous\": \"dfdfc2\",\n    \"72 Sedge/Herbaceous\": \"d1d182\",\n    \"73 Lichens\": \"a3cc51\",\n    \"74 Moss\": \"82ba9e\",\n    \"81 Pasture/Hay\": \"dcd939\",\n    \"82 Cultivated Crops\": \"ab6c28\",\n    \"90 Woody Wetlands\": \"b8d9eb\",\n    \"95 Emergent Herbaceous Wetlands\": \"6c9fb8\",\n}\n\nnlcd = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\")\nlandcover = nlcd.select(\"landcover\")\n\nMap.addLayer(landcover, {}, \"NLCD Land Cover 2019\")\nMap.add_legend(title=\"NLCD Land Cover Classification\", legend_dict=legend_dict)\nMap\n\n#\n", "task": "Using the `ee` and `geemap` libraries, create a map centered at coordinates [40, -100] with a zoom level of 4. Add the \"Google Hybrid\" basemap to the map. Define a dictionary `legend_dict` that maps NLCD land cover classes to their corresponding hex color codes. Then, load the 2019 NLCD land cover data from the `USGS/NLCD_RELEASES/2019_REL/NLCD/2019` Earth Engine image collection. Select the `landcover` band from the image and add it to the map, labeling it \"NLCD Land Cover 2019\". Finally, add a legend to the map using the `legend_dict` dictionary, titled \"NLCD Land Cover Classification\". Make sure to define the following variables: `legend_dict`, `Map`, `landcover`, and `nlcd`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\n# Load an image.\nimage = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318')\n", "functions": ["geemap.Map", "Map.add_basemap", "ee.Image", "nlcd.select", "Map.addLayer", "Map.add_legend"], "external_vars": ["ee", "geemap"], "defined_vars": ["nlcd", "Map", "legend_dict", "landcover"], "parameters": ["Google Hybrid", "USGS/NLCD_RELEASES/2019_REL/NLCD/2019", "landcover", "landcover", "NLCD Land Cover 2019", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "\ngg.download_gemgis_data.download_tutorial_data(filename=\"23_calculating_thickness_maps.zip\", dirpath=file_path)\n", "task": "Download the tutorial data for calculating thickness maps, named \"23_calculating_thickness_maps.zip\", into the directory specified by the variable \"file_path\" using the \"gg\" object. You need to define the following variables before executing this instruction: \"file_path\" and \"gg\".", "exec_path": "gemgis-main", "context": "import gemgis as gg\nfile_path = 'data/23_calculating_thickness_maps/'\n", "functions": ["gg.download_gemgis_data.download_tutorial_data"], "external_vars": ["file_path", "gg"], "defined_vars": [], "parameters": [], "libraries": ["import gemgis as gg"]}
{"code": "\nMap = geemap.Map(center=[40, -100], zoom=4)\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nimage = ee.Image().paint(states, 0, 2)\n\nMap.centerObject(states, 4)\nMap.addLayer(image, {}, \"US States\")\n\nMap.addLayerControl()\nMap\n\n#\n", "task": "Using the `ee` and `geemap` libraries, create a map centered on the United States at zoom level 4. Define variables named `image`, `states`, and `Map` to represent the following: \\n\\n1. **`states`**: A FeatureCollection of US states from the `TIGER/2018/States` dataset.\\n2. **`image`**: An image where US states are painted with a value of 0 and a width of 2 pixels.\\n3. **`Map`**: A `geemap` map object.\\n\\nCenter the map on the US states, add the `image` as a layer labeled \"US States\", and display the layer control.", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.foliumap as emap\nimport geemap as emap\nimport ee\nee.Initialize()\n", "functions": ["geemap.Map", "ee.FeatureCollection", "unknown_function.paint", "ee.Image", "Map.centerObject", "Map.addLayer", "Map.addLayerControl"], "external_vars": ["ee", "geemap"], "defined_vars": ["image", "Map", "states"], "parameters": ["TIGER/2018/States", "states", 0, 2, "states", 4, "image", "US States", "{}"], "libraries": ["import geemap.foliumap as emap", "import geemap as emap", "import ee", "import geemap"]}
{"code": "\nts = wxee.TimeSeries(\"NOAA/NWS/RTMA\")\n\n#\n", "task": "Using the `wxee` library, create a TimeSeries object named `ts` representing data from the \"NOAA/NWS/RTMA\" source.", "exec_path": "wxee-main", "context": "import wxee\nwxee.Initialize()\n", "functions": ["wxee.TimeSeries"], "external_vars": ["wxee"], "defined_vars": ["ts"], "parameters": ["NOAA/NWS/RTMA"], "libraries": ["import wxee"]}
{"code": "\n# In[ ]:\n\n#\n# Test with only one variable\nimg = geemap.netcdf_to_ee(nc_file=nc_file, var_names=\"u_wind\")\npalette = cm.palettes.YlOrRd\n\nMap = geemap.Map()\nMap.addLayer(img, {\"min\": -20, \"max\": 25, \"palette\": palette, \"opacity\": 0.6}, \"u_wind\")\nMap\n\n#\n", "task": "Using the geemap library, read the netCDF file `nc_file` and extract the variable \"u_wind\" into an Earth Engine image object called `img`. Utilize the `cm` library to define a color palette `palette` based on the YlOrRd colormap. Finally, use the geemap library to create an interactive map object called `Map` and add the `img` as a layer, setting the minimum and maximum values for the visualization, applying the defined palette, and setting the opacity to 0.6. Name the layer \"u_wind\".", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.colormaps as cm\nnc_file = '../data/wind_global.nc'\n", "functions": ["geemap.netcdf_to_ee", "geemap.Map", "Map.addLayer"], "external_vars": ["nc_file", "cm", "geemap"], "defined_vars": ["palette", "img", "Map"], "parameters": ["img", "u_wind", "{'min': -20, 'max': 25, 'palette': palette, 'opacity': 0.6}"], "libraries": ["import geemap.colormaps as cm", "import geemap"]}
{"code": "\ngdf1 = gpd.GeoDataFrame(geometry=[gmap_sorted.loc[2].geometry])\ngdf1\n\n#\n", "task": "Using the `gpd` library, create a GeoDataFrame named `gdf1` with the geometry of the second row (index 2) from the `gmap_sorted` GeoDataFrame.", "exec_path": "gemgis-main", "context": "import gemgis as gg\nimport geopandas as gpd\nfile_path = 'data/16_extracting_interfaces_from_geological_maps/'\ngmap = gpd.read_file(file_path + 'interfaces_polygons.shp')\nstratigraphy = ['Sand2', 'Ton', 'Sand1']\ngmap_sorted = gg.vector.sort_by_stratigraphy(\n    gdf=gmap, stratigraphy=stratigraphy)\n", "functions": ["gpd.GeoDataFrame"], "external_vars": ["gmap_sorted", "gpd"], "defined_vars": ["gdf1"], "parameters": [], "libraries": ["import gemgis as gg", "import geopandas as gpd"]}
{"code": "\nitem = items[0]\nprint(*[f\"{key}: {asset.title}\" for key, asset in item.assets.items()], sep=\"\\n\")\n\n#\n", "task": "Print the title of each asset associated with the first item in the list `items`. Format the output as `key: asset.title` where `key` is the key of the asset in the `item.assets` dictionary and `asset.title` is the title of the asset. Use `print` to display the output, separating each line with a newline character.  Make sure to define `key`, `item`, and `asset` variables before executing this code.", "exec_path": "PlanetaryComputerExamples-main", "context": "import pystac_client\nimport planetary_computer\n#\ncatalog = pystac_client.Client.open(\n    'https://planetarycomputer.microsoft.com/api/stac/v1', modifier=planetary_computer.sign_inplace)\nitems = list(catalog.get_collection('hgb').get_all_items())\n", "functions": ["print", "item.assets.items"], "external_vars": ["items", "print"], "defined_vars": ["asset", "key", "item"], "parameters": ["*[f'{key}: {asset.title}' for key, asset in item.assets.items()]"], "libraries": ["import planetary_computer", "import pystac_client"]}
{"code": "\nurl = \"https://open.gishub.org/data/raster/srtm90.tif\"\ndem = leafmap.download_file(url, \"srtm90.tif\")\n\n#\n", "task": "Using the `leafmap` library, download the SRTM90 elevation data from the provided URL and store it in a variable named `dem`. Make sure to define the variables `url` and `dem` before executing this code.", "exec_path": "leafmap-master", "context": "import leafmap.foliumap as leafmap\n", "functions": ["leafmap.download_file"], "external_vars": ["leafmap"], "defined_vars": ["dem", "url"], "parameters": ["url", "srtm90.tif"], "libraries": ["import leafmap.foliumap as leafmap"]}
{"code": "\ndf = geemap.ee_to_df(fc)\ndf\n\n#\n", "task": "Convert the Earth Engine feature collection `fc` to a pandas DataFrame named `df` using the `geemap.ee_to_df()` function.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nstates = ee.FeatureCollection('TIGER/2018/States')\nfc = states.filter(ee.Filter.eq('NAME', 'Alaska'))\n", "functions": ["geemap.ee_to_df"], "external_vars": ["geemap", "fc"], "defined_vars": ["df"], "parameters": ["fc"], "libraries": ["import ee", "import geemap"]}
{"code": "\ngdf = gg.raster.sample_interfaces(raster=raster.read(1), \n                                  random_samples=10,\n                                  extent=[0, 972, 0 ,1069],\n                                  formation='Test',\n                                  crs='EPSG:4326')\n\ngdf\n\n#\n", "task": "Using the `gg` and `raster` objects, define a GeoDataFrame called `gdf` by randomly sampling 10 points from the first raster layer. The sampling should be within the extent [0, 972, 0, 1069], with the formation set to \"Test\" and the coordinate reference system set to \"EPSG:4326\".", "exec_path": "gemgis-main", "context": "import gemgis as gg\nimport rasterio\nfile_path = 'data/08_sampling_interfaces_orientations_from_raster/'\nraster = rasterio.open(file_path + 'raster.tif')\n", "functions": ["gg.raster.sample_interfaces", "raster.read"], "external_vars": ["raster", "gg"], "defined_vars": ["gdf"], "parameters": [1], "libraries": ["import gemgis as gg", "import rasterio"]}
{"code": "\nMap = geemap.Map()\nMap.split_map(left_layer=\"HYBRID\", right_layer=\"ROADMAP\")\nMap\n\n#\n", "task": "Using the geemap library, create a Map object and split it into two layers, using the \"HYBRID\" layer on the left and the \"ROADMAP\" layer on the right. Define a variable called `Map` to represent the Map object.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import geojson_to_ee, ee_to_geojson\n", "functions": ["geemap.Map", "Map.split_map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["from geemap import geojson_to_ee, ee_to_geojson", "import geemap"]}
{"code": "\ngeemap.show_image(\"dem.jpg\")\n\n#\n", "task": "Using the geemap library, display the image \"dem.jpg\".", "exec_path": "geemap-master", "context": "import geemap\n", "functions": ["geemap.show_image"], "external_vars": ["geemap"], "defined_vars": [], "parameters": ["dem.jpg"], "libraries": ["import geemap"]}
{"code": "\nnaip_props.get(\"NOMINAL_SCALE\").getInfo()\n\n#\n", "task": "Get the information about the nominal scale from the `naip_props` dictionary.  **You will need to define the `naip_props` variable before running this code.**", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\ncentroid = ee.Geometry.Point([-122.4439, 37.7538])\nnaip = ee.ImageCollection('USDA/NAIP/DOQQ').filterBounds(centroid).first()\nnaip_props = geemap.image_props(naip)\n", "functions": ["unknown_function.getInfo", "naip_props.get"], "external_vars": ["naip_props"], "defined_vars": [], "parameters": ["NOMINAL_SCALE"], "libraries": ["import ee", "import geemap"]}
{"code": "\nfig, ax = plt.subplots(1, figsize=(5,5))\n\ninterfaces.plot(ax=ax, column='formation', legend=True, aspect='equal')\n\nplt.grid()\nax.set_xlabel('X [m]')\nax.set_ylabel('Y [m]')\n\n#\n", "task": "Using the libraries `plt` and `interfaces`, create a plot of the `formation` column from the `interfaces` data.  Set the plot to have an equal aspect ratio and display a grid. Label the x-axis as \"X [m]\" and the y-axis as \"Y [m]\".  The plot should be generated using `plt.subplots` to create a figure and axes object.  Make sure to save the figure and axes objects as `fig` and `ax` respectively.", "exec_path": "gemgis_data-main", "context": "import geopandas as gpd\nimport matplotlib.pyplot as plt\n#\nfile_path = 'data/example24_unconformable_layers/'\ninterfaces = gpd.read_file(file_path + 'interfaces24.shp')\n", "functions": ["plt.subplots", "interfaces.plot", "plt.grid", "ax.set_xlabel", "ax.set_ylabel"], "external_vars": ["plt", "interfaces"], "defined_vars": ["fig", "ax"], "parameters": [1, "X [m]", "Y [m]"], "libraries": ["import geopandas as gpd", "import matplotlib.pyplot as plt"]}
{"code": "\ncities_shp = \"../data/us_cities.shp\"\ncities = geemap.shp_to_ee(cities_shp)\nMap.addLayer(cities, {}, \"US Cities\")\n\n#\n", "task": "Using the `geemap` library, import the shapefile located at `../data/us_cities.shp` and convert it to an Earth Engine FeatureCollection.  Assign the shapefile path to the variable `cities_shp` and the converted FeatureCollection to the variable `cities`. Finally, add the `cities` FeatureCollection to the `Map` object, labeling it \"US Cities\".", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import geojson_to_ee, ee_to_geojson\nMap = geemap.Map()\n", "functions": ["geemap.shp_to_ee", "Map.addLayer"], "external_vars": ["Map", "geemap"], "defined_vars": ["cities", "cities_shp"], "parameters": ["cities_shp", "cities", "US Cities", "{}"], "libraries": ["from geemap import geojson_to_ee, ee_to_geojson", "import geemap"]}
{"code": "\nin_fc = geemap.shp_to_ee(in_shp)\nm.add_layer(in_fc, {}, \"Cities\")\n\n#\n", "task": "Using the geemap library, convert the shapefile stored in the variable `in_shp` to an Earth Engine feature collection and assign it to a new variable called `in_fc`. Then, add this feature collection to the map object `m` with the label \"Cities\".", "exec_path": "geemap-master", "context": "import geemap\nm = geemap.Map(center=[40, -100], zoom=4)\nin_shp = 'us_cities.shp'\n", "functions": ["geemap.shp_to_ee", "m.add_layer"], "external_vars": ["m", "geemap", "in_shp"], "defined_vars": ["in_fc"], "parameters": ["in_shp", "in_fc", "Cities", "{}"], "libraries": ["import geemap"]}
{"code": "\n# %%\n# **First option:** using the raster as a reference to match, we rasterize the vector in any projection and georeferenced grid. We simply have to pass the\n# :class:`~geoutils.Raster` as single argument to :func:`~geoutils.Vector.rasterize`. See :ref:`core-match-ref` for more details.\n\nvect_rasterized = vect.rasterize(rast)\nvect_rasterized.plot(ax=\"new\", cmap=\"viridis\")\n#\n", "task": "Rasterize the vector object `vect` using the raster object `rast`.  Store the result in a new variable called `vect_rasterized`. Then, plot the rasterized vector using a `viridis` colormap and create a new plot axes.", "exec_path": "geoutils-main", "context": "import geoutils as gu\n# sphinx_gallery_thumbnail_number = 2\nfilename_rast = gu.examples.get_path('everest_landsat_b4')\nfilename_vect = gu.examples.get_path('everest_rgi_outlines')\nrast = gu.Raster(filename_rast)\nvect = gu.Vector(filename_vect)\n", "functions": ["vect.rasterize", "vect_rasterized.plot"], "external_vars": ["rast", "vect"], "defined_vars": ["vect_rasterized"], "parameters": ["rast"], "libraries": ["import geoutils as gu"]}
{"code": "\nm = geemap.Map(center=[37.75, -122.45], zoom=12)\n\ncollection = (\n    ee.ImageCollection(\"COPERNICUS/S2_SR\")\n    .filterBounds(ee.Geometry.Point([-122.45, 37.75]))\n    .filterMetadata(\"CLOUDY_PIXEL_PERCENTAGE\", \"less_than\", 10)\n)\n\nvis_params = {\"min\": 0, \"max\": 4000, \"bands\": [\"B8\", \"B4\", \"B3\"]}\n\nm.add_time_slider(collection, vis_params)\nm\n\n#\n", "task": "Using the geemap and ee libraries, create a map centered at [37.75, -122.45] with a zoom level of 12. Then, filter the COPERNICUS/S2_SR image collection for images within the bounds of the point [-122.45, 37.75] and having a cloudy pixel percentage less than 10. Define a visualization parameters dictionary with minimum value 0, maximum value 4000, and bands \"B8\", \"B4\", \"B3\". Finally, add a time slider to the map using the filtered image collection and the visualization parameters. Make sure to define the variables collection, m, and vis_params.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map", "unknown_function.filterMetadata", "unknown_function.filterBounds", "ee.ImageCollection", "ee.Geometry.Point", "m.add_time_slider"], "external_vars": ["ee", "geemap"], "defined_vars": ["m", "collection", "vis_params"], "parameters": ["CLOUDY_PIXEL_PERCENTAGE", "less_than", 10, "COPERNICUS/S2_SR", "collection", "vis_params", "ee.Geometry.Point([-122.45, 37.75])", "[-122.45, 37.75]"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\ninterfaces = gpd.read_file(file_path + 'interfaces15.shp')\ninterfaces.head()\n\n#\n", "task": "Using the geopandas library (`gpd`) and the `file_path` variable, read the shapefile named \"interfaces15.shp\" and store the resulting GeoDataFrame in a variable named `interfaces`. Then, display the first few rows of the GeoDataFrame.", "exec_path": "gemgis-main", "context": "import geopandas as gpd\nfile_path = 'data/example15/'\n", "functions": ["gpd.read_file", "interfaces.head"], "external_vars": ["file_path", "gpd"], "defined_vars": ["interfaces"], "parameters": ["file_path + 'interfaces15.shp'"], "libraries": ["import geopandas as gpd"]}
{"code": "\ntimelapse = geemap.landsat_timelapse(\n    roi,\n    out_gif=\"hong_kong.gif\",\n    start_year=1990,\n    end_year=2022,\n    start_date=\"01-01\",\n    end_date=\"12-31\",\n    bands=[\"SWIR1\", \"NIR\", \"Red\"],\n    frames_per_second=3,\n    title=\"Hong Kong\",\n)\ngeemap.show_image(timelapse)\n\n#\n", "task": "Using the geemap library and the provided region of interest (roi), create a Landsat timelapse animation from 1990 to 2022. The animation should be saved as \"hong_kong.gif\" and display the SWIR1, NIR, and Red bands. Set the frame rate to 3 frames per second and add a title \"Hong Kong\". Define a variable called \"timelapse\" to store the created animation and then use geemap.show_image() to display it.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nstart_date = '2016-01-01'\nend_date = '2022-12-31'\nroi = ee.Geometry.BBox(113.8252, 22.1988, 114.0851, 22.3497)\n", "functions": ["geemap.landsat_timelapse", "geemap.show_image"], "external_vars": ["roi", "geemap"], "defined_vars": ["timelapse"], "parameters": ["roi", "timelapse"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\ngeemap.bar_chart(\n    \"forest_cover.csv\",\n    x=\"NAME\",\n    y=\"sum\",\n    max_rows=20,\n    x_label=\"Country\",\n    y_label=\"Forest area (km2)\",\n)\n\n#\n", "task": "Using the geemap library, create a bar chart from the \"forest_cover.csv\" file. Set the x-axis to \"NAME\" and the y-axis to \"sum\". Limit the chart to a maximum of 20 rows. Label the x-axis as \"Country\" and the y-axis as \"Forest area (km2)\".", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.bar_chart"], "external_vars": ["geemap"], "defined_vars": [], "parameters": ["forest_cover.csv"], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\n# Add Earth Engine layers to Map\nMap.addLayer(dem, vis_params, \"SRTM DEM\", True, 0.7)\n\nMap\n\n#\n", "task": "Add the `dem` layer to the `Map` using the provided `vis_params`. Name the layer \"SRTM DEM\", make it visible by default and set the opacity to 0.7.  [dem, Map, vis_params] need to be defined.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\n#\nMap = geemap.Map(center=(40, -100), zoom=4, height='750px')\n# Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\n# Set visualization parameters.\nvis_params = {'min': 0, 'max': 4000, 'palette': [\n    '006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']}\n", "functions": ["Map.addLayer"], "external_vars": ["dem", "Map", "vis_params"], "defined_vars": [], "parameters": ["dem", "vis_params", "SRTM DEM", true, 0.7], "libraries": ["import ee", "import geemap"]}
{"code": "\ncamera_oblique = ertsc.measure.PerspectiveCameraMeasure(\n    id=\"camera_oblique\",\n    origin=[15, 15, 15] * ureg.m,\n    target=[0, 0, 3.0] * ureg.m,\n    up=[0, 0, 1],\n    film_resolution=(320, 240),\n    spp=512,\n)\n\n#\n", "task": "Define a perspective camera named `camera_oblique` using the `ertsc.measure.PerspectiveCameraMeasure` function. Set the camera origin to [15, 15, 15] meters, target to [0, 0, 3.0] meters, up direction to [0, 0, 1], film resolution to (320, 240), and samples per pixel (spp) to 512. Use the `ureg` module for unit conversions.", "exec_path": "eradiate-tutorials-main", "context": "import eradiate.scenes as ertsc\nfrom eradiate import unit_registry as ureg\n", "functions": ["ertsc.measure.PerspectiveCameraMeasure"], "external_vars": ["ureg", "ertsc"], "defined_vars": ["camera_oblique"], "parameters": [], "libraries": ["import eradiate.scenes as ertsc", "from eradiate import unit_registry as ureg"]}
{"code": "\n# Add US census states\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nstyle = {\"fillColor\": \"00000000\"}\nm.add_layer(states.style(**style), {}, \"US States\")\n#\n", "task": "Using the Earth Engine library (`ee`) and the map object (`m`), add a layer of US states with a transparent fill color. Define the variables `states` and `style` for this purpose.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nm = geemap.Map(center=[40, -100], zoom=4)\n", "functions": ["ee.FeatureCollection", "m.add_layer", "states.style"], "external_vars": ["ee", "m"], "defined_vars": ["style", "states"], "parameters": ["TIGER/2018/States", "US States", "states.style(**style)", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nwidget.close()\n\n#\n", "task": "Close the widget. **[widget]** should be defined as a widget object.", "exec_path": "geemap-master", "context": "import geemap\nhtml = geemap.create_legend(title='NLCD Land Cover Type',\n                            builtin_legend='NLCD', draggable=False, position='bottomright')\nwidget = geemap.show_html(html)\n", "functions": ["widget.close"], "external_vars": ["widget"], "defined_vars": [], "parameters": [], "libraries": ["import geemap"]}
{"code": "\nMap.add_stac_layer(url, bands=[\"pan\"], name=\"Panchromatic\")\n\n#\n", "task": "Add a Panchromatic layer from the STAC URL `url` to the `Map` object.  Define the following variables: `bands` and `name`.", "exec_path": "leafmap-master", "context": "import leafmap\nMap = leafmap.Map()\nurl = 'https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json'\n", "functions": ["Map.add_stac_layer"], "external_vars": ["Map", "url"], "defined_vars": [], "parameters": ["url"], "libraries": ["import leafmap"]}
{"code": "\n###############################################################################\n# Weights in data decimation\n# --------------------------\n#\n# :class:`~verde.BlockReduce` can't output weights for each data point because\n# it doesn't know which reduction operation it's using. If you want to do a\n# weighted interpolation, like :class:`verde.Spline`,\n# :class:`~verde.BlockReduce` won't propagate the weights to the interpolation\n# function. If your data are relatively smooth, you can use\n# :class:`verde.BlockMean` instead to decimated data and produce weights. It\n# can calculate different kinds of weights, depending on configuration options\n# and what you give it as input.\n#\n# Let's explore all of the possibilities.\nmean = vd.BlockMean(spacing=15 / 60)\nprint(mean)\n#\n", "task": "Use the `vd.BlockMean` function to calculate the mean with a spacing of 15/60 and store the result in a variable called `mean`. Then, print the value of `mean` using the `print` function.", "exec_path": "verde-main", "context": "import verde as vd\n", "functions": ["vd.BlockMean", "print"], "external_vars": ["vd", "print"], "defined_vars": ["mean"], "parameters": ["mean"], "libraries": ["import verde as vd"]}
{"code": "\n# Create a synthetic geographic grid using a checkerboard pattern\nregion = (0, 360, -90, -60)\nspacing = 0.25\nwavelength = 10 * 1e5  # The size of the cells in the checkerboard\ncheckerboard = vd.synthetic.CheckerBoard(\n    region=vd.project_region(region, projection), w_east=wavelength, w_north=wavelength\n)\ndata = checkerboard.grid(\n    region=region,\n    spacing=spacing,\n    projection=projection,\n    data_names=\"checkerboard\",\n    dims=(\"latitude\", \"longitude\"),\n)\nprint(\"Geographic grid:\")\nprint(data)\n#\n", "task": "Using the \"vd\" library, create a checkerboard pattern with a wavelength of 10 * 100000.0 meters. The checkerboard should cover a region defined by the \"region\" variable, which should be projected using the \"projection\" variable. Then, generate a geographic grid of the checkerboard pattern with a spacing of 0.25 degrees. Store the generated data in the \"data\" variable. Finally, print the \"Geographic grid:\" followed by the \"data\". You will need to define the variables \"data\", \"region\", \"checkerboard\", \"wavelength\", and \"spacing\" before running this code. The \"print\" function and \"vd\" library are required for this task. ", "exec_path": "verde-main", "context": "import pyproj\nimport verde as vd\n# projection. EPSG 3031 is a South Polar Stereographic projection.\nprojection = pyproj.Proj('epsg:3031')\n", "functions": ["vd.synthetic.CheckerBoard", "vd.project_region", "checkerboard.grid", "print", "print"], "external_vars": ["projection", "vd", "print"], "defined_vars": ["spacing", "checkerboard", "wavelength", "region", "data"], "parameters": ["region", "projection", "Geographic grid:", "data"], "libraries": ["import pyproj", "import verde as vd"]}
{"code": "\nnaip_url = \"https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?\"\nMap.add_wms_layer(\n    url=naip_url, layers=\"0\", name=\"NAIP Imagery\", format=\"image/png\", shown=True\n)\n\n#\n", "task": "Add a NAIP Imagery layer to the map using the provided `naip_url`. Ensure the `Map` object is defined and the variable `naip_url` is defined before executing this instruction.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\n#\nMap = geemap.Map()\n", "functions": ["Map.add_wms_layer"], "external_vars": ["Map"], "defined_vars": ["naip_url"], "parameters": [], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA"]}
{"code": "\nout_dir = os.getcwd()\nout_shp = os.path.join(out_dir, \"world_cities.shp\")\n\n#\n", "task": "Using the `os` module, define a variable called `out_dir` that stores the current working directory. Then, define a variable called `out_shp` that represents the full path to a shapefile named \"world_cities.shp\" within the `out_dir` directory.", "exec_path": "leafmap-master", "context": "import os\n", "functions": ["os.getcwd", "os.path.join"], "external_vars": ["os"], "defined_vars": ["out_shp", "out_dir"], "parameters": ["out_dir", "world_cities.shp"], "libraries": ["import os"]}
{"code": "\n# Use a Mercator projection for our Cartesian gridder\nprojection = pyproj.Proj(proj=\"merc\", lat_ts=data.latitude.mean())\n#\n", "task": "Using the `pyproj` library, define a projection variable named `projection` using the Mercator projection (proj = 'merc'). Set the latitude of true scale (`lat_ts`) to the mean latitude of the `data` dataframe. ", "exec_path": "verde-main", "context": "import pyproj\nimport verde as vd\ndata = vd.datasets.fetch_texas_wind()\n", "functions": ["pyproj.Proj", "data.latitude.mean"], "external_vars": ["pyproj", "data"], "defined_vars": ["projection"], "parameters": [], "libraries": ["import pyproj", "import verde as vd"]}
{"code": "\nm = geemap.Map(center=[40, -100], zoom=4)\nm.add_basemap(\"Esri.WorldImagery\")\n\nlegend_dict = {\n    \"11 Open Water\": \"466b9f\",\n    \"12 Perennial Ice/Snow\": \"d1def8\",\n    \"21 Developed, Open Space\": \"dec5c5\",\n    \"22 Developed, Low Intensity\": \"d99282\",\n    \"23 Developed, Medium Intensity\": \"eb0000\",\n    \"24 Developed High Intensity\": \"ab0000\",\n    \"31 Barren Land (Rock/Sand/Clay)\": \"b3ac9f\",\n    \"41 Deciduous Forest\": \"68ab5f\",\n    \"42 Evergreen Forest\": \"1c5f2c\",\n    \"43 Mixed Forest\": \"b5c58f\",\n    \"51 Dwarf Scrub\": \"af963c\",\n    \"52 Shrub/Scrub\": \"ccb879\",\n    \"71 Grassland/Herbaceous\": \"dfdfc2\",\n    \"72 Sedge/Herbaceous\": \"d1d182\",\n    \"73 Lichens\": \"a3cc51\",\n    \"74 Moss\": \"82ba9e\",\n    \"81 Pasture/Hay\": \"dcd939\",\n    \"82 Cultivated Crops\": \"ab6c28\",\n    \"90 Woody Wetlands\": \"b8d9eb\",\n    \"95 Emergent Herbaceous Wetlands\": \"6c9fb8\",\n}\n\nnlcd = ee.Image(\"USGS/NLCD_RELEASES/2021_REL/NLCD/2021\")\nlandcover = nlcd.select(\"landcover\")\n\nm.add_layer(landcover, {}, \"NLCD Land Cover 2021\")\nm.add_legend(title=\"NLCD Land Cover Classification\", legend_dict=legend_dict)\nm\n\n#\n", "task": "Using the geemap and ee libraries, create an interactive map centered at [40, -100] with a zoom level of 4. Add the \"Esri.WorldImagery\" basemap. Define a dictionary called `legend_dict` to represent the NLCD land cover classes and their corresponding hex color codes. Load the 2021 NLCD land cover data from the `USGS/NLCD_RELEASES/2021_REL/NLCD/2021` asset and select the `landcover` band. Add the landcover data as a layer to the map. Finally, add a legend to the map using the `legend_dict`. Make sure to define the following variables: `m`, `nlcd`, `legend_dict`, `landcover`.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nimport ee\nee.Initialize()\nfrom geemap.datasets import get_metadata\ncollection = ee.ImageCollection('COPERNICUS/S2_SR')\ngeometry = ee.Geometry.Point([-86.893044, 41.718642])\nimages = collection.filterBounds(geometry).filterDate(\n    '2023-07-01', '2023-09-01').filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 5))\nimage = images.median()\n", "functions": ["geemap.Map", "m.add_basemap", "ee.Image", "nlcd.select", "m.add_layer", "m.add_legend"], "external_vars": ["geemap", "ee"], "defined_vars": ["legend_dict", "landcover", "nlcd", "m"], "parameters": ["Esri.WorldImagery", "USGS/NLCD_RELEASES/2021_REL/NLCD/2021", "landcover", "landcover", "NLCD Land Cover 2021", "{}"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import get_metadata"]}
{"code": "\n# Print the elevation of Mount Everest.\nxy = ee.Geometry.Point([86.9250, 27.9881])\nelev = image.sample(xy, 30).first().get(\"elevation\").getInfo()\nprint(\"Mount Everest elevation (m):\", elev)\n#\n", "task": "Using the provided `image` and `ee` objects, define a variable `xy` representing the coordinates of Mount Everest as an `ee.Geometry.Point`.  Sample the `image` at this point using `image.sample` with a radius of 30 meters, and store the elevation value in a variable named `elev`. Finally, print the elevation in meters using the `print` function.", "exec_path": "geemap-master", "context": "import geemap\nimport ee\nee.Initialize()\n# Add Earth Engine dataset\nimage = ee.Image('USGS/SRTMGL1_003')\n", "functions": ["ee.Geometry.Point", "unknown_function.getInfo", "unknown_function.get", "unknown_function.first", "image.sample", "print"], "external_vars": ["ee", "image", "print"], "defined_vars": ["elev", "xy"], "parameters": ["elevation", "xy", 30, "Mount Everest elevation (m):", "elev", "[86.925, 27.9881]"], "libraries": ["import ee", "import geemap"]}
{"code": "\n# Let's define a point of interest:\npoi = ee.Geometry.PointFromQuery(\"Oporto, Portugal\",user_agent = \"eemont-tutorial-024\")\n", "task": "Using the Earth Engine library (ee), define a variable named \"poi\" that represents a point geometry located in Oporto, Portugal. Use the `ee.Geometry.PointFromQuery` method with the query \"Oporto, Portugal\" and set the user agent to \"eemont-tutorial-024\".", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\nimport geemap.colormaps as cm\n", "functions": ["ee.Geometry.PointFromQuery"], "external_vars": ["ee"], "defined_vars": ["poi"], "parameters": ["Oporto, Portugal"], "libraries": ["import eemont", "import geemap.colormaps as cm", "import ee", "import geemap"]}
{"code": "\nwhiteboxgui.show(tree=True)\n\n#\n", "task": "Use the `whiteboxgui` object to display a visualization of the decision tree.", "exec_path": "geemap-master", "context": "import whiteboxgui\n", "functions": ["whiteboxgui.show"], "external_vars": ["whiteboxgui"], "defined_vars": [], "parameters": [], "libraries": ["import whiteboxgui"]}
{"code": "\ngeemap.ee_export_vector_to_drive(\n    fc, description=\"Alaska\", fileFormat=\"SHP\", folder=\"export\"\n)\n\n#\n", "task": "Export the feature collection `fc` to Google Drive as a Shapefile named \"Alaska\".  Use the `geemap.ee_export_vector_to_drive` function to perform the export. Set the file format to \"SHP\", and the folder to \"export\". Make sure to define `fc` and `geemap` before executing the code.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nstates = ee.FeatureCollection('TIGER/2018/States')\nfc = states.filter(ee.Filter.eq('NAME', 'Alaska'))\n", "functions": ["geemap.ee_export_vector_to_drive"], "external_vars": ["geemap", "fc"], "defined_vars": [], "parameters": ["fc"], "libraries": ["import ee", "import geemap"]}
{"code": "\nstart = ds.time.min()\ndelta_days = (ds.time - start).dt.days\ndelta_days_fire = (ds.FireMask * delta_days).astype(int)\n", "task": "Calculate the number of days since the first timestamp in the `ds` dataframe, and store it in the variable `delta_days`. Then, multiply the `delta_days` by the `FireMask` column in `ds` and convert it to an integer, storing the result in the variable `delta_days_fire`. You will need to define the variables `delta_days_fire`, `delta_days`, and `start`.", "exec_path": "wxee-main", "context": "import ee\nee.Initialize()\nimport wxee\nwxee.Initialize()\nmodis = wxee.TimeSeries(\n    'MODIS/006/MOD14A1').filterDate('2021-08-15', '2021-09-05').select('FireMask')\nfire_masks = modis.map(lambda img: img.eq(\n    9).copyProperties(img, img.propertyNames()))\nregion = ee.Geometry.Polygon([[[-120.70580745719522, 38.90798203224902], [-120.70580745719522, 38.51793451346024],\n                             [-119.90014827750772, 38.51793451346024], [-119.90014827750772, 38.90798203224902]]])\nds = fire_masks.wx.to_xarray(scale=1000, region=region, crs='EPSG:26910')\n", "functions": ["ds.time.min", "unknown_function.astype"], "external_vars": ["ds", "int"], "defined_vars": ["start", "delta_days_fire", "delta_days"], "parameters": ["int"], "libraries": ["import wxee", "import ee"]}
{"code": "\ndf = geemap.ee_to_df(features)\ndf\n\n#\n", "task": "Using the `geemap` library, convert the Earth Engine features object `features` into a Pandas DataFrame and assign it to the variable `df`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nimport geemap.chart as chart\nfeatures = ee.FeatureCollection(\n    'projects/google/charts_feature_example').select('[0-9][0-9]_tmean|label')\n", "functions": ["geemap.ee_to_df"], "external_vars": ["features", "geemap"], "defined_vars": ["df"], "parameters": ["features"], "libraries": ["import ee", "import geemap.chart as chart", "import geemap"]}
{"code": "\nMap = geemap.Map()\nMap\n\n#\n", "task": "Using the geemap library, create a new map object and assign it to the variable \"Map\".", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA"]}
{"code": "\nMap.add_colorbar(\n    vis_params,\n    label=\"Elevation (m)\",\n    layer_name=\"SRTM DEM\",\n    orientation=\"vertical\",\n    transparent_bg=True,\n    discrete=True,\n)\n\n#\n", "task": "Using the `Map` object and the `vis_params` dictionary, add a colorbar to the map. Set the colorbar label to \"Elevation (m)\", the layer name to \"SRTM DEM\", the orientation to \"vertical\", make the background transparent, and set the colorbar to discrete.  You will need to define the following variables:  []", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\n#\nMap = geemap.Map()\n# Set visualization parameters.\nvis_params = {'min': 0, 'max': 4000, 'palette': [\n    '006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']}\n", "functions": ["Map.add_colorbar"], "external_vars": ["vis_params", "Map"], "defined_vars": [], "parameters": ["vis_params"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA"]}
{"code": "\nm = leafmap.Map(height=\"400px\", width=\"800px\")\nm\n\n#\n", "task": "Using the `leafmap` library, create a new map object named `m` with a height of 400 pixels and a width of 800 pixels.", "exec_path": "leafmap-master", "context": "import leafmap\n", "functions": ["leafmap.Map"], "external_vars": ["leafmap"], "defined_vars": ["m"], "parameters": [], "libraries": ["import leafmap"]}
{"code": "\nMap = geemap.Map(center=[40, -100], zoom=4, height=600)\nMap\n\n#\n", "task": "Using the geemap library, create a new Map object named \"Map\" with the following parameters: center at coordinates [40, -100], zoom level 4, and a height of 600 pixels.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\n", "functions": ["geemap.Map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\ncamera_oblique = ertsc.measure.PerspectiveCameraMeasure(\n    id=\"camera_oblique\",\n    origin=[10, 10, 10] * ureg.m,\n    target=[0, 0, 0.0] * ureg.m,\n    up=[0, 0, 1],\n    film_resolution=(640, 480),\n    spp=128,\n)\n", "task": "Define a perspective camera named \"camera_oblique\" using the `ertsc.measure.PerspectiveCameraMeasure` function. Set its origin to [10, 10, 10] meters using the `ureg` module, target to [0, 0, 0] meters, up vector to [0, 0, 1], film resolution to (640, 480) pixels, and samples per pixel to 128.", "exec_path": "eradiate-tutorials-main", "context": "import eradiate.scenes as ertsc\nfrom eradiate import unit_registry as ureg\n", "functions": ["ertsc.measure.PerspectiveCameraMeasure"], "external_vars": ["ureg", "ertsc"], "defined_vars": ["camera_oblique"], "parameters": [], "libraries": ["import eradiate.scenes as ertsc", "from eradiate import unit_registry as ureg"]}
{"code": "\nm = geemap.Map()\nstyle = {\"fillColor\": \"00000000\"}\nm.add_layer(lat_grid.style(**style), {}, \"Latitude Grid\")\nm\n\n#\n", "task": "Define variables named `m` and `style` to create a Geemap map and add a latitude grid layer. The latitude grid layer is defined by the variable `lat_grid` using the `geemap` library.  The layer should be styled with a fill color of `00000000`.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nlat_grid = geemap.latitude_grid(\n    step=5.0, west=-180, east=180, south=-85, north=85)\n", "functions": ["geemap.Map", "m.add_layer", "lat_grid.style"], "external_vars": ["lat_grid", "geemap"], "defined_vars": ["m", "style"], "parameters": ["Latitude Grid", "lat_grid.style(**style)", "{}"], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nMap = geemap.Map()\nstyle = {\"fillColor\": \"00000000\"}\nMap.addLayer(lon_grid.style(**style), {}, \"Longitude Grid\")\nMap\n\n#\n", "task": "Using the `geemap` library, create a map object named `Map` and a style dictionary named `style` with a fill color of '00000000'. Then, add a layer to the map using the `lon_grid` object, applying the `style` dictionary to it. Name the layer \"Longitude Grid\".", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nlon_grid = geemap.longitude_grid(\n    step=5.0, west=-180, east=180, south=-85, north=85)\n", "functions": ["geemap.Map", "Map.addLayer", "lon_grid.style"], "external_vars": ["lon_grid", "geemap"], "defined_vars": ["style", "Map"], "parameters": ["Longitude Grid", "lon_grid.style(**style)", "{}"], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nimg = mpimg.imread('data/images/example28/dem_example28.png')\nplt.figure(figsize=(10, 10))\nimgplot = plt.imshow(img)\nplt.axis('off')\nplt.tight_layout()\n\n#\n", "task": "Using the `mpimg` and `plt` libraries, read the image file \"data/images/example28/dem_example28.png\" into a variable called `img`. Then, display this image using `plt.imshow()` and store the resulting image plot in a variable called `imgplot`. Finally, turn off the axes and adjust the layout for better visualization.", "exec_path": "gemgis-main", "context": "import matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n", "functions": ["mpimg.imread", "plt.figure", "plt.imshow", "plt.axis", "plt.tight_layout"], "external_vars": ["plt", "mpimg"], "defined_vars": ["img", "imgplot"], "parameters": ["data/images/example28/dem_example28.png", "img", "off"], "libraries": ["import matplotlib.image as mpimg", "import matplotlib.pyplot as plt"]}
{"code": "\npath_raster = \"data/16_plotHIST/LC08_232066_20190727_SR.tif\"\nimg = rasterio.open(path_raster)\n\n#\n", "task": "Using the `rasterio` library, open the raster file located at the path specified by the `path_raster` variable and store the resulting raster object in the variable `img`.", "exec_path": "scikit-eo-main", "context": "import rasterio\n", "functions": ["rasterio.open"], "external_vars": ["rasterio"], "defined_vars": ["img", "path_raster"], "parameters": ["path_raster"], "libraries": ["import rasterio"]}
{"code": "\n# Get and filter the image collection.\nMOD16A2 = ee.ImageCollection('MODIS/006/MOD16A2').select('ET')\n", "task": "Using the Earth Engine library (`ee`), define a variable called `MOD16A2` as an image collection. The image collection should be from the MODIS Terra Land Surface Temperature and Vegetation Index (MOD16A2) collection and select the `ET` band.", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport datetime\nimport geemap\n", "functions": ["unknown_function.select", "ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["MOD16A2"], "parameters": ["ET", "MODIS/006/MOD16A2"], "libraries": ["import eemont", "import ee", "import datetime", "import geemap"]}
{"code": "\nm = geemap.Map(center=(40, -100), zoom=4)\ndem = ee.Image(\"USGS/SRTMGL1_003\")\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nvis_params = {\n    \"min\": 0,\n    \"max\": 4000,\n    \"palette\": [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"],\n}\nm.add_layer(dem, vis_params, \"SRTM DEM\")\nm.add_layer(states, {}, \"US States\")\nm.add(\"layer_manager\")\nm\n\n#\n", "task": "Using the geemap and ee libraries, create a map centered at (40, -100) with zoom level 4. Add the SRTMGL1_003 elevation data as a layer with the specified visualization parameters. Then, add a layer showing US States. Finally, add a layer manager to the map. You will need to define the following variables: m, vis_params, states, dem.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nimport ee\nee.Initialize()\nfrom geemap.datasets import get_metadata\n", "functions": ["geemap.Map", "ee.Image", "ee.FeatureCollection", "m.add_layer", "m.add_layer", "m.add"], "external_vars": ["geemap", "ee"], "defined_vars": ["vis_params", "dem", "states", "m"], "parameters": ["USGS/SRTMGL1_003", "TIGER/2018/States", "dem", "vis_params", "SRTM DEM", "states", "US States", "layer_manager", "{}"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import get_metadata"]}
{"code": "\nsize = images.size().getInfo()\n\n#\n", "task": "Get the size of the image object stored in the variable `images` and store it in a variable named `size`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nregion = ee.Geometry.Polygon([[[-99.101934, 47.12745], [-99.101934, 47.156232],\n                             [-99.033441, 47.156232], [-99.033441, 47.12745], [-99.101934, 47.12745]]])\ncollection = geemap.naip_timeseries(region, RGBN=True)\nimages = collection.toList(collection.size())\n", "functions": ["unknown_function.getInfo", "images.size"], "external_vars": ["images"], "defined_vars": ["size"], "parameters": [], "libraries": ["import ee", "import geemap"]}
{"code": "\nm = leafmap.Map(center=[0, 0], zoom=2)\n\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\n\nstyle = {\n    \"stroke\": True,\n    \"color\": \"#0000ff\",\n    \"weight\": 2,\n    \"opacity\": 1,\n    \"fill\": True,\n    \"fillColor\": \"#0000ff\",\n    \"fillOpacity\": 0.1,\n}\n\nhover_style = {\"fillOpacity\": 0.7}\n\nm.add_geojson(url, layer_name=\"Countries\", style=style, hover_style=hover_style)\nm\n\n#\n", "task": "Using the **leafmap** library, create an interactive map centered at coordinates [0, 0] with a zoom level of 2. Then, load a GeoJSON file from the provided URL and add it to the map as a layer named \"Countries\". Apply the specified style and hover_style dictionaries to the GeoJSON layer.  Ensure the variables **hover_style**, **m**, **style**, and **url** are defined before executing the code.", "exec_path": "leafmap-master", "context": "import leafmap\n", "functions": ["leafmap.Map", "m.add_geojson"], "external_vars": ["leafmap"], "defined_vars": ["m", "style", "url", "hover_style"], "parameters": ["url"], "libraries": ["import leafmap"]}
{"code": "\n# Add Earth Engine dataset\ndem = ee.Image(\"USGS/SRTMGL1_003\")\nlandsat7 = ee.Image(\"LANDSAT/LE7_TOA_5YEAR/1999_2003\").select(\n    [\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B7\"]\n)\n\nvis_params = {\n    \"min\": 0,\n    \"max\": 4000,\n    \"palette\": [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"],\n}\n\nMap.addLayer(dem, vis_params, \"SRTM DEM\", True, 1)\nMap.addLayer(\n    landsat7,\n    {\"bands\": [\"B4\", \"B3\", \"B2\"], \"min\": 20, \"max\": 200, \"gamma\": 2},\n    \"Landsat 7\",\n)\nMap\n\n#\n", "task": "Using the Earth Engine library (ee), load the SRTM Global 1 arc-second elevation data and the Landsat 7 TOA 5-year composite for 1999-2003. Define the following variables: **dem** (Earth Engine image representing SRTM elevation), **landsat7** (Earth Engine image representing Landsat 7 data), and **vis_params** (dictionary defining visualization parameters for the SRTM data). Use the Map object to add these layers to the map, displaying the SRTM elevation data with a custom color palette and the Landsat 7 data using bands 4, 3, and 2 for red, green, and blue, respectively.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nimport ee\nee.Initialize()\nMap = geemap.Map(center=(40, -100), zoom=4)\n", "functions": ["ee.Image", "unknown_function.select", "ee.Image", "Map.addLayer", "Map.addLayer"], "external_vars": ["Map", "ee"], "defined_vars": ["vis_params", "dem", "landsat7"], "parameters": ["USGS/SRTMGL1_003", "LANDSAT/LE7_TOA_5YEAR/1999_2003", "dem", "vis_params", "SRTM DEM", true, 1, "landsat7", "Landsat 7", "['B1', 'B2', 'B3', 'B4', 'B5', 'B7']", "{'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2}"], "libraries": ["import ee", "import geemap", "from geemap import cartoee", "from geemap.datasets import DATA"]}
{"code": "\nlen(dates)\n\n#\n", "task": "Determine the number of elements in the list called \"dates\". You will need to define the variable \"dates\" before running this code.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\ncollection = ee.ImageCollection(\n    'MODIS/061/MOD13A2').filterDate('2015-01-01', '2019-12-31').select('NDVI')\ndates = geemap.image_dates(collection).getInfo()\n", "functions": ["len"], "external_vars": ["len", "dates"], "defined_vars": [], "parameters": ["dates"], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "import geemap", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nm.set_plot_options(add_marker_cluster=True, overlay=True)\n\n#\n", "task": "Using the map object `m`, configure the plot options to add marker clusters and overlay the clusters on the map. **Note**: This assumes you have a map object named `m` already defined and you will need to define the `add_marker_cluster` and `overlay` functions before running this code.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nm = geemap.Map(center=[40, -100], zoom=4)\n", "functions": ["m.set_plot_options"], "external_vars": ["m"], "defined_vars": [], "parameters": [], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\n# Defining empty lith_block array\nlith_blocks = np.array([])\n#\n", "task": "Using the NumPy library (imported as `np`), create an empty array named `lith_blocks`.", "exec_path": "gemgis-main", "context": "import numpy as np\n", "functions": ["np.array"], "external_vars": ["np"], "defined_vars": ["lith_blocks"], "parameters": ["[]"], "libraries": ["import numpy as np"]}
{"code": "\n# Add US census states\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nstyle = {\"fillColor\": \"00000000\"}\nMap.addLayer(states.style(**style), {}, \"US States\")\n#\n", "task": "Using the Earth Engine library (`ee`) and the Map object, define a FeatureCollection called `states` representing the US states from the TIGER/2018 dataset. Then, define a style dictionary called `style` with a transparent fill color. Finally, add the styled states to the map, using the label \"US States\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nMap = geemap.Map(center=[40, -100], zoom=4)\n", "functions": ["ee.FeatureCollection", "Map.addLayer", "states.style"], "external_vars": ["ee", "Map"], "defined_vars": ["style", "states"], "parameters": ["TIGER/2018/States", "US States", "states.style(**style)", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\ndem = ee.Image(\"USGS/SRTMGL1_003\")\n\nvis_params = {\n    \"min\": 0,\n    \"max\": 4000,\n    \"palette\": [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"],\n}\n\nMap.addLayer(dem, vis_params, \"DEM\")\n\n#\n", "task": "Using the ee and Map objects, define a variable named `dem` to represent the SRTMGL1_003 elevation data. Define a dictionary named `vis_params` to set the minimum, maximum, and color palette for visualizing the elevation data. Then, add the `dem` image to the Map using `vis_params` and the label \"DEM\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\n#\nMap = geemap.Map(center=[40, -100], zoom=4)\n", "functions": ["ee.Image", "Map.addLayer"], "external_vars": ["ee", "Map"], "defined_vars": ["dem", "vis_params"], "parameters": ["USGS/SRTMGL1_003", "dem", "vis_params", "DEM"], "libraries": ["import ee", "import geemap"]}
{"code": "\nout = widgets.Output(layout={\"border\": \"1px solid black\"})\nout\n\n#\n", "task": "Using the `widgets` library, create a new output widget named `out` with a border of 1px solid black.", "exec_path": "geemap-master", "context": "import ipywidgets as widgets\n", "functions": ["widgets.Output"], "external_vars": ["widgets"], "defined_vars": ["out"], "parameters": [], "libraries": ["import ipywidgets as widgets"]}
{"code": "\n# Add NLCD data\ndataset = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\")\nlandcover = dataset.select(\"landcover\")\nMap.addLayer(landcover, {}, \"NLCD 2019\")\n#\n", "task": "Using the Earth Engine library (`ee`) and the `Map` object, load the 2019 National Land Cover Database (NLCD) dataset. Define variables named `dataset` and `landcover` to store the loaded image and the \"landcover\" band, respectively. Then, add the `landcover` band to the map with the label \"NLCD 2019\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nMap = geemap.Map(center=[40, -100], zoom=4)\nimage = ee.ImageCollection('COPERNICUS/S2').filterDate('2018-09-01',\n                                                       '2018-09-30').map(lambda img: img.divide(10000)).median()\n", "functions": ["ee.Image", "dataset.select", "Map.addLayer"], "external_vars": ["ee", "Map"], "defined_vars": ["landcover", "dataset"], "parameters": ["USGS/NLCD_RELEASES/2019_REL/NLCD/2019", "landcover", "landcover", "NLCD 2019", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\n# calculate NDVI for each image using the map function\nndvi_images = collection.map(lambda image: image.normalizedDifference([\"B5\", \"B4\"]))\n\nvizParams = {\"bands\": [\"B5\", \"B4\", \"B3\"], \"min\": 0, \"max\": 0.4}\n\nMap = geemap.Map(center=[40, -100], zoom=4)\n", "task": "Calculate the NDVI for each image in the collection using the `normalizedDifference` method and store the resulting images in a new variable called `ndvi_images`. Then, define a `vizParams` dictionary for visualizing the NDVI images with bands `B5`, `B4`, and `B3`, setting the minimum and maximum values to 0 and 0.4 respectively. Finally, create a `Map` object using the `geemap` library centered at coordinates [40, -100] and set the zoom level to 4.", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.foliumap as emap\nimport geemap as emap\nimport ee\nee.Initialize()\npoint = ee.Geometry.Point(-83.93, 35.85)\n# select three Landsat 8 imagery in the Knoxville area with the least cloud coverage\ncollection = ee.ImageCollection(\n    'LANDSAT/LC8_L1T_TOA').filterBounds(point).sort('CLOUD_COVER').limit(3)\n", "functions": ["collection.map", "image.normalizedDifference", "geemap.Map"], "external_vars": ["collection", "image", "geemap"], "defined_vars": ["ndvi_images", "Map", "vizParams"], "parameters": ["lambda image: image.normalizedDifference(['B5', 'B4'])", "['B5', 'B4']"], "libraries": ["import geemap.foliumap as emap", "import geemap as emap", "import ee", "import geemap"]}
{"code": "\n#Initialize reader\nmeta_path = tempfile.mkdtemp()\nISMN_reader = ismn.ISMN_Interface(path_to_ismn_data, meta_path=meta_path)\nlist(ISMN_reader.stations_that_measure('soil_moisture'))\n\n#\n", "task": "Using the `tempfile` module, create a temporary directory and assign it to the variable `meta_path`. Then, initialize an `ISMN_Interface` object from the `ismn` module, using `path_to_ismn_data` as the path to the ISMN data and `meta_path` as the meta path. Finally, using the `list` function, return a list of all stations that measure \"soil_moisture\" using the `ISMN_reader` object.", "exec_path": "pytesmo-master", "context": "import ismn.interface as ismn\nimport tempfile\n# set path to ISMN data\npath_to_ismn_data = './test-data/ismn/multinetwork/header_values'\n", "functions": ["tempfile.mkdtemp", "ismn.ISMN_Interface", "list", "ISMN_reader.stations_that_measure"], "external_vars": ["path_to_ismn_data", "ismn", "tempfile", "list"], "defined_vars": ["meta_path", "ISMN_reader"], "parameters": ["path_to_ismn_data", "soil_moisture", "ISMN_reader.stations_that_measure('soil_moisture')"], "libraries": ["import tempfile", "import ismn.interface as ismn"]}
{"code": "\n# In[ ]:\n\n#\n# Draw any shapes on the map using the Drawing tools before executing this code block\nroi = Map.user_roi\n\nif roi is None:\n    roi = ee.Geometry.Polygon(\n        [\n            [\n                [-115.413031, 35.889467],\n                [-115.413031, 36.543157],\n                [-114.034328, 36.543157],\n                [-114.034328, 35.889467],\n                [-115.413031, 35.889467],\n            ]\n        ]\n    )\n\n#\n", "task": "Define a variable `roi` that represents a region of interest. If the user-defined region of interest (`Map.user_roi`) is not available, set `roi` to a predefined polygon using the `ee.Geometry.Polygon` function with the specified coordinates.", "exec_path": "geemap-master", "context": "import geemap\nimport ee\nee.Initialize()\nfrom geemap.datasets import DATA\nimport geemap.colormaps as cm\n#\nMap = geemap.Map()\n", "functions": ["ee.Geometry.Polygon"], "external_vars": ["ee", "Map"], "defined_vars": ["roi"], "parameters": ["[[[-115.413031, 35.889467], [-115.413031, 36.543157], [-114.034328, 36.543157], [-114.034328, 35.889467], [-115.413031, 35.889467]]]"], "libraries": ["import geemap.colormaps as cm", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\ntopo = gpd.read_file(file_path + 'topo13.shp')\ntopo.head()\n\n#\n", "task": "Read the shapefile \"topo13.shp\" from the specified file path using the geopandas library and assign it to the variable \"topo\". Then, display the first few rows of the dataframe using the .head() method.", "exec_path": "gemgis-main", "context": "import geopandas as gpd\nfile_path = 'data/example13/'\n", "functions": ["gpd.read_file", "topo.head"], "external_vars": ["file_path", "gpd"], "defined_vars": ["topo"], "parameters": ["file_path + 'topo13.shp'"], "libraries": ["import geopandas as gpd"]}
{"code": "\nimage = ee.Image(\"LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318\").select(4).gt(0.2)\nMap.setCenter(-122.1899, 37.5010, 13)\nMap.addLayer(image, {}, \"NIR threshold\")\n#\n", "task": "Using the Earth Engine library (ee), load the Landsat 8 image with ID \"LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318\". Select the Near-Infrared band (band 4). Create a binary image (image) by setting all values greater than 0.2 to 1 and the rest to 0. Center the map at coordinates (-122.1899, 37.501) with zoom level 13 using the Map object. Add the binary image (image) to the map with the label \"NIR threshold\".", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.foliumap as emap\nimport geemap as emap\nimport ee\nee.Initialize()\nMap = geemap.Map(center=[40, -100], zoom=4)\n", "functions": ["unknown_function.gt", "unknown_function.select", "ee.Image", "Map.setCenter", "Map.addLayer"], "external_vars": ["ee", "Map"], "defined_vars": ["image"], "parameters": [0.2, 4, "LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318", 37.501, 13, "image", "NIR threshold", "-122.1899", "{}"], "libraries": ["import geemap.foliumap as emap", "import geemap as emap", "import ee", "import geemap"]}
{"code": "\nclient = dask.distributed.Client(processes=False)\nprint(f\"/proxy/{client.scheduler_info()['services']['dashboard']}/status\")\n\n#\n", "task": "Using the `dask` library, create a client object named `client` without running separate processes. Then, print the URL to the Dask dashboard using the `print` function.", "exec_path": "PlanetaryComputerExamples-main", "context": "import dask.distributed\n", "functions": ["dask.distributed.Client", "print", "client.scheduler_info"], "external_vars": ["dask", "print"], "defined_vars": ["client"], "parameters": ["f'/proxy/{client.scheduler_info()['services']['dashboard']}/status'"], "libraries": ["import dask.distributed"]}
{"code": "\nsearch = catalog.search(\n    collections=[\"sentinel-1-rtc\"], datetime=\"2021-12-17\", bbox=bbox\n)\nitems = search.get_all_items()\nprint(f\"Found {len(items)} items\")\nitem = items[0]\nitem\n\n#\n", "task": "Using the `catalog` object, search for Sentinel-1 RTC data within the bounding box `bbox` on December 17th, 2021. Store the search results in a variable called `search`. Then, retrieve all matching items from the search results and store them in a variable called `items`. Print the number of found items using the `print` function and the `len` function. Finally, define a variable called `item` and assign it the first item from the `items` list.", "exec_path": "PlanetaryComputerExamples-main", "context": "import planetary_computer\nimport pystac_client\nlon, lat = [-121.95, 47.04]\nbuffer = 0.2\nbbox = [lon - buffer, lat - buffer, lon + buffer, lat + buffer]\ncatalog = pystac_client.Client.open(\n    'https://planetarycomputer.microsoft.com/api/stac/v1', modifier=planetary_computer.sign_inplace)\n", "functions": ["catalog.search", "search.get_all_items", "print", "len"], "external_vars": ["catalog", "len", "bbox", "print"], "defined_vars": ["items", "search", "item"], "parameters": ["items", "f'Found {len(items)} items'"], "libraries": ["import planetary_computer", "import pystac_client"]}
{"code": "\nMap.addLayerControl()\nMap\n", "task": "Add a layer control to the map, `Map`. Make sure to define the following variables: [].", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.foliumap as emap\nimport geemap as emap\nMap = geemap.Map(center=[40, -100], zoom=4)\n", "functions": ["Map.addLayerControl"], "external_vars": ["Map"], "defined_vars": [], "parameters": [], "libraries": ["import geemap.foliumap as emap", "import geemap as emap", "import geemap"]}
{"code": "\nleafmap.download_file(url, output=filename)\n\n#\n", "task": "Download a file from the given URL using the `leafmap` library and save it to the specified filename. Make sure you have defined the following variables before executing this instruction: `leafmap`, `filename`, `url`.", "exec_path": "leafmap-master", "context": "import leafmap\n#\nurl = 'https://github.com/opengeos/leafmap/raw/master/examples/data/wind_global.nc'\nfilename = 'wind_global.nc'\n", "functions": ["leafmap.download_file"], "external_vars": ["leafmap", "filename", "url"], "defined_vars": [], "parameters": ["url"], "libraries": ["import leafmap"]}
{"code": "\ndf = leafmap.csv_to_df(in_csv)\ndf\n", "task": "Using the `leafmap` library, read the CSV file specified by the `in_csv` variable and store the resulting DataFrame in a variable called `df`.", "exec_path": "leafmap-master", "context": "import leafmap.leafmap as leafmap\n# Read a CSV as a Pandas DataFrame.\nin_csv = 'https://raw.githubusercontent.com/opengeos/data/main/world/world_cities.csv'\n", "functions": ["leafmap.csv_to_df"], "external_vars": ["leafmap", "in_csv"], "defined_vars": ["df"], "parameters": ["in_csv"], "libraries": ["import leafmap.leafmap as leafmap"]}
{"code": "\n# ## Landsat 4, 5 and 7, Collection 2, Pre-processing and Processing\nL7 = (ee.ImageCollection(\"LANDSAT/LE07/C02/T1_L2\")\n      .filterBounds(poi)\n      .filterDate(\"2020-01-01\",\"2021-01-01\")\n      .preprocess()\n      .spectralIndices(\"EVI\")\n      .median())\n", "task": "Using the Earth Engine library (ee) and a Point of Interest (poi), define a variable named L7 that represents the median EVI (Enhanced Vegetation Index) for Landsat 7 imagery within the poi boundary, collected between January 1st, 2020, and January 1st, 2021.  The imagery should be preprocessed.", "exec_path": "eemont-master", "context": "import ee\nee.Initialize()\nimport eemont\nimport geemap\nimport geemap.colormaps as cm\npoi = ee.Geometry.BBoxFromQuery('Belice', user_agent='eemont-tutorial-029')\n", "functions": ["unknown_function.median", "unknown_function.spectralIndices", "unknown_function.preprocess", "unknown_function.filterDate", "unknown_function.filterBounds", "ee.ImageCollection"], "external_vars": ["poi", "ee"], "defined_vars": ["L7"], "parameters": ["EVI", "2020-01-01", "2021-01-01", "poi", "LANDSAT/LE07/C02/T1_L2"], "libraries": ["import eemont", "import geemap.colormaps as cm", "import ee", "import geemap"]}
{"code": "\n# In[ ]:\n\n#\n# Create a dictionary of properties, some of which may be computed values.\nprops = {\"foo\": ee.Number(8).add(88), \"bar\": \"nihao\"}\n#\n", "task": "Using the external variable `ee`, define a dictionary named `props` with the following key-value pairs:  `foo`: the result of adding 88 to the number 8 using the `ee.Number` function, and `bar`: the string \"nihao\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nimport geemap.colormaps as cm\n", "functions": ["unknown_function.add", "ee.Number"], "external_vars": ["ee"], "defined_vars": ["props"], "parameters": [88, 8], "libraries": ["from geemap.datasets import get_metadata", "import geemap.colormaps as cm", "import geemap", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nMap.ts_inspector(\n    left_ts=collection,\n    right_ts=collection,\n    left_names=years,\n    right_names=years,\n    left_vis=vis_params,\n    right_vis=vis_params,\n    width=\"80px\",\n)\nMap\n\n#\n", "task": "Use the `Map` class to create a time series inspector with the following parameters:\\n\\n* `left_ts`: `collection`\\n* `right_ts`: `collection`\\n* `left_names`: `years`\\n* `right_names`: `years`\\n* `left_vis`: `vis_params`\\n* `right_vis`: `vis_params`\\n* `width`: `80px`\\n\\n**Note**: You need to define the variables `collection`, `years`, and `vis_params` before running this code.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nMap = geemap.Map(center=[40, -100], zoom=4)\ncollection = ee.ImageCollection(\n    'USGS/NLCD_RELEASES/2019_REL/NLCD').select('landcover')\nvis_params = {'bands': ['landcover']}\nyears = collection.aggregate_array('system:index').getInfo()\n", "functions": ["Map.ts_inspector"], "external_vars": ["collection", "years", "Map", "vis_params"], "defined_vars": [], "parameters": [], "libraries": ["from geemap.datasets import get_metadata", "import ee", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\ngeemap.image_stats_by_zone(dem, landcover, out_csv=\"std.csv\", reducer=\"STD\")\n\n#\n", "task": "Using the geemap library, calculate the standard deviation of the elevation data (`dem`) within each landcover zone (`landcover`). Store the results in a CSV file named `std.csv`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\ncentroid = ee.Geometry.Point([-122.4439, 37.7538])\nimage = ee.ImageCollection(\n    'LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()\ndem = ee.Image('USGS/3DEP/10m')\nlandcover = ee.Image(\n    'USGS/NLCD_RELEASES/2021_REL/NLCD/2021').select('landcover')\n", "functions": ["geemap.image_stats_by_zone"], "external_vars": ["dem", "geemap", "landcover"], "defined_vars": [], "parameters": ["dem", "landcover"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nMap = geemap.Map()\nMap.split_map()\nMap\n\n#\n", "task": "Using the geemap library, create a new map object called \"Map\". Then, split the map into multiple tiles.", "exec_path": "geemap-master", "context": "import geemap\n", "functions": ["geemap.Map", "Map.split_map"], "external_vars": ["geemap"], "defined_vars": ["Map"], "parameters": [], "libraries": ["import geemap"]}
{"code": "\n# plot the result with cartoee using a PlateCarre projection (default)\nax = cartoee.get_map(blend, region=bbox, proj=projection)\ncb = cartoee.add_colorbar(ax, vis_params=vis_params, loc=\"right\")\n\nax.set_title(label=\"MODIS NDVI\", fontsize=15)\n#\n", "task": "Using the cartoee library, generate a map of the MODIS NDVI data. The map should use the provided `blend` data, be projected using `projection`, and be clipped to the bounding box `bbox`. Use the provided `vis_params` to add a colorbar to the right of the map.  Define variables `ax` and `cb` to store the resulting map axes and colorbar respectively. Finally, set the title of the map to \"MODIS NDVI\" with a font size of 15.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap import cartoee\nimport cartopy.crs as ccrs\nimage = ee.ImageCollection('MODIS/MCD43A4_006_NDVI').filter(\n    ee.Filter.date('2018-04-01', '2018-05-01')).select('NDVI').first()\nvis_params = {'min': 0.0, 'max': 1.0, 'palette': ['FFFFFF', 'CE7E45', 'DF923D', 'F1B555', 'FCD163', '99B718',\n                                                  '74A901', '66A000', '529400', '3E8601', '207401', '056201', '004C00', '023B01', '012E01', '011D01', '011301']}\ncountries = ee.FeatureCollection('users/giswqs/public/countries')\nstyle = {'color': '00000088', 'width': 1, 'fillColor': '00000000'}\nndvi = image.visualize(**vis_params)\nblend = ndvi.blend(countries.style(**style))\n# specify region to focus on\nbbox = [180, -88, -180, 88]\nprojection = ccrs.EqualEarth(central_longitude=-180)\n", "functions": ["cartoee.get_map", "cartoee.add_colorbar", "ax.set_title"], "external_vars": ["bbox", "cartoee", "projection", "vis_params", "blend"], "defined_vars": ["cb", "ax"], "parameters": ["blend", "ax"], "libraries": ["from geemap import cartoee", "import ee", "import geemap", "import cartopy.crs as ccrs"]}
{"code": "\nnlcd_stats = \"nlcd_stats.csv\"\n\ngeemap.zonal_stats_by_group(\n    landcover,\n    states,\n    nlcd_stats,\n    statistics_type=\"SUM\",\n    denominator=1e6,\n    decimal_places=2,\n)\n\n#\n", "task": "Calculate the sum of each landcover class within each state using the \"geemap.zonal_stats_by_group\" function. First, define the variable \"nlcd_stats\" to hold the path to the \"nlcd_stats.csv\" file. Then, use the following parameters:  \"landcover\" for the landcover data, \"states\" for the state boundaries, \"nlcd_stats\" for the stats file, \"statistics_type='SUM'\" to calculate the sum, \"denominator=1000000.0\" to express the results in millions, and \"decimal_places=2\" for two decimal places in the output.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nstates = ee.FeatureCollection('TIGER/2018/States')\nimage = ee.Image('USGS/SRTMGL1_003')\n# Add NLCD data\ndataset = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019')\nlandcover = dataset.select('landcover')\n", "functions": ["geemap.zonal_stats_by_group"], "external_vars": ["geemap", "landcover", "states"], "defined_vars": ["nlcd_stats"], "parameters": ["landcover", "states", "nlcd_stats"], "libraries": ["import ee", "import geemap"]}
{"code": "\nm = leafmap.Map(center=[40.427495, -86.913638], zoom=18, height=700)\nm.add_basemap(\"SATELLITE\")\nm\n\n#\n", "task": "Using the `leafmap` library, create a map object named `m` centered at coordinates [40.427495, -86.913638] with a zoom level of 18 and a height of 700 pixels. Then, add a satellite basemap to the map.", "exec_path": "segment-geospatial-main", "context": "import leafmap\n", "functions": ["leafmap.Map", "m.add_basemap"], "external_vars": ["leafmap"], "defined_vars": ["m"], "parameters": ["SATELLITE"], "libraries": ["import leafmap"]}
{"code": "\n# Separate out some of the data into utility variables\ncoordinates = (data.longitude.values, data.latitude.values)\nregion = vd.get_region(coordinates)\n# Use a Mercator projection because Spline is a Cartesian gridder\nprojection = pyproj.Proj(proj=\"merc\", lat_ts=data.latitude.mean())\n#\n", "task": "Using the `data` dataframe, `pyproj` library, and `vd` object, define the following variables: \\n\\n1. `coordinates`: A tuple containing the longitude and latitude values from the `data` dataframe.\\n2. `region`: The region corresponding to the `coordinates` obtained using the `vd.get_region()` function.\\n3. `projection`: A `pyproj.Proj` object with a 'merc' projection and a latitude of true scale set to the mean latitude from the `data` dataframe.", "exec_path": "verde-main", "context": "import pyproj\nimport verde as vd\n# Fetch the wind speed data from Texas.\ndata = vd.datasets.fetch_texas_wind()\n", "functions": ["vd.get_region", "pyproj.Proj", "data.latitude.mean"], "external_vars": ["vd", "pyproj", "data"], "defined_vars": ["projection", "coordinates", "region"], "parameters": ["coordinates"], "libraries": ["import pyproj", "import verde as vd"]}
{"code": "\nm = geemap.Map()\nm.split_map(left_layer=\"Esri.WorldTopoMap\", right_layer=\"OpenTopoMap\")\nm\n\n#\n", "task": "Using the geemap library, create a map object named \"m\" and split it into two layers: \"Esri.WorldTopoMap\" on the left and \"OpenTopoMap\" on the right.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map", "m.split_map"], "external_vars": ["geemap"], "defined_vars": ["m"], "parameters": [], "libraries": ["from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata", "from geemap.datasets import DATA", "import geemap"]}
{"code": "\nregion = ee.Geometry.BBox(-122.5955, 37.5339, -122.0982, 37.8252)\nfc = ee.FeatureCollection(region)\nstyle = {\"color\": \"ffff00ff\", \"fillColor\": \"00000000\"}\nm.add_layer(fc.style(**style), {}, \"ROI\")\n\n#\n", "task": "Using the Earth Engine library (`ee`) and the map object (`m`), define a region (`region`) using the BBox function and create a FeatureCollection (`fc`) from it. Then, create a style dictionary (`style`) for the FeatureCollection and add it to the map with the layer name `ROI`.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nimport ee\nee.Initialize()\nfrom geemap.datasets import get_metadata\nm = geemap.Map()\ngeometry = ee.Geometry.Point([-86.893044, 41.718642])\ndata = 'https://github.com/gee-community/geemap/blob/master/examples/data/us_cities.csv'\n", "functions": ["ee.Geometry.BBox", "ee.FeatureCollection", "m.add_layer", "fc.style"], "external_vars": ["ee", "m"], "defined_vars": ["style", "fc", "region"], "parameters": [37.5339, 37.8252, "region", "ROI", "-122.5955", "-122.0982", "fc.style(**style)", "{}"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import get_metadata"]}
{"code": "\nwidgets.SelectMultiple(\n    options=[\"Apples\", \"Oranges\", \"Pears\"],\n    value=[\"Oranges\"],\n    description=\"Fruits\",\n    disabled=False,\n)\n\n#\n", "task": "Create a multiple selection widget using the `widgets` library. The options should be \"Apples\", \"Oranges\", and \"Pears\". The default selected value should be \"Oranges\". The widget should be labeled \"Fruits\" and should be enabled. Make sure to define the following variables: `widgets` before running this code.", "exec_path": "geemap-master", "context": "from ipywidgets import interact, interactive, fixed, interact_manual\nimport ipywidgets as widgets\nw = widgets.IntSlider(value=10)\nw.value = 50\n", "functions": ["widgets.SelectMultiple"], "external_vars": ["widgets"], "defined_vars": [], "parameters": [], "libraries": ["from ipywidgets import interact, interactive, fixed, interact_manual", "import ipywidgets as widgets"]}
{"code": "\nax.grid()\n\n#\n", "task": "Add a grid to the plot represented by the axes object \"ax\". **Requires:** [ax]", "exec_path": "gemgis_data-main", "context": "import matplotlib.pyplot as plt\nfig, ax = plt.subplots(1, figsize=(5, 5))\n", "functions": ["ax.grid"], "external_vars": ["ax"], "defined_vars": [], "parameters": [], "libraries": ["import matplotlib.pyplot as plt"]}
{"code": "\ngridmet = ee.ImageCollection(\"IDAHO_EPSCOR/GRIDMET\")\n\n#\n", "task": "Using the Earth Engine library (ee), load the GRIDMET image collection and assign it to the variable `gridmet`.", "exec_path": "wxee-main", "context": "import ee\nee.Initialize()\nimport wxee\nwxee.Initialize()\n", "functions": ["ee.ImageCollection"], "external_vars": ["ee"], "defined_vars": ["gridmet"], "parameters": ["IDAHO_EPSCOR/GRIDMET"], "libraries": ["import wxee", "import ee"]}
{"code": "\nplt.imshow(wms_array, extent=[32286000, 32328000,5620000,5648000])\nplt.xlabel('X [m]')\nplt.ylabel('Y [m]')\nplt.text(32294500,5629750, 'Aachen', size = 14)\n", "task": "Display the image stored in the variable `wms_array` using `plt.imshow`. Set the extent of the image to be [32286000, 32328000, 5620000, 5648000]. Label the x and y axes as \"X [m]\" and \"Y [m]\" respectively. Add a text label \"Aachen\" at coordinates (32294500, 5629750) with a font size of 14. Ensure that `plt` is imported from the matplotlib library and `wms_array` is a valid image array. ", "exec_path": "gemgis-main", "context": "import gemgis as gg\nimport matplotlib.pyplot as plt\nwms = gg.web.load_wms('http://www.wms.nrw.de/gd/GK100')\nwms_array = gg.web.load_as_array(url=wms.url, layer='0', style='default', crs='EPSG:4647', bbox=[\n                                 32286000, 32328000, 5620000, 5648000], size=[1400, 933], filetype='image/png')\n", "functions": ["plt.imshow", "plt.xlabel", "plt.ylabel", "plt.text"], "external_vars": ["plt", "wms_array"], "defined_vars": [], "parameters": ["wms_array", "X [m]", "Y [m]", 32294500, 5629750, "Aachen"], "libraries": ["import gemgis as gg", "import matplotlib.pyplot as plt"]}
{"code": "\nbbox = [-80.11, 8.71, -79.24, 9.38]\nsearch = catalog.search(\n    collections=[\"sentinel-1-rtc\"], bbox=bbox, datetime=\"2022-05-02/2022-05-09\"\n)\nitems = search.item_collection()\nprint(f\"Found {len(items)} items\")\nitem = items[0]\n\n#\n", "task": "Define variables named `bbox`, `search`, `items`, and `item`. Use the `catalog` object to search for data in the `sentinel-1-rtc` collection within the specified bounding box (`bbox`) and date range (`2022-05-02/2022-05-09`). Store the results in `search`. Then, use `search.item_collection()` to get the list of items and store them in `items`. Finally, print the number of items found using `len(items)` and `print`, and assign the first item in the `items` list to the `item` variable.", "exec_path": "PlanetaryComputerExamples-main", "context": "import pystac_client\nimport planetary_computer\n#\ncatalog = pystac_client.Client.open(\n    'https://planetarycomputer.microsoft.com/api/stac/v1', modifier=planetary_computer.sign_inplace)\n", "functions": ["catalog.search", "search.item_collection", "print", "len"], "external_vars": ["catalog", "len", "print"], "defined_vars": ["bbox", "search", "items", "item"], "parameters": ["items", "f'Found {len(items)} items'"], "libraries": ["import planetary_computer", "import pystac_client"]}
{"code": "\nif m.user_roi is not None:\n    image = dem.clip(m.user_roi)\n    m.layers[1].visible = False\n    m.add_layer(image, vis_params, \"Clipped DEM\")\n\n#\n", "task": "If the user has defined a region of interest (ROI) in variable `m.user_roi`, clip the digital elevation model (`dem`) to this ROI, storing the result in a variable called `image`.  Then, hide the second layer in `m.layers` and add the clipped image to the map object (`m`) using the provided `vis_params` and the name \"Clipped DEM\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nm = geemap.Map(center=(40, -100), zoom=4)\ndem = ee.Image('USGS/SRTMGL1_003')\nvis_params = {'min': 0, 'max': 4000, 'palette': 'terrain'}\n", "functions": ["dem.clip", "m.add_layer"], "external_vars": ["m", "dem", "vis_params"], "defined_vars": ["image"], "parameters": ["image", "vis_params", "Clipped DEM", "m.user_roi"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nMap = geemap.Map()\n\ncollection = (\n    ee.ImageCollection(\"NOAA/GFS0P25\")\n    .filterDate(\"2018-12-22\", \"2018-12-23\")\n    .limit(24)\n    .select(\"temperature_2m_above_ground\")\n)\n\nvis_params = {\n    \"min\": -40.0,\n    \"max\": 35.0,\n    \"palette\": [\"blue\", \"purple\", \"cyan\", \"green\", \"yellow\", \"red\"],\n}\n\nlabels = [str(n).zfill(2) + \":00\" for n in range(0, 24)]\nMap.add_time_slider(collection, vis_params, labels=labels, time_interval=1, opacity=0.8)\nMap\n\n#\n", "task": "Using the `geemap` library, create an interactive map with a time slider displaying the 2-meter air temperature data from the NOAA GFS0P25 dataset for December 22nd, 2018. The time slider should display hourly data for 24 hours.  Use the `ee` library to access the dataset, filter it for the specified date and time period, and select the temperature variable. Define the following variables: `Map` for the geemap map object, `collection` for the filtered image collection, `labels` for the labels on the time slider, `n` as an iterator for the labels, and `vis_params` for the visualization parameters. The visualization parameters should set the minimum and maximum values for the temperature data and define a color palette.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map", "unknown_function.select", "unknown_function.limit", "unknown_function.filterDate", "ee.ImageCollection", "unknown_function.zfill", "str", "range", "Map.add_time_slider"], "external_vars": ["ee", "geemap", "range", "str"], "defined_vars": ["collection", "Map", "n", "labels", "vis_params"], "parameters": ["temperature_2m_above_ground", 24, "2018-12-22", "2018-12-23", "NOAA/GFS0P25", 2, "n", 0, 24, "collection", "vis_params"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nlast_bands = [\"last_b50\", \"last_b40\", \"last_b30\"]\nlast_image = dataset.select(last_bands)\nm.add_layer(last_image, {\"bands\": last_bands, \"gamma\": 1.5}, \"Landsat 2023\")\n\n#\n", "task": "Using the provided dataset, select bands named \"last_b50\", \"last_b40\", and \"last_b30\" and assign them to the variable last_bands. Then, select these bands from the dataset to create a new image object named last_image. Finally, add this last_image to the map object \"m\" with the specified band names and a gamma value of 1.5, labeling the layer as \"Landsat 2023\".", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nimport ee\nee.Initialize()\nfrom geemap.datasets import get_metadata\nm = geemap.Map()\nimage = ee.Image(\n    'LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318').select(['B5', 'B4', 'B3'])\ndata = 'GOES-17'\ndataset = ee.Image('UMD/hansen/global_forest_change_2023_v1_11')\n", "functions": ["dataset.select", "m.add_layer"], "external_vars": ["dataset", "m"], "defined_vars": ["last_image", "last_bands"], "parameters": ["last_bands", "last_image", "Landsat 2023", "{'bands': last_bands, 'gamma': 1.5}"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import get_metadata"]}
{"code": "\n# create a new orographic projection focused on the Pacific\nprojection = ccrs.Orthographic(-130, -10)\n#\n", "task": "Define a cartopy projection named `projection` using the `ccrs.Orthographic` function with central longitude -130 and central latitude -10.", "exec_path": "geemap-master", "context": "import cartopy.crs as ccrs\n", "functions": ["ccrs.Orthographic"], "external_vars": ["ccrs"], "defined_vars": ["projection"], "parameters": ["-130", "-10"], "libraries": ["import cartopy.crs as ccrs"]}
{"code": "\n###############################################################################\n# Calling :meth:`verde.Chain.fit` will automatically run the data through the\n# chain:\n#\n# #. Apply the blocked median to the input data\n# #. Fit a trend to the blocked data and output the residuals\n# #. Fit the spline to the trend residuals\n\nchain.fit(proj_coords, data.bathymetry_m)\n#\n", "task": "Fit the chain model to the projected coordinates and the bathymetry data from the data object.", "exec_path": "verde-main", "context": "import numpy as np\nimport pyproj\nimport verde as vd\ndata = vd.datasets.fetch_baja_bathymetry()\n# The desired grid spacing in degrees\nspacing = 10 / 60\n# Use Mercator projection because Spline is a Cartesian gridder\nprojection = pyproj.Proj(proj='merc', lat_ts=data.latitude.mean())\nproj_coords = projection(data.longitude.values, data.latitude.values)\n# polynomial trend, and then fits a standard gridder to the trend residuals.\nchain = vd.Chain([('reduce', vd.BlockReduce(np.median, spacing * 111000.0)),\n                 ('trend', vd.Trend(degree=1)), ('spline', vd.Spline())])\n", "functions": ["chain.fit"], "external_vars": ["proj_coords", "chain", "data"], "defined_vars": [], "parameters": ["proj_coords", "data.bathymetry_m"], "libraries": ["import verde as vd", "import pyproj", "import numpy as np"]}
{"code": "\nlen(TNM.find_details()[\"items\"])\n\n#\n", "task": "Get the number of items in the \"items\" list within the \"find_details\" method of the TNM object.", "exec_path": "leafmap-master", "context": "import leafmap\n#\nTNM = leafmap.The_national_map_USGS()\n", "functions": ["len", "TNM.find_details"], "external_vars": ["len", "TNM"], "defined_vars": [], "parameters": ["TNM.find_details()['items']"], "libraries": ["import leafmap"]}
{"code": "\nstats = geemap.image_stats_by_zone(dem, landcover, reducer=\"MEAN\")\nstats\n\n#\n", "task": "Calculate the mean elevation of each landcover type using the `geemap` library. Use the variables `dem` (Digital Elevation Model) and `landcover` to define the zones. Store the results in a variable called `stats`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nimage = ee.Image('USGS/SRTMGL1_003')\nreducer = 'mean'\ndem = ee.Image('USGS/3DEP/10m')\nlandcover = ee.Image(\n    'USGS/NLCD_RELEASES/2019_REL/NLCD/2019').select('landcover')\n", "functions": ["geemap.image_stats_by_zone"], "external_vars": ["dem", "geemap", "landcover"], "defined_vars": ["stats"], "parameters": ["dem", "landcover"], "libraries": ["import ee", "import geemap"]}
{"code": "\nintersection.plot(column='formation', aspect='equal', legend=True)\nplt.grid()\n", "task": "Using the pandas DataFrame \"intersection\" and the matplotlib library \"plt\", create a plot where the column \"formation\" is plotted with equal aspect ratio and a legend. Add a grid to the plot.", "exec_path": "gemgis-main", "context": "import gemgis as gg\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nfile_path = 'data/16_extracting_interfaces_from_geological_maps/'\ngmap = gpd.read_file(file_path + 'interfaces_polygons.shp')\nstratigraphy = ['Sand2', 'Ton', 'Sand1']\ngmap_sorted = gg.vector.sort_by_stratigraphy(\n    gdf=gmap, stratigraphy=stratigraphy)\nintersection = gg.vector.extract_xy_from_polygon_intersections(gdf=gmap_sorted)\n", "functions": ["intersection.plot", "plt.grid"], "external_vars": ["plt", "intersection"], "defined_vars": [], "parameters": [], "libraries": ["import gemgis as gg", "import geopandas as gpd", "import matplotlib.pyplot as plt"]}
{"code": "\nstyle = {\"color\": \"0000FFFF\", \"fillColor\": \"00000000\"}\nm.add_layer(counties, {}, \"Counties Vector\", False)\nm.add_layer(counties.style(**style), {}, \"Counties Raster\")\nm\n\n#\n", "task": "Add the `counties` layer to the map `m` as a vector layer, then add another layer to the map `m` that is a raster representation of the `counties` layer with the style defined by the `style` variable. The `style` variable needs to be defined before running this code.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nm = geemap.Map(center=[64.864983, -147.840441], zoom=4)\ncounties = ee.FeatureCollection(\n    'TIGER/2018/Counties').filter(ee.Filter.eq('STATEFP', '02'))\n", "functions": ["m.add_layer", "m.add_layer", "counties.style"], "external_vars": ["m", "counties"], "defined_vars": ["style"], "parameters": ["counties", "Counties Vector", false, "Counties Raster", "{}", "counties.style(**style)", "{}"], "libraries": ["import ee", "import geemap"]}
{"code": "\n# grid definition for output field\nx = np.arange(0, 5, 0.1)\ny = np.arange(0, 5, 0.1)\n\nmodel = gs.Gaussian(dim=2, var=0.5, len_scale=5, anis=0.5, angles=-0.5)\nkrige = gs.Krige(model, cond_pos=cond_pos, cond_val=cond_val)\ncond_srf = gs.CondSRF(krige)\ncond_srf.set_pos([x, y], \"structured\")\n#\n", "task": "Using the external libraries `gs` and `np`, define a 2-dimensional Gaussian model with variance 0.5, length scale 5, anisotropy 0.5, and angle -0.5. Then, create a Kriging object named `krige` using the defined model and the provided condition positions (`cond_pos`) and values (`cond_val`). Finally, initialize a conditional surface object `cond_srf` based on the `krige` object and set its positions using the structured arrays `x` and `y`, which are defined using `np.arange(0, 5, 0.1)`.", "exec_path": "GSTools", "context": "import gstools as gs\nimport numpy as np\n# conditioning data (x, y, value)\ncond_pos = [[0.3, 1.9, 1.1, 3.3, 4.7], [1.2, 0.6, 3.2, 4.4, 3.8]]\ncond_val = [0.47, 0.56, 0.74, 1.47, 1.74]\n", "functions": ["np.arange", "np.arange", "gs.Gaussian", "gs.Krige", "gs.CondSRF", "cond_srf.set_pos"], "external_vars": ["cond_pos", "cond_val", "np", "gs"], "defined_vars": ["model", "cond_srf", "krige", "x", "y"], "parameters": [0, 5, 0.1, 0, 5, 0.1, "model", "krige", "structured", "[x, y]"], "libraries": ["import numpy as np", "import gstools as gs"]}
{"code": "\n# add gridlines to the map at a specified interval\ncartoee.add_gridlines(ax, interval=[60, 30], linestyle=\"--\")\n#\n", "task": "Using the `cartoee` library, add gridlines to the axis object `ax` with intervals of 60 on the x-axis and 30 on the y-axis.  The gridlines should be dashed. You will need to define the following variables: `cartoee`, `ax`.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nimport ee\nee.Initialize()\nvis_params = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}\npoint = ee.Geometry.Point([-122.4439, 37.7538])\nimage = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(point).filterDate(\n    '2016-01-01', '2016-12-31').sort('CLOUD_COVER').first().select('B[1-7]')\nsrtm = ee.Image('CGIAR/SRTM90_V4')\nregion = [-180, -60, 180, 85]\nvis = {'min': 0, 'max': 3000}\ncmap = 'gist_earth'\n# use cartoee to get a map\nax = cartoee.get_map(srtm, region=region, vis_params=vis, cmap=cmap)\n", "functions": ["cartoee.add_gridlines"], "external_vars": ["ax", "cartoee"], "defined_vars": [], "parameters": ["ax"], "libraries": ["import ee", "import geemap", "from geemap import cartoee", "from geemap.datasets import DATA"]}
{"code": "\n# Assets\nt_assets = rich.table.Table(\"Key\", \"Value\")\nfor key, asset in items[1].assets.items():\n    t_assets.add_row(key, asset.title)\nt_assets\n\n#\n", "task": "Using the `rich` library and the `items` list, create a table called `t_assets` with columns \"Key\" and \"Value\". Iterate through the assets within the second item (`items[1]`) and for each key-asset pair, add a row to `t_assets` containing the key and the title of the asset. Define the variables `t_assets`, `key`, and `asset` within the code.", "exec_path": "PlanetaryComputerExamples-main", "context": "import planetary_computer\nimport pystac_client\nimport rich.table\n# Open the Planetary Computer STAC API\ncatalog = pystac_client.Client.open(\n    'https://planetarycomputer.microsoft.com/api/stac/v1/', modifier=planetary_computer.sign_inplace)\ncollection = catalog.get_collection('usda-cdl')\n# Search the catalog and collection for desired items\nlatitude = 36.7378\nlongitude = -119.7871\nFresno = [longitude, latitude]\ngeometry = {'type': 'Point', 'coordinates': Fresno}\nsearch = catalog.search(collections=collection,\n                        intersects=geometry, datetime='2021')\nitems = list(search.get_items())\n", "functions": ["rich.table.Table", "unknown_function.assets.items", "t_assets.add_row"], "external_vars": ["items", "rich"], "defined_vars": ["t_assets", "key", "asset"], "parameters": ["Key", "Value", "key", "asset.title"], "libraries": ["import planetary_computer", "import rich.table", "import pystac_client"]}
{"code": "\ndata = gg.raster.read_zmap(file_path + 'top_dinant_final_tvd.dat')\ndata\n\n#\n", "task": "Read the zmap data from the file located at `file_path + 'top_dinant_final_tvd.dat'` using the `gg.raster.read_zmap` function and store it in a variable named `data`.", "exec_path": "gemgis-main", "context": "import gemgis as gg\nfile_path = 'data/45_opening_asc_and_zmap_grids/'\n", "functions": ["gg.raster.read_zmap"], "external_vars": ["file_path", "gg"], "defined_vars": ["data"], "parameters": ["file_path + 'top_dinant_final_tvd.dat'"], "libraries": ["import gemgis as gg"]}
{"code": "\nroi = m.user_roi\n\nif roi is None:\n    roi = ee.Geometry.BBox(-112.8089, 33.7306, -88.5951, 46.6244)\n    m.add_layer(roi, {}, \"ROI\")\n\nm.center_object(roi)\n\n#\n", "task": "Define a variable `roi` and set it to the user-defined region of interest (`m.user_roi`). If `roi` is `None`, then define it as a bounding box (`ee.Geometry.BBox`) with coordinates (-112.8089, 33.7306, -88.5951, 46.6244). Add the `roi` as a layer to the map (`m.add_layer`) with the name \"ROI\". Finally, center the map on the `roi` (`m.center_object(roi)`).", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\nm = geemap.Map()\n", "functions": ["ee.Geometry.BBox", "m.add_layer", "m.center_object"], "external_vars": ["m", "ee"], "defined_vars": ["roi"], "parameters": [33.7306, 46.6244, "roi", "ROI", "roi", "-112.8089", "-88.5951", "{}"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\n# Assets\nt_assets = rich.table.Table(\"Key\", \"Value\")\nfor key, asset in items[0].assets.items():\n    t_assets.add_row(key, asset.title)\nt_assets\n\n#\n", "task": "Using the `rich` library and the `items` variable, create a table named `t_assets` with columns \"Key\" and \"Value\".  Populate the table with key-value pairs from the `assets` attribute of the first element in the `items` list. The key should be the key from the `assets` dictionary and the value should be the `title` attribute of the corresponding `asset` object.  Define variables `t_assets`, `key`, and `asset` within this process.", "exec_path": "PlanetaryComputerExamples-main", "context": "import planetary_computer\nimport pystac_client\nimport rich.table\n# Open the Planetary Computer STAC API\ncatalog = pystac_client.Client.open(\n    'https://planetarycomputer.microsoft.com/api/stac/v1', modifier=planetary_computer.sign_inplace)\ncollection = catalog.get_collection('noaa-climate-normals-tabular')\n# Get Items\nitems = list(collection.get_all_items())\n", "functions": ["rich.table.Table", "unknown_function.assets.items", "t_assets.add_row"], "external_vars": ["items", "rich"], "defined_vars": ["t_assets", "key", "asset"], "parameters": ["Key", "Value", "key", "asset.title"], "libraries": ["import planetary_computer", "import rich.table", "import pystac_client"]}
{"code": "\nresult = image.cluster(clusterer)\nm.add_layer(result.randomVisualizer(), {}, \"Clusters\")\nm.add(\"layer_manager\")\nm\n\n#\n", "task": "Cluster the image using the provided `clusterer` and add a layer to the visualization `m` that displays the resulting clusters using a random visualizer. Define a variable `result` to store the clustering output.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nimport ee\nee.Initialize()\nfrom geemap.datasets import get_metadata\nm = geemap.Map()\ngeometry = ee.Geometry.Point([-86.893044, 41.718642])\npoint = ee.Geometry.Point(-99.2222, 46.7816)\ndata = 'GOES-17'\nstart_date = '2020-09-05T15:00:00'\nend_date = '2020-09-06T02:00:00'\nregion = ee.Geometry.BBox(-149.352, 64.5532, -147.0976, 65.1277)\ncollection = geemap.landsat_timeseries(\n    region, start_year=2021, end_year=2021, start_date='06-01', end_date='09-01')\nimage = collection.first()\ntraining = image.sample(**{'region': region, 'scale': 150,\n                        'numPixels': 5000, 'seed': 1, 'geometries': True})\nclusterer = ee.Clusterer.wekaXMeans(\n    minClusters=3, maxClusters=6).train(training)\n", "functions": ["image.cluster", "m.add_layer", "result.randomVisualizer", "m.add"], "external_vars": ["image", "clusterer", "m"], "defined_vars": ["result"], "parameters": ["clusterer", "Clusters", "layer_manager", "result.randomVisualizer()", "{}"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import get_metadata"]}
{"code": "\nin_shp = \"countries.shp\"\nfc = geemap.shp_to_ee(in_shp)\n\n#\n", "task": "Using the `geemap` library, convert the shapefile located at `in_shp` into an Earth Engine FeatureCollection and store it in the variable `fc`.", "exec_path": "geemap-master", "context": "import geemap\n", "functions": ["geemap.shp_to_ee"], "external_vars": ["geemap"], "defined_vars": ["fc", "in_shp"], "parameters": ["in_shp"], "libraries": ["import geemap"]}
{"code": "\ninterfaces = gpd.read_file(file_path + 'interfaces4.shp')\ninterfaces.head()\n\n#\n", "task": "Using the `gpd` library, read the shapefile located at `file_path + 'interfaces4.shp'` and store it in a variable named `interfaces`. Then, display the first few rows of the `interfaces` DataFrame.", "exec_path": "gemgis_data-main", "context": "import geopandas as gpd\n#\nfile_path = 'data/example04_unconformably_dipping_layers/'\n", "functions": ["gpd.read_file", "interfaces.head"], "external_vars": ["file_path", "gpd"], "defined_vars": ["interfaces"], "parameters": ["file_path + 'interfaces4.shp'"], "libraries": ["import geopandas as gpd"]}
{"code": "\nfaults = gpd.read_file(file_path + 'gg_nrw_geotekst_l.shp', bbox=bbox)\nfaults.head()\n\n#\n", "task": "Read a shapefile called \"gg_nrw_geotekst_l.shp\" located at the path specified by `file_path` using the `gpd.read_file` function. Apply the bounding box `bbox` to limit the data read. Store the resulting GeoDataFrame in a variable called `faults` and display the first few rows of the data using `faults.head()`.", "exec_path": "gemgis-main", "context": "import geopandas as gpd\nfile_path = 'data/42_draping_linestrings_over_dem_in_pyvista/'\nbbox = (32250000, 5650000, 32390000, 5760000)\n", "functions": ["gpd.read_file", "faults.head"], "external_vars": ["bbox", "file_path", "gpd"], "defined_vars": ["faults"], "parameters": ["file_path + 'gg_nrw_geotekst_l.shp'"], "libraries": ["import geopandas as gpd"]}
{"code": "\nm = geemap.Map()\n\ncollection = (\n    ee.ImageCollection(\"NOAA/GFS0P25\")\n    .filterDate(\"2018-12-22\", \"2018-12-23\")\n    .limit(24)\n    .select(\"temperature_2m_above_ground\")\n)\n\nvis_params = {\n    \"min\": -40.0,\n    \"max\": 35.0,\n    \"palette\": [\"blue\", \"purple\", \"cyan\", \"green\", \"yellow\", \"red\"],\n}\n\nlabels = [str(n).zfill(2) + \":00\" for n in range(0, 24)]\nm.add_time_slider(collection, vis_params, labels=labels, time_interval=1, opacity=0.8)\nm\n\n#\n", "task": "Using the geemap library, create a map object called \"m\". Then, define an Earth Engine Image Collection named \"collection\" using the \"ee\" library by filtering the \"NOAA/GFS0P25\" collection for the date range \"2018-12-22\" to \"2018-12-23\". Limit the collection to 24 images and select the \"temperature_2m_above_ground\" band.  Define a dictionary called \"vis_params\" to specify the minimum and maximum values, along with a palette for visualizing the temperature data. Create a list of labels called \"labels\" using the \"str\" and \"range\" functions, formatted as \"HH:00\" for each hour between 0 and 23. Finally, using the \"m\" object and \"add_time_slider\" method from geemap, add a time slider to the map, incorporating the \"collection\", \"vis_params\", \"labels\", a time interval of 1 hour, and an opacity of 0.8. Make sure to define the variables \"labels\", \"collection\", \"n\", \"m\", and \"vis_params\".", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["geemap.Map", "unknown_function.select", "unknown_function.limit", "unknown_function.filterDate", "ee.ImageCollection", "unknown_function.zfill", "str", "range", "m.add_time_slider"], "external_vars": ["ee", "geemap", "range", "str"], "defined_vars": ["m", "collection", "n", "labels", "vis_params"], "parameters": ["temperature_2m_above_ground", 24, "2018-12-22", "2018-12-23", "NOAA/GFS0P25", 2, "n", 0, 24, "collection", "vis_params"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\ndef write_vrt(items, asset_key, dest_path):\n    \"\"\"Write a VRT with hrefs extracted from a list of items for a specific asset.\"\"\"\n    hrefs = [pc.sign(item.assets[asset_key].href) for item in items]\n    vsi_hrefs = [f\"/vsicurl/{href}\" for href in hrefs]\n    gdal.BuildVRT(dest_path, vsi_hrefs).FlushCache()\n\n#\n", "task": "Using the `gdal` and `pc` libraries, write a function called `write_vrt` that takes a list of `items`, an `asset_key`, and a `dest_path` as input. The function should extract the hrefs from the `assets` dictionary of each `item` using the provided `asset_key`, sign them using the `pc.sign` function, and construct a VRT file at the specified `dest_path` using these signed hrefs. The function should make use of the `gdal.BuildVRT` and `FlushCache` methods. Ensure to define the following variables within the function: `href`, `hrefs`, `vsi_hrefs`, `item`, and `asset_key`.", "exec_path": "PlanetaryComputerExamples-main", "context": "import planetary_computer as pc\n", "functions": ["pc.sign", "unknown_function.FlushCache", "gdal.BuildVRT"], "external_vars": ["gdal", "pc"], "defined_vars": ["href", "hrefs", "dest_path", "item", "asset_key", "vsi_hrefs", "items"], "parameters": ["dest_path", "vsi_hrefs", "item.assets[asset_key].href"], "libraries": ["import planetary_computer as pc"]}
{"code": "\nleafmap.stac_bounds(url)\n\n#\n", "task": "Use the `leafmap` library to get the bounding box coordinates for the STAC asset specified by the `url` variable.  The `leafmap` library should be imported and the `url` variable should be defined before running this code.", "exec_path": "leafmap-master", "context": "import leafmap\n#\nurl = 'https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json'\n", "functions": ["leafmap.stac_bounds"], "external_vars": ["leafmap", "url"], "defined_vars": [], "parameters": ["url"], "libraries": ["import leafmap"]}
{"code": "\nm = leafmap.Map()\ntext = \"Hello World\"\nm.add_text(text, position=\"bottomright\")\nm\n\n#\n", "task": "Using the `leafmap` library, create a map object named `m`. Define a string variable named `text` with the value \"Hello World\". Add the text to the map at the bottom right position.", "exec_path": "leafmap-master", "context": "import leafmap\n", "functions": ["leafmap.Map", "m.add_text"], "external_vars": ["leafmap"], "defined_vars": ["m", "text"], "parameters": ["text"], "libraries": ["import leafmap"]}
{"code": "\n# use cartoee to get a map\nax = cartoee.get_map(image, vis_params=vis, basemap=basemap, zoom_level=8)\n#\n", "task": "Using the `cartoee` library, create a map object named `ax` using the provided `image` and visualization parameters `vis`.  Set the basemap to `basemap` and zoom level to 8.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap import cartoee\nimport cartopy.io.img_tiles as cimgt\n# get a landsat image to visualize\nimage = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')\n# define the visualization parameters to view\nvis = {'bands': ['B5', 'B4', 'B3'], 'min': 0, 'max': 5000, 'gamma': 1.3}\nbasemap = cimgt.Stamen('terrain-background')\n", "functions": ["cartoee.get_map"], "external_vars": ["cartoee", "vis", "image", "basemap"], "defined_vars": ["ax"], "parameters": ["image"], "libraries": ["from geemap import cartoee", "import ee", "import cartopy.io.img_tiles as cimgt", "import geemap"]}
{"code": "\n# Train a CART classifier with default parameters.\ntrained = ee.Classifier.smileCart().train(training, label, bands)\n\n#\n", "task": "Train a random forest classifier using the `smileCart` algorithm from the Earth Engine library (`ee`). Use the training dataset (`training`), the label column (`label`), and the specified bands (`bands`) to train the classifier. Store the trained classifier in the variable `trained`.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nimport ee\nee.Initialize()\npoint = ee.Geometry.Point([-122.4439, 37.7538])\nimage = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(point).filterDate(\n    '2016-01-01', '2016-12-31').sort('CLOUD_COVER').first().select('B[1-7]')\nnlcd = ee.Image(\n    'USGS/NLCD/NLCD2016').select('landcover').clip(image.geometry())\n# Make the training dataset.\npoints = nlcd.sample(**{'region': image.geometry(), 'scale': 30,\n                     'numPixels': 5000, 'seed': 0, 'geometries': True})\n# Use these bands for prediction.\nbands = ['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7']\n# This property of the table stores the land cover labels.\nlabel = 'landcover'\n# Overlay the points on the imagery to get training.\ntraining = image.select(bands).sampleRegions(\n    **{'collection': points, 'properties': [label], 'scale': 30})\n", "functions": ["unknown_function.train", "ee.Classifier.smileCart"], "external_vars": ["training", "label", "ee", "bands"], "defined_vars": ["trained"], "parameters": ["training", "label", "bands"], "libraries": ["import ee", "import geemap", "from geemap import cartoee", "from geemap.datasets import DATA"]}
{"code": "\nstart_date = \"2016-01-01\"\nend_date = \"2022-12-31\"\nregion = ee.Geometry.BBox(-122.5549, 37.6968, -122.3446, 37.8111)\n\n#\n", "task": "Define the start date, end date, and region using the `ee` library. The start date should be set to `2016-01-01`, the end date to `2022-12-31`, and the region should be a bounding box defined by the coordinates `(-122.5549, 37.6968, -122.3446, 37.8111)`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\nfrom geemap.datasets import DATA\nfrom geemap.datasets import get_metadata\nfrom geemap.legends import builtin_legends\n", "functions": ["ee.Geometry.BBox"], "external_vars": ["ee"], "defined_vars": ["end_date", "region", "start_date"], "parameters": [37.6968, 37.8111, "-122.5549", "-122.3446"], "libraries": ["from geemap.datasets import get_metadata", "import geemap", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import DATA"]}
{"code": "\nclass_palette = nlcd.get(\"landcover_class_palette\").getInfo()\nclass_palette\n\n#\n", "task": "Using the `nlcd` variable, get the landcover class palette information and store it in a variable named `class_palette`.", "exec_path": "geemap-master", "context": "import ee\nee.Initialize()\nimport geemap\npoint = ee.Geometry.Point([-122.4439, 37.7538])\n# point = ee.Geometry.Point([-87.7719, 41.8799])\nimage = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(point).filterDate(\n    '2016-01-01', '2016-12-31').sort('CLOUD_COVER').first().select('B[1-7]')\nnlcd = ee.Image(\n    'USGS/NLCD/NLCD2016').select('landcover').clip(image.geometry())\n", "functions": ["unknown_function.getInfo", "nlcd.get"], "external_vars": ["nlcd"], "defined_vars": ["class_palette"], "parameters": ["landcover_class_palette"], "libraries": ["import ee", "import geemap"]}
{"code": "\nout_landsat_stats = \"landsat_stats.csv\"\ngeemap.zonal_stats(\n    landsat,\n    states,\n    out_landsat_stats,\n    statistics_type=\"MEAN\",\n    scale=1000,\n    return_fc=False,\n)\n\n#\n", "task": "Using the \"geemap\" library, calculate the mean zonal statistics of the \"landsat\" image for each state defined in the \"states\" feature collection. Save the results to a CSV file named \"out_landsat_stats\". Make sure to define the variable \"out_landsat_stats\" before executing the code.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nimport ee\nee.Initialize()\nfrom geemap.datasets import get_metadata\nstates = ee.FeatureCollection('TIGER/2018/States')\nimage = ee.Image('USGS/SRTMGL1_003')\n# Add 5-year Landsat TOA composite\nlandsat = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\n", "functions": ["geemap.zonal_stats"], "external_vars": ["geemap", "landsat", "states"], "defined_vars": ["out_landsat_stats"], "parameters": ["landsat", "states", "out_landsat_stats"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import get_metadata"]}
{"code": "\ngeemap.extract_values_to_points(in_fc, landsat7, \"landsat.csv\")\n\n#\n", "task": "Use the `geemap.extract_values_to_points()` function to extract values from the Landsat 7 image (`landsat7`) to the points in the feature collection (`in_fc`). Save the extracted values to a CSV file named \"landsat.csv\".\\n\\n**Required Variables:**\\n- `in_fc`: Feature Collection containing the points.\\n- `landsat7`: Landsat 7 image.\\n- `geemap`: The geemap library.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nimport ee\nee.Initialize()\nfrom geemap.datasets import get_metadata\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\nimage = ee.ImageCollection('COPERNICUS/S2').filterDate('2023-07-01', '2023-09-01').filter(\n    ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 5)).map(lambda img: img.divide(10000)).median()\nin_shp = 'us_cities.shp'\nin_fc = geemap.shp_to_ee(in_shp)\n", "functions": ["geemap.extract_values_to_points"], "external_vars": ["in_fc", "geemap", "landsat7"], "defined_vars": [], "parameters": ["in_fc", "landsat7", "landsat.csv"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "import ee", "from geemap.datasets import get_metadata"]}
{"code": "\n# Update the mask of the `objectId` layer defined previously using the\n# minimum area mask just defined.\nobjectId = objectId.updateMask(areaMask)\nMap.addLayer(objectId, {}, \"Large hotspots\")\n\n#\n", "task": "Update the mask of the object identified by `objectId` using the `areaMask` and add this masked object as a layer to the `Map` with the name \"Large hotspots\".  Make sure to define the `objectId` variable before executing this code.", "exec_path": "geemap-master", "context": "import geemap\nimport geemap.foliumap as emap\nimport geemap as emap\nimport ee\nee.Initialize()\nMap = geemap.Map(center=[40, -100], zoom=4)\n# Make an area of interest geometry centered on San Francisco.\npoint = ee.Geometry.Point(-122.1899, 37.501)\naoi = point.buffer(10000)\n# area of interest.\nkelvin = ee.Image(\n    'LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318').select(['B10'], ['kelvin']).clip(aoi)\n# Threshold the thermal band to set hot pixels as value 1 and not as 0.\nhotspots = kelvin.gt(303).selfMask().rename('hotspots')\n# Uniquely label the hotspot image objects.\nobjectId = hotspots.connectedComponents(\n    **{'connectedness': ee.Kernel.plus(1), 'maxSize': 128})\n# Compute the number of pixels in each object defined by the \"labels\" band.\nobjectSize = objectId.select('labels').connectedPixelCount(\n    **{'maxSize': 128, 'eightConnected': False})\n# Get a pixel area image.\npixelArea = ee.Image.pixelArea()\n# of an object relates the area of the object in m^2.\nobjectArea = objectSize.multiply(pixelArea)\n# objects below a given size (1 hectare in this case).\nareaMask = objectArea.gte(10000)\n", "functions": ["objectId.updateMask", "Map.addLayer"], "external_vars": ["areaMask", "Map"], "defined_vars": ["objectId"], "parameters": ["areaMask", "objectId", "Large hotspots", "{}"], "libraries": ["import geemap.foliumap as emap", "import geemap as emap", "import ee", "import geemap"]}
{"code": "\n###############################################################################\n# Finally, we can visualise some results. For quickly plotting a covariance\n# model, GSTools provides some helper functions.\n\nax = fit_model.plot(x_max=max(bin_center))\nax.plot(bin_center, gamma)\n\n#\n", "task": "Plot the fitted model and the gamma values on the same plot. Use the provided `fit_model` object to plot the fitted model, setting the maximum x-value to the maximum value in `bin_center`.  Plot the gamma values against the `bin_center` values.  **This will require defining a variable named `ax` to hold the plot object.**", "exec_path": "GSTools", "context": "import numpy as np\nimport gstools as gs\n# structured one. For this, we are going to write another small function\nherten_log_trans = np.log(np.loadtxt('herten_transmissivity.gz'))\ndim, origin, spacing = np.loadtxt('grid_dim_origin_spacing.txt')\n# create a structured grid on which the data is defined\nx_s = np.arange(origin[0], origin[0] + dim[0] * spacing[0], spacing[0])\ny_s = np.arange(origin[1], origin[1] + dim[1] * spacing[1], spacing[1])\n# create the corresponding unstructured grid for the variogram estimation\nx_u, y_u = np.meshgrid(x_s, y_s)\nbins = gs.standard_bins(pos=(x_u, y_u), max_dist=10)\nbin_center, gamma = gs.vario_estimate(\n    (x_u, y_u), herten_log_trans.reshape(-1), bins, sampling_size=2000, sampling_seed=19920516)\n# fit an exponential model\nfit_model = gs.Exponential(dim=2)\n", "functions": ["fit_model.plot", "max", "ax.plot"], "external_vars": ["gamma", "bin_center", "max", "fit_model"], "defined_vars": ["ax"], "parameters": ["bin_center", "bin_center", "gamma"], "libraries": ["import gstools as gs", "import numpy as np"]}
{"code": "\nberlin_bbox = gg.utils.create_polygon_from_location(coordinates=berlin)\n\nprint(berlin_bbox.bounds)\nberlin_bbox\n\n#\n", "task": "Using the `gg` library and the `berlin` variable, create a polygon representing Berlin using the `create_polygon_from_location` function. Assign this polygon to a variable called `berlin_bbox`. Then, print the bounds of this polygon using the `print` function and the `berlin_bbox.bounds` attribute.", "exec_path": "gemgis-main", "context": "import gemgis as gg\nberlin = gg.utils.get_location_coordinate(name='Berlin')\n", "functions": ["gg.utils.create_polygon_from_location", "print"], "external_vars": ["berlin", "print", "gg"], "defined_vars": ["berlin_bbox"], "parameters": ["berlin_bbox.bounds"], "libraries": ["import gemgis as gg"]}
{"code": "\ngeemap.cog_center(url)\n\n#\n", "task": "Use the geemap library to find the center coordinates of the image specified by the `url` variable. The `geemap.cog_center()` function should be used to achieve this. This function requires the `url` variable to be defined, which should represent a valid image URL. You will need to have the `geemap` library installed and imported.", "exec_path": "geemap-master", "context": "import geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nfrom geemap.legends import builtin_legends\nfrom geemap.datasets import get_metadata\ndata = 'https://github.com/gee-community/geemap/blob/master/examples/data/us_cities.csv'\nurl = 'https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif'\n", "functions": ["geemap.cog_center"], "external_vars": ["geemap", "url"], "defined_vars": [], "parameters": ["url"], "libraries": ["import geemap", "from geemap import cartoee", "from geemap.datasets import DATA", "from geemap.legends import builtin_legends", "from geemap.datasets import get_metadata"]}
